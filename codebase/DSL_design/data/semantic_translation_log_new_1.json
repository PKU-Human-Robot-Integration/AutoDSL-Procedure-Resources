{"Molecular Biology & Genetics": {"0": {"subject": "Molecular Biology & Genetics", "enum": 0, "protocol": "Bile Sample Preparation: Collect bile into a sterile bottle. Centrifuge at 3000g for 10 minutes at 4\u00b0C to clear sediments. Aliquot 1 ml into tubes. Store aliquots at -20\u00b0C. ", "compile": [{"i": 0, "sentense": "Bile Sample Preparation: Collect bile into a sterile bottle.", "python": "python\ndef bile_sample_preparation():\n    print(\"Collect bile into a sterile bottle\")\n\nbile_sample_preparation()\n", "biocoder": "python\n# Biocoder Format\n\ndef bile_sample_prep():\n    # Step 1: Collection of bile\n    bile_sample = Fluid('Bile sample')\n    sterile_bottle = Container('Sterile Bottle')\n    \n    # Pouring the bile into the sterile bottle\n    p1000 = Pipette(p1000)\n    p1000.pick_up_tip()\n    p1000.aspirate(bile_sample,1000)\n    p1000.dispense(sterile_bottle,1000)\n\nbile_sample_prep()\n", "result_baseline4": {"opcode": "bile_sample_preparation", "slot": [["String", "Collect bile into a sterile bottle"]], "emit": ""}, "result_baseline5": {"opcode": "bile_sample_prep", "slot": [["Container", null], ["Container", null], ["Device", null], ["Volume", 1000]], "emit": ""}}, {"i": 1, "sentense": "Centrifuge at 3000g for 10 minutes at 4\u00b0C to clear sediments.", "python": "python\ndef centrifuge(speed, time, temperature):\n    if temperature != 4:\n        print(\"Error: Centrifuge must be done at 4\u00b0C\")\n        return\n    print(f\"Centrifuging at {speed}g for {time} minutes at {temperature}\u00b0C to clear sediments\")\n\n# Run the protocol\ncentrifuge(3000, 10, 4)\n", "biocoder": "\nbegin_protocol(\"Centrifuge to clear sediments\");\n\nCentrifuge._create(\"Centrifuge step\", speed=3000*g, temperature=4*C, time=10*minutes);\n\nend_protocol();\n", "result_baseline4": {"opcode": "centrifuge", "slot": [["Force", 3000], ["Time", 10], ["Temperature", 4]], "emit": "Centrifuging to clear sediments"}, "result_baseline5": {"opcode": "Centrifuge", "slot": [["Device", null], ["Force", 3000], ["Temperature", 4], ["Time", 10]], "emit": ""}}, {"i": 2, "sentense": "Aliquot 1 ml into tubes.", "python": "python\n# Define the function to aliquot 1 ml into tubes\ndef aliquot_into_tubes(num_tubes):\n    volume = 1  # 1 ml\n    for i in range(num_tubes):\n        print(f\"Aliquoted {volume} ml into tube {i+1}\")\n\n# Call the function to aliquot 1 ml into 5 tubes\naliquot_into_tubes(5)\n", "biocoder": "cpp\n#include \"Biocoder.h\"\n\nvoid setup()\n{\n  start_protocol(\"Aliquot 1 ml into tubes\");\n}\n\nvoid loop()\n{\n  // Step 1: Aliquot 1 ml into tubes\n  Container tube = new_container(TUBE);\n  Fluid fluid = new_fluid(\"fluid\");\n\n  first_step();\n  Fluid_volume vol = measure_fluid_volume(fluid, ml(1));\n  aliquot(tube, vol, \"1 ml into tubes\");\n}\n\nint main()\n{\n  setup();\n  loop();\n  end_protocol();\n}\n", "result_baseline4": {"opcode": "aliquot_into_tubes", "slot": [["Volume", 1], ["Length", null], ["Mass", null]], "emit": "Printed aliquoted volume into tubes"}, "result_baseline5": {"opcode": "Aliquot", "slot": [["Container", "TUBE"], ["Volume", "1 ml"], ["String", "1 ml into tubes"], ["Device", null]], "emit": "fluid"}}, {"i": 3, "sentense": "Store aliquots at -20\u00b0C.", "python": "python\n# Protocol for storing aliquots at -20\u00b0C\n\n# Define variable for storage temperature\nstorage_temperature = -20\n\n# Print message about storing aliquots at -20\u00b0C\nprint(f\"Store aliquots at {storage_temperature}\u00b0C\")\n", "biocoder": "\n#include \"BioCoder.h\"\n\nvoid main() \n{\n    start_protocol(\"Store Aliquots at -20\u00b0C\");\n\n    //Step 1: Store Aliquots\n    StoreAtMinus20(store_aliquots,\"Aliquots\",-20);\n\n    end_protocol();\n}\n", "result_baseline4": {"opcode": "STORE", "slot": [["Temperature", -20], ["String", "aliquots"], ["Temperature", null]], "emit": ""}, "result_baseline5": {"opcode": "StoreAliquots", "slot": [["String", "Aliquots"], ["Temperature", -20], ["Device", null]], "emit": ""}}]}, "1": {"subject": "Molecular Biology & Genetics", "enum": 1, "protocol": "3' Terminal Nucleosides Determination in RNA: Dissolve yeast tRNA<sup>Phe</sup> or mouse piRNAs in Milli-Q water. Add ammonium acetate buffer and RNase T<sub>2</sub>, then incubate. After RNA hydrolysis, analyze the hydrolysate using an LC/MS system.", "compile": [{"i": 0, "sentense": "3' Terminal Nucleosides Determination in RNA: Dissolve yeast tRNA<sup>Phe</sup> or mouse piRNAs in Milli-Q water.", "python": "python\nimport re\n\ndef determine_terminal_nucleosides(rna_sequence):\n    rna_sequence = rna_sequence.upper()\n\n    # Find the last two nucleotides in the RNA sequence\n    last_two_nucleotides = rna_sequence[-2:]\n\n    return last_two_nucleotides\n\n# Dissolve yeast tRNA-Phe or mouse piRNAs in Milli-Q water\nrna_sequence = \"AUGUCGAAUCCG\"\n\nterminal_nucleosides = determine_terminal_nucleosides(rna_sequence)\nprint(\"Terminal Nucleosides:\", terminal_nucleosides)\n", "biocoder": "python\n# Biocoder Protocol for 3' Terminal Nucleosides Determination in RNA\n\ndef dissolve_RNA():\n    # Creating solutions\n    yeast_tRNA_Phe = Solution(\"yeast tRNA^Phe\", 1.0, \"pure substance\")\n    mouse_piRNAs = Solution(\"mouse piRNAs\", 1.0, \"pure substance\")\n    milli_q_water = Solution(\"Milli-Q water\", 1.0, \"pure substance\")\n    \n    # Dissolving yeast tRNA^Phe in Milli-Q water\n    yeast_tRNA_Phe_solution = mix(yeast_tRNA_Phe, milli_q_water, keep=True)\n    comment(\"yeast tRNA^Phe has been dissolved in Milli-Q water\")\n    \n    # Dissolving mouse piRNAs in Milli-Q water\n    mouse_piRNAs_solution = mix(mouse_piRNAs, milli_q_water, keep=True)\n    comment(\"mouse piRNAs has been dissolved in Milli-Q water\")\n    \n    return yeast_tRNA_Phe_solution, mouse_piRNAs_solution\n\n# Execute the function\ndissolve_RNA()\n", "result_baseline4": {"opcode": "determine_terminal_nucleosides", "slot": [["String", "AUGUCGAAUCCG"]], "emit": "last_two_nucleotides"}, "result_baseline5": {"opcode": "DISSOLVE", "slot": [["Container", "yeast tRNA^Phe"], ["Container", "mouse piRNAs"], ["Container", "Milli-Q water"]], "emit": "solutions"}}, {"i": 1, "sentense": "Add ammonium acetate buffer and RNase T<sub>2</sub>, then incubate.", "python": "python\ndef protocol():\n    # Add ammonium acetate buffer\n    print(\"Adding ammonium acetate buffer...\")\n    \n    # Add RNase T2\n    print(\"Adding RNase T2...\")\n    \n    # Incubate\n    print(\"Incubating...\")\n\nprotocol()\n", "biocoder": "python\nfrom biocoder import *\n\ndef main():\n    # Materials needed\n    p1 = Solution(\"Ammonium Acetate Buffer\")\n    p2 = Solid(\"RNase T2\")\n\n    # Steps of the protocol\n    # Adding materials\n    add(p1, vol(100, ML))\n    add(p2, mass(1, MG))\n    \n    # Incubation\n    incubate(p1, temp(37, degC), time(30, MIN))\n\nmain()\n", "result_baseline4": {"opcode": "protocol", "slot": [["String", "Add ammonium acetate buffer"], ["String", "Add RNase T2"], ["String", "Incubate"]], "emit": ""}, "result_baseline5": {"opcode": "Incubation", "slot": [["Container", "Ammonium Acetate Buffer"], ["Temperature", 37], ["Time", 30]], "emit": ""}}, {"i": 2, "sentense": "After RNA hydrolysis, analyze the hydrolysate using an LC/MS system.", "python": "python\ndef analyze_hydrolysate():\n    # Perform RNA hydrolysis\n    # Analyze the hydrolysate using an LC/MS system\n    print(\"Hydrolysate analysis completed.\")\n\nanalyze_hydrolysate()\n", "biocoder": "\n# Protocol: RNA Hydrolysate Analysis using LC/MS System\n\nbegin_protocol(\"RNA Hydrolysate Analysis\")\n\nbegin_step(\"RNA Hydrolysis\")\ncomment(\"At this step, RNA has been hydrolyzed.\")\nend_step()\n\nbegin_step(\"LC/MS Analysis\")\ncomment(\"Analyze the hydrolysate using an LC/MS system.\")\nend_step()\n\nend_protocol()\n", "result_baseline4": {"opcode": "Hydrolysis Analysis", "slot": [["String", "RNA hydrolysis"], ["String", "Analyze using LC/MS system"]], "emit": "Hydrolysate analysis completed"}, "result_baseline5": {"opcode": "RNA Hydrolysate Analysis", "slot": [], "emit": "LC/MS Analysis results"}}]}, "2": {"subject": "Molecular Biology & Genetics", "enum": 2, "protocol": "Cell Thawing, Splitting, and Transfection: Thaw cells, spin down, and plate in growth media. Event trigger: Split cells at 80% confluency to avoid differentiation. For transfection, seed at low density and change media post-transfection for differentiation or growth.", "compile": [{"i": 0, "sentense": "Cell Thawing, Splitting, and Transfection: Thaw cells, spin down, and plate in growth media.", "python": "python\ndef cell_thawing_splitting_transfection():\n    cells = \"thawed\"\n    spin_down_cells = True\n    plated_cells = True\n    media = \"growth media\"\n\n    print(f\"Cells {cells}, spinning down: {spin_down_cells}, plating in {media}\")\n\ncell_thawing_splitting_transfection()\n", "biocoder": "python\nfrom biocoder import *\n\ndef cell_thaw_split_transfect():\n    # 1. Thaw cells\n    p = Protocol()\n    cells = Sample('Cells', TimeCourse(0, Units.day, 1, Units.day))\n    p.thaw(cells, temp=25, duration=TimeCourse(1, Units.hr))\n\n    # 2. Spin down\n    p.spin(cells, 1000, 'x g', TimeCourse(5, Units.min))\n    p.resuspend_pellet(cells, 1, 'h2o')\n\n    # 3. Plate in growth media\n    media = Reagent('Growth Media')\n    plate = Consumable('Cell culture plate')\n    p.plate(cells, media, plate)\n\n    p.run()\n\ncell_thaw_split_transfect()\n", "result_baseline4": {"opcode": "cell_thawing_splitting_transfection", "slot": [["String", "thawed"], ["Bool", true], ["Bool", true], ["String", "growth media"]], "emit": "None"}, "result_baseline5": {"opcode": "cell_thaw_split_transfect", "slot": [["Device", null], ["Temperature", 25], ["Time", 1], ["Force", 1000], ["String", "x g"], ["Time", 5], ["Mass", 1], ["String", "h2o"], ["Container", null], ["Container", null]], "emit": "Plate in growth media"}}, {"i": 1, "sentense": "Event trigger: Split cells at 80% confluency to avoid differentiation.", "python": "python\n# Define the cellular confluency threshold\nconfluency_threshold = 80\n\n# Check the confluency level of the cells\ncurrent_confluency = 75  # Assume that the current confluency is 75%\n\n# Check if the cells need to be split\nif current_confluency >= confluency_threshold:\n    print(\"Cells are at 80% confluency. Split cells to avoid differentiation.\")\nelse:\n    print(\"Cells are below 80% confluency. No need to split cells at this time.\")\n", "biocoder": "python\nfrom biocoder import *\n\ndef split_cells_at_confluency():\n\n    # Materials needed\n    cells = Material(\"Cells with 80% confluency\")\n    \n    # Procedure\n    p1 = Procedure('Splitting cells at 80% confluency to avoid differentiation')\n    p1.comment('Cells should be split at 80% confluency to avoid differentiation')\n    \n    p1.step('Aspirate the medium from the cell culture')\n    \n    wash1 = p1.step('Wash the cells with 1X PBS')\n    wash1.add_materials(Material('1X PBS'))\n    \n    p1.step('Aspirate the PBS')\n    \n    trypsinize_step = p1.step('Add 1ml of 0.25% trypsin-EDTA solution to the cells and incubate for 2-3 minutes at 37 degrees')\n    trypsinize_step.add_materials(Material('0.25% Trypsin-EDTA solution'))\n    \n    p1.step('Gently tap the flask to ensure complete detachment of the cells')\n    \n    p1.step('Add 2ml of complete growth medium to deactivate trypsin')\n    p1.step('Pipette up and down to resuspend cells')\n    \n    transfer_step = p1.step('Transfer the cell suspension to a new cell culture flask')\n    transfer_step.add_materials(Material('New cell culture flask'))\n    \n    p1.step('Place the flask in the incubator at 37 degrees Celsius with 5% CO2')\n    \n    protocol = Protocol(name='Split cells at 80% confluency protocol', proc_list=[p1])\n    return protocol.get_protocol()\n\nprint(split_cells_at_confluency())\n", "result_baseline4": {"opcode": "CELL_SPLIT", "slot": [["Mass", null], ["Mass", 80]], "emit": "Split cells to avoid differentiation"}, "result_baseline5": {"opcode": "SPLIT", "slot": [["Container", "Cells with 80% confluency"], ["Volume", "1X PBS"], ["Volume", "0.25% Trypsin-EDTA solution"], ["Volume", "complete growth medium"], ["Container", "New cell culture flask"]], "emit": "Split cells at 80% confluency protocol"}}, {"i": 2, "sentense": "For transfection, seed at low density and change media post-transfection for differentiation or growth.", "python": "python\ndef transfection_protocol(density, media_change):\n    if density == \"low\" and media_change == \"differentiation\":\n        print(\"Transfection: Seed at low density and change media for differentiation\")\n    elif density == \"low\" and media_change == \"growth\":\n        print(\"Transfection: Seed at low density and change media for growth\")\n    else:\n        print(\"Incorrect protocol parameters\")\n\ntransfection_protocol(\"low\", \"differentiation\")\n", "biocoder": "cpp\n#include \"BioCoder.h\"\n\nvoid main() {\n    // Start protocol\n    Protocol transfection(\"Transfection protocol for low density seeding\");\n\n    Fluid transfection_medium(\"transfection medium\");\n\n    Container growth_plate = new_plate(\"growth plate\");\n    Container differentiation_plate = new_plate(\"differentiation plate\");\n\n    first_step(\"Seeding at low density\");\n    seed_cells(growth_plate,CELL_SUSPENSION,vol(100, UL), \"Low Density\", incubate_time(30, MINS, 37, CELSIUS));\n\n    next_step(\"Transfection\");\n    transfection(growth_plate, transfection_medium, \"Transfection Protocol\");\n\n    next_step(\"Change medium post-transfection\");\n    change_medium(growth_plate, transfection_medium);\n\n    next_step(\"For differentiation\");\n    change_medium(differentiation_plate, transfection_medium);\n\n    next_step(\"For growth\");\n    incubate(growth_plate, \"Standard Conditions\", incubate_time(24, HRS, 37, CELSIUS));\n\n    // End protocol\n    end_protocol();\n}\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "Transfection", "slot": [["Container", "growth plate"], ["Container", "transfection medium"]], "emit": "Transfection Protocol"}}]}, "3": {"subject": "Molecular Biology & Genetics", "enum": 3, "protocol": "Bile Processing Protocol: Collect bile in sterile bottles from patients with biliary tubes. Centrifuge at 3000g for 10 minutes at 4\u00b0C to remove sediment and debris. Aliquot the clear bile into 1 ml volumes in microcentrifuge tubes. Store the aliquots at -20\u00b0C for future use. ", "compile": [{"i": 0, "sentense": "Bile Processing Protocol: Collect bile in sterile bottles from patients with biliary tubes.", "python": "python\n# Bile Processing Protocol\n\ndef collect_bile(patient_id, collection_date):\n    # Assume bile collection process here\n    collected_bile = \"Bile sample collected from Patient ID: {} on {}\".format(patient_id, collection_date)\n    return collected_bile\n\npatient_id = \"12345\"\ncollection_date = \"2022-10-15\"\nbile_sample = collect_bile(patient_id, collection_date)\nprint(bile_sample)\n", "biocoder": "\n#include \"biocoder.h\"\n\nvoid setup()\n{\n  start_protocol(\"Bile Processing Protocol\");\n}\n\nvoid loop()\n{\n  Fluid bile = new_fluid(\"bile from patients with biliary tubes\");\n  Container sterile_bottles = new_container(STERILE_BOTTLE);\n\n  first_step(\"Collection of Bile\");\n  comment(\"The bile is collected directly from patients with biliary tubes into sterile bottles.\");\n\n  next_step(\"Bile Collection\");\n  collect_fluid(bile, sterile_bottles);\n\n  next_step(\"Storage\");\n  comment(\"Store the collected bile samples in a safe and properly labeled storage space for further analysis.\");\n  \n  end_protocol();\n}\n\nint main()\n{\n  setup();\n\n  loop();\n}\n", "result_baseline4": {"opcode": "COLLECT", "slot": [["String", "12345"], ["Time", "2022-10-15"]], "emit": "Bile sample collected from Patient ID: 12345 on 2022-10-15"}, "result_baseline5": {"opcode": "Bile Processing Protocol", "slot": [["Container", "STERILE_BOTTLE"]], "emit": "Store the collected bile samples in a safe and properly labeled storage space for further analysis."}}, {"i": 1, "sentense": "Centrifuge at 3000g for 10 minutes at 4\u00b0C to remove sediment and debris.", "python": "python\n#Importing necessary libraries\nimport time\n\n#Function to simulate centrifugation\ndef centrifuge():\n    print(\"Centrifuging at 3000g for 10 minutes at 4\u00b0C...\")\n    time.sleep(600) #10 minutes in seconds\n    print(\"Centrifugation complete.\")\n\n#Performing centrifugation\ncentrifuge()\n", "biocoder": "\nbegin_protocol(\"Remove sediment and debris\");\n\ncentrifuge(FV, 3000, rpm, 4, time(10, mins));\n\nend_protocol();\n", "result_baseline4": {"opcode": "CENTRIFUGE", "slot": [["Force", 3000], ["Time", 10], ["Temperature", 4]], "emit": "Centrifugation complete."}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 2, "sentense": "Aliquot the clear bile into 1 ml volumes in microcentrifuge tubes.", "python": "python\nclear_bile_volume = 1000  # in microliters\nnum_tubes = clear_bile_volume // 1000\n\nfor i in range(num_tubes):\n    print(f\"Microcentrifuge tube {i + 1}: 1 ml clear bile\")\n", "biocoder": "Python\nfrom biocoder import *\n\n\ndef bile_aliquot_protocol():\n    # Protocol steps\n    bile = Solution(name='clear bile')\n    microcentrifuge_tubes = Container(name='microcentrifuge tubes')\n\n    # Aliquot the clear bile into 1 ml volumes in microcentrifuge tubes\n    p = Protocol()\n    p.add_step(Transfer(src=bile, dest= microcentrifuge_tubes, amount=V(\"1 ml\")))\n\n    return p\n\nif __name__ == '__main__':\n    p = bile_aliquot_protocol()\n    print(p)\n", "result_baseline4": {"opcode": "MIX", "slot": [["Volume", 1000], ["String", "clear bile"], ["Container", null]], "emit": "Mix well"}, "result_baseline5": {"opcode": "Aliquot", "slot": [["Container", "clear bile"], ["Container", null], ["Volume", "1 ml"]], "emit": "Aliquoted into microcentrifuge tubes"}}, {"i": 3, "sentense": "Store the aliquots at -20\u00b0C for future use.", "python": "python\n# Store the aliquots at -20\u00b0C for future use\nstorage_temperature = -20\n\ndef store_aliquots(storage_temperature):\n    print(f\"Aliquots stored at {storage_temperature}\u00b0C\")\n\nstore_aliquots(storage_temperature)\n", "biocoder": "cpp\n// Store the aliquots at -20\u00b0C for future use.\n", "result_baseline4": {"opcode": "store_aliquots", "slot": [["Temperature", -20]], "emit": "Aliquots stored at -20\u00b0C"}, "result_baseline5": {"opcode": "STORE", "slot": [["Container", null], ["Temperature", "-20\u00b0C"], ["Time", null]], "emit": "Future use"}}]}, "4": {"subject": "Molecular Biology & Genetics", "enum": 4, "protocol": "Bile Collection and Centrifugation: Collect bile into a sterile collection bottle. Use a centrifuge tube to spin at 3000g for 10 minutes at 4\u00b0C. Aliquot the clarified supernatant into microcentrifuge tubes, 1 ml each. Freeze aliquots in microcentrifuge tubes at -20\u00b0C for storage.", "compile": [{"i": 0, "sentense": "Bile Collection and Centrifugation: Collect bile into a sterile collection bottle.", "python": "python\ndef bile_collection_and_centrifugation():\n    # Step 1: Collect bile into a sterile collection bottle\n    collection_bottle = \"sterile collection bottle\"\n    # Step 2: Centrifuge the collected bile\n    centrifuge_time = 10  # minutes\n    centrifuge_speed = 3000  # rpm\n    \n    print(f\"Step 1: Collect bile into a {collection_bottle}\")\n    print(f\"Step 2: Centrifuge the collected bile for {centrifuge_time} minutes at {centrifuge_speed} rpm\")\n    \nbile_collection_and_centrifugation()\n", "biocoder": "cpp\n#include \"BioCoder.h\"\n\nvoid main() {\n\tBioCoder *my_protocol = new BioCoder();\n\tFluid *bile = new Fluid(\"Bile\");\n\n\tContainer *sterile_bottle = my_protocol->new_container(STERILE_COLLECTION_BOTTLE);\n\t\n\tmy_protocol->first_step(\"Bile Collection\");\n\tmy_protocol->collect(bile, sterile_bottle);\n\n\tmy_protocol->run();\n\tdelete my_protocol;\n}\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 1, "sentense": "Use a centrifuge tube to spin at 3000g for 10 minutes at 4\u00b0C.", "python": "python\n# Import necessary libraries\nimport time\n\n# Set the constants\ncentrifuge_speed = 3000  # in g\ncentrifuge_time = 10  # in minutes\ncentrifuge_temperature = 4  # in \u00b0C\n\n# Define a function to simulate spinning in a centrifuge tube\ndef spin_in_centrifuge(speed, time, temperature):\n    print(f\"Spinning at {speed}g for {time} minutes at {temperature}\u00b0C...\")\n    time.sleep(60 * time)  # Convert minutes to seconds\n    print(\"Spin completed.\")\n\n# Run the function\nspin_in_centrifuge(centrifuge_speed, centrifuge_time, centrifuge_temperature)\n", "biocoder": "\nbegin_protocol(\"Spin a centrifuge tube\");\n\nFluid fluid_in_tube;\nContainer tube_in_centrifuge = new_container(CENTRIFUGE_TUBE_50ML);\ntube_in_centrifuge.contain(fluid_in_tube);\n\nCentrifuge.run(tube_in_centrifuge, 3000, time(10, MINS), 4);\n\nend_protocol();\n", "result_baseline4": {"opcode": "SPIN", "slot": [["Force", 3000], ["Time", 10], ["Temperature", 4]], "emit": "Spin completed."}, "result_baseline5": {"opcode": "Spin", "slot": [["Container", "CENTRIFUGE_TUBE_50ML"], ["Time", "10 MINS"], ["Mass", null]], "emit": "Centrifuged tube"}}, {"i": 2, "sentense": "Aliquot the clarified supernatant into microcentrifuge tubes, 1 ml each.", "python": "python\ndef aliquot_supernatant(supernatant_volume, aliquot_volume):\n    num_tubes = supernatant_volume // aliquot_volume\n\n    for i in range(num_tubes):\n        print(f'Aliquoting supernatant into microcentrifuge tube {i+1}')\n\naliquot_supernatant(supernatant_volume=10, aliquot_volume=1)\n", "biocoder": "Python\nfrom biocoder import *\n\ndef protocol():\n    # Create new protocol for processing\n    p = Protocol()\n\n    # Define resources (liquids)\n    supernatant = Solution('clarified supernatant')\n\n    # Define containers (tubes)\n    tubes = p.add_container(Tube(name='microcentrifuge tubes'))\n\n    # Steps in the protocol\n    p.comment('Aliquot the Clarified Supernatant')\n    p.aliquot(tubes, supernatant, Volumes.milliliter(1))\n\n    # Output Biocoder protocol\n    p.print()\n\n# Call the method\nprotocol()\n", "result_baseline4": {"opcode": "ALIQUOT", "slot": [["Volume", 10], ["Volume", 1]], "emit": "Aliquoting supernatant into microcentrifuge tube"}, "result_baseline5": {"opcode": "Aliquot", "slot": [["Container", "microcentrifuge tubes"], ["Container", null], ["Volume", 1]], "emit": "Biocoder protocol"}}, {"i": 3, "sentense": "Freeze aliquots in microcentrifuge tubes at -20\u00b0C for storage.", "python": "python\ndef freeze_aliquots(storage_temp):\n    if storage_temp == -20:\n        print(\"Freezing aliquots in microcentrifuge tubes at -20\u00b0C for storage\")\n\n# Call the function with the specified storage temperature\nfreeze_aliquots(-20)\n", "biocoder": "python\ndef freeze_aliquots():\n    # Parameters:\n    # temperature is in degrees centigrade.\n    temperature = -20\n\n    # Aliquots are stored in microcentrifuge tubes\n    microcentrifuge_tubes = Container(\"microcentrifuge_tubes\")\n\n    # Instructions:\n    # 1. Freeze aliquots in microcentrifuge tubes at -20 degrees centigrade for storage.\n    instr = \"Freeze aliquots in microcentrifuge tubes at \"+str(temperature)+\" degrees centigrade for storage.\"\n    \n    print(instr)\n\nfreeze_aliquots()\n", "result_baseline4": {"opcode": "freeze_aliquots", "slot": [["Temperature", -20]], "emit": "Freezing aliquots in microcentrifuge tubes at -20\u00b0C for storage"}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}]}}, "Biomedical & Clinical Research": {"0": {"subject": "Biomedical & Clinical Research", "enum": 0, "protocol": "Muscle Elasticity Therapy Study: For 4 weeks, repeat 5 sessions per week: Group A performs MET, Group B performs static stretching and motor control exercise.", "compile": [{"i": 0, "sentense": "Muscle Elasticity Therapy Study: For 4 weeks, repeat 5 sessions per week: Group A performs MET, Group B performs static stretching and motor control exercise.", "python": "python\n# Define the groups\ngroup_a = \"MET\"\ngroup_b = \"static stretching and motor control exercise\"\n\n# Loop for 4 weeks\nfor week in range(1, 5):\n    # Repeat 5 sessions per week\n    for session in range(1, 6):\n        # Group A performs MET\n        if group_a == \"MET\":\n            print(f\"Week {week}, Session {session}: Group A performs Muscle Elasticity Therapy (MET)\")\n        # Group B performs static stretching and motor control exercise\n        elif group_b == \"static stretching and motor control exercise\":\n            print(f\"Week {week}, Session {session}: Group B performs static stretching and motor control exercise\")\n", "biocoder": "No program", "result_baseline4": {"opcode": "REPEAT", "slot": [["Time", null], ["Frequency", null], ["REG", "MET"], ["REG", "static stretching and motor control exercise"]], "emit": "Print group activities for 4 weeks and 5 sessions per week"}, "result_baseline5": {"opcode": "No program", "slot": [], "emit": "No specific action mentioned"}}]}, "1": {"subject": "Biomedical & Clinical Research", "enum": 1, "protocol": "Fluorescence Assay for Enzyme Activity: Repeat the addition of substrates and enzyme to the cuvette, and record fluorescence intensity. Keep repeating these additions and measurements until no further change in fluorescence intensity is detected, indicating equilibrium.", "compile": [{"i": 0, "sentense": "Fluorescence Assay for Enzyme Activity: Repeat the addition of substrates and enzyme to the cuvette, and record fluorescence intensity.", "python": "python\ndef fluorescence_assay():\n    substrates = [1, 2, 3, 4]\n    enzyme = 5\n    cuvette = []\n\n    for i in range(10):\n        cuvette.extend(substrates)\n        cuvette.append(enzyme)\n        fluorescence_intensity = sum(cuvette)\n        print(f\"Fluorescence intensity after round {i+1}: {fluorescence_intensity}\")\n\nif __name__ == \"__main__\":\n    fluorescence_assay()\n", "biocoder": "Python\n#Biocoder Python code for Fluorescence Assay for Enzyme Activity\n\nfrom biocoder import *\n\n#intializing necessary lab equipment\ncuvette = new_container(name=\"cuvette\")\n\ndef enzyme_activity_assay(substrate, enzyme, cuvette, repetitions):\n    # Check the parameters for null/empty condition \n    if (not substrate) or (not enzyme) or (not cuvette) or (repetitions <= 0):\n        print(\"Provide valid input parameters.\")\n        return\n    \n    for i in range(repetitions):\n        add_to(cuvette, substrate)\n        add_to(cuvette, enzyme)\n\n        # record fluorescence intensity\n        measure_fluorescence(cuvette)\n\n# Main function to perform the enzyme activity assay\ndef main():\n\n    substrate = Substance(name=\"substrate\")\n    enzyme = Substance(name=\"enzyme\")\n\n    # Perform the assay\n    enzyme_activity_assay(substrate, enzyme, cuvette, 10)  # Repeat 10 times\n\nif __name__ == \"__main__\":\n    main()\n", "result_baseline4": {"opcode": "FLUORESCENCE_ASSAY", "slot": [["Container", "cuvette"], ["Mass", null], ["Volume", null]], "emit": "Fluorescence intensity"}, "result_baseline5": {"opcode": "enzyme_activity_assay", "slot": [["Container", "substrate"], ["Container", "enzyme"], ["Container", "cuvette"], ["Volume", 10]], "emit": "fluorescence intensity"}}, {"i": 1, "sentense": "Keep repeating these additions and measurements until no further change in fluorescence intensity is detected, indicating equilibrium.", "python": "python\ndef measure_fluorescence():\n    # Simulate fluorescence measurement\n    return random.uniform(0, 100)\n\ndef protocol():\n    equilibrium = False\n    prev_intensity = 0\n    \n    while not equilibrium:\n        intensity = measure_fluorescence()\n        \n        if intensity == prev_intensity:\n            equilibrium = True\n            print(\"Equilibrium reached.\")\n        else:\n            prev_intensity = intensity\n    \nprotocol()\n", "biocoder": "\nstart_protocol(\"Monitor Fluorescence Until Equilibrium\");\n \nFluid fluorsample = new_fluid(\"fluorophore sample\");\n \nbool equilibrium = false;\nint previous_intensity = 0;\nint current_intensity = 0;\n\nwhile (equilibrium == false) {\n    measure_fluorescence(fluorsample, &current_intensity);\n\n    if (current_intensity == previous_intensity) {\n       equilibrium = true;\n       comment(\"Equilibrium detected, stopping.\");\n    } else {\n       previous_intensity = current_intensity;\n       next_step();\n    }\n}\n\nend_protocol();\n", "result_baseline4": {"opcode": "measure_fluorescence", "slot": [["Bool", null], ["Mass", null], ["Mass", null]], "emit": "Equilibrium reached."}, "result_baseline5": {"opcode": "Monitor Fluorescence Until Equilibrium", "slot": [["Container", "fluorsample"], ["Bool", false], ["Mass", null], ["Mass", null]], "emit": "Equilibrium detected, stopping."}}]}, "2": {"subject": "Biomedical & Clinical Research", "enum": 2, "protocol": "For in vivo experiments using ViroMag, the volume of virus injected depends on the viral preparation, injection route, target tissue, and preliminary in vitro results. Keep In vivo ViroMag and saline at room temperature. Use 10 to 20 \u00b5L of In vivo ViroMag for each 1x10^6 infectious viral particles, avoiding exceeding recommended injection volumes.", "compile": [{"i": 0, "sentense": "For in vivo experiments using ViroMag, the volume of virus injected depends on the viral preparation, injection route, target tissue, and preliminary in vitro results.", "python": "python\ndef calculate_virus_volume(viral_preparation, injection_route, target_tissue, preliminary_results):\n    if viral_preparation == 'ViroMag':\n        if injection_route == 'intravenous':\n            if target_tissue == 'brain':\n                if preliminary_results == 'positive':\n                    virus_volume = 100 # arbitrary value, adjust as needed\n                else:\n                    virus_volume = 50 # arbitrary value, adjust as needed\n            elif target_tissue == 'liver':\n                if preliminary_results == 'positive':\n                    virus_volume = 75 # arbitrary value, adjust as needed\n                else:\n                    virus_volume = 25 # arbitrary value, adjust as needed\n            else:\n                virus_volume = 50 # arbitrary value, adjust as needed\n        elif injection_route == 'intraperitoneal':\n            if target_tissue == 'spleen':\n                if preliminary_results == 'positive':\n                    virus_volume = 80 # arbitrary value, adjust as needed\n                else:\n                    virus_volume = 40 # arbitrary value, adjust as needed\n            else:\n                virus_volume = 60 # arbitrary value, adjust as needed\n        else:\n            virus_volume = 50 # arbitrary value, adjust as needed\n    else:\n        virus_volume = 0 # no virus injected if not using ViroMag\n        \n    return virus_volume\n\n# Example of using the protocol\nvirus_injection_volume = calculate_virus_volume('ViroMag', 'intravenous', 'brain', 'positive')\nprint(f\"Virus injection volume: {virus_injection_volume} \u00b5l\")\n", "biocoder": "\nProcedure Viromag_Exp_Protocol() \n{\n  Solutions Used\n  ViroMag virus;\n  \n  Steps\n  1. CT.VOLUME_OF_INJECTION := specify_the_volume;\n  2. set_injection_route := specify_the_injection_route;\n  3. set_target_tissue := specify_the_target_tissue;\n  4. preliminary_in_vitro_results := obtain_results;\n}\n\n", "result_baseline4": {"opcode": "calculate_virus_volume", "slot": [["String", "ViroMag"], ["String", "intravenous"], ["String", "brain"], ["String", "positive"]], "emit": "virus_volume"}, "result_baseline5": {"opcode": "Viromag_Exp_Protocol", "slot": [["Volume", null], ["String", "injection route"], ["String", "target tissue"], ["String", null]], "emit": "preliminary in vitro results"}}, {"i": 1, "sentense": "Keep In vivo ViroMag and saline at room temperature.", "python": "python\nin_vivo_viroMag = \"room temperature\"\nsaline = \"room temperature\"\n\nprint(\"In vivo ViroMag stored at:\", in_vivo_viroMag)\nprint(\"Saline stored at:\", saline)\n", "biocoder": "\n# Biocoder version 4\n# Protocol: Keep In vivo ViroMag and saline at room temperature\n\nbeginProtocol(\"Keep In vivo ViroMag and saline at room temperature\")\n\n# Step 1\ncomment(\"Step 1: Normalize conditions\")\n\n# Substep 1.1: Normalize In vivo ViroMag\nFluid invivo_viroMag = new Fluid(\"In vivo ViroMag\", 1.0);\ninvivo_viroMag.storeAtRoomTemperature();\n\n# Substep 1.2: Normalize saline\nFluid saline = new Fluid(\"Saline\", 1.0);\nsaline.storeAtRoomTemperature();\n\nendProtocol();\n", "result_baseline4": {"opcode": "STORAGE_CHECK", "slot": [["Temperature", "room temperature"], ["String", null]], "emit": "Storage verification"}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 2, "sentense": "Use 10 to 20 \u00b5L of In vivo ViroMag for each 1x10^6 infectious viral particles, avoiding exceeding recommended injection volumes.", "python": "python\nviral_particles = 1e6\ninjection_volume = viral_particles // 1e6 * 10\n\nif injection_volume > 20:\n    injection_volume = 20\n\nprint(f\"Use {injection_volume} \u00b5L of In vivo ViroMag for each 1x10^6 infectious viral particles\")\n", "biocoder": "Python\ndef in_vivo_viroMag_transfection():\n    # reagents setup\n    ViroMag = Reagents.ViroMag()\n    viral_particles = Reagents.viral_particles()\n    \n    # properties setup\n    ViroMag_in_use = 10 to 20\n    viral_particles_in_use = 1e6 \n    \n    # Transfection steps\n    comment(\"Use 10 to 20 \u00b5L of In vivo ViroMag for each 1x10^6 infectious viral particles, avoiding exceeding recommended injection volumes.\")\n    transfer(ViroMag, viral_particles, ViroMag_in_use, mix_after=True)\n    \n    execute()\n\nin_vivo_viroMag_transfection()\n", "result_baseline4": {"opcode": "Mixing", "slot": [["Volume", 20], ["Concentration", "viral particles"], ["Container", null]], "emit": "Mix well before use"}, "result_baseline5": {"opcode": "Transfection", "slot": [["Container", "ViroMag"], ["Container", "viral particles"], ["Volume", "10 to 20 \u00b5L"], ["Concentration", "1x10^6 infectious viral particles"], ["Bool", true]], "emit": "execute"}}]}, "3": {"subject": "Biomedical & Clinical Research", "enum": 3, "protocol": "Place the larvae in a 1m^3 box filled with dirt. Feed them the specified food 3-4 times daily at 2-3 hour intervals for optimal growth. Continue feeding until the larvae turn into pupae, at which point increase the food quantity. Once pupae become adults, modify their environment by adding water to facilitate mating. After mating, collect the resulting larvae.", "compile": [{"i": 0, "sentense": "Place the larvae in a 1m^3 box filled with dirt.", "python": "python\nbox_volume = 1 # m^3\nlarvae = 10\n\n# Calculate the dirt volume needed to fill the box\ndirt_volume = box_volume\n\nprint(\"Place\", larvae, \"larvae in a 1m^3 box filled with\", dirt_volume, \"m^3 of dirt.\")\n", "biocoder": "Python\nfrom biocoder import *\n\ndef experiment_protocol():\n    # Materials\n    box = Solid(\"1m^3 box\")\n    dirt = Solid(\"Dirt\")\n    larvae = Organism(\"Larvae\")\n    \n    # Protocol\n    p = Protocol()\n\n    p.add_step(\"Place the larvae in a 1m^3 box filled with dirt.\")\n    \n    # Instructions\n    p.dispense(box, dirt, volumes=\"1 m^3\")\n    p.transfer(larvae, box)\n    \n    return p\n\nprotocol = experiment_protocol()\n", "result_baseline4": {"opcode": "PLACE", "slot": [["Volume", 1], ["Mass", 10], ["Container", null]], "emit": "Instructions"}, "result_baseline5": {"opcode": "TRANSFER", "slot": [["Container", "1m^3 box"], ["Container", "Dirt"], ["Device", null]], "emit": "Larvae"}}, {"i": 1, "sentense": "Feed them the specified food 3-4 times daily at 2-3 hour intervals for optimal growth.", "python": "python\ndef feed_specified_food():\n    for i in range(3, 5):\n        print(f\"Feed specified food {i} times daily at 2-3 hour intervals for optimal growth.\")\n\nfeed_specified_food()\n", "biocoder": "No program", "result_baseline4": {"opcode": "feed_specified_food", "slot": [["Time", null], ["Frequency", null]], "emit": "optimal growth"}, "result_baseline5": {"opcode": "No Program", "slot": [], "emit": "N/A"}}, {"i": 2, "sentense": "Continue feeding until the larvae turn into pupae, at which point increase the food quantity.", "python": "python\nlarvae = True\nfood_quantity = 1\n\nwhile larvae:\n    # feeding the larvae\n    # check if larvae have turned into pupae\n    if larvae_turn_into_pupae():\n        food_quantity += 1\n        print(\"Larvae have turned into pupae. Increasing food quantity to:\", food_quantity)\n        break\n", "biocoder": "Python\n# Biocoder version of the protocol\n\n# Importing needed modules\nfrom biocoder import *\n\n\ndef larva_feeding_protocol():\n    # Create a new step, add details about the process\n    step = Step(\"Continue feeding larvae\")\n\n    # Add components that will interact (i.e. the food and larvae)\n    larvae = Solid(\"larvae\")\n    food = Solid(\"food\")\n\n    # Start the process\n    step.add_item(larvae)\n    step.add_item(food)\n    step.start('Start feeding until the larvae turn into pupae')\n\n    # Set a conditional parameter for moving to the next step\n    step.wait_until_condition(larvae, 'have turned into pupae')\n\n    # Start the next step\n    step.increase(food, 'Increase the food quality')\n    step.start('Increase food supply')\n\n\n# Call the function we wrote\nlarva_feeding_protocol()\n", "result_baseline4": {"opcode": "feeding", "slot": [["Bool", true], ["Mass", 1], ["Mass", null], ["String", "pupae"]], "emit": "increase food quantity"}, "result_baseline5": {"opcode": "FEED", "slot": [["Container", "larvae"], ["Container", "food"], ["String", null]], "emit": "Increased food supply"}}, {"i": 3, "sentense": "Once pupae become adults, modify their environment by adding water to facilitate mating.", "python": "python\ndef modify_environment(pupae):\n    # Check if the pupae have become adults\n    if pupae == \"adult\":\n        # Add water to facilitate mating\n        environment = \"water added for mating\"\n        return environment\n    else:\n        return \"Not yet adults, no modification needed\"\n\n# Test the function with pupae becoming adults\npupae_status = \"adult\"\nmodified_environment = modify_environment(pupae_status)\nprint(modified_environment)\n", "biocoder": "Python\n# Biocoder Python code\nfrom biocoder import *\n\ndef fly_mating_protocol():\n  # Step 1: Identify and isolate adult fly from pupae\n  adults = select('Adult Fly from Pupae')\n  \n  # Step 2: Modify environment to facilitate mating\n  water = Solution('water')\n  add(water)\n\n  # Step 3: Allow for mating\n  wait(hours=24)\n\nif __name__ == \"__main__\":\n  fly_mating_protocol()\n  output()", "result_baseline4": {"opcode": "modify_environment", "slot": [["String", "adult"]], "emit": "water added for mating"}, "result_baseline5": {"opcode": "Fly Mating", "slot": [["Container", "Adult Fly from Pupae"], ["Container", null], ["Time", 24]], "emit": "Modified environment for mating"}}, {"i": 4, "sentense": "After mating, collect the resulting larvae.", "python": "python\n# Protocol for collecting larvae after mating\n\n# Assume the collection process is triggered after mating event occurs\n\ndef collect_larvae():\n    larvae = []  # Initialize an empty list to store resulting larvae\n    \n    # Code to collect larvae goes here\n    # For example, you could use a loop to simulate collecting larvae\n    for i in range(10):  # Collect 10 larvae for demonstration\n        larvae.append(f\"Larva {i+1}\")  # Add larvae to the list\n    \n    return larvae\n\n# Call the function to collect larvae after mating\nresulting_larvae = collect_larvae()\nprint(resulting_larvae)  # Output the resulting larvae\n", "biocoder": "\nbegin_protocol(\"Collecting larvae after mating\");\n\nbegin_step(\"Mating of subjects\");\ncomment(\"Allow the subjects to mate for a specified period.\");\nend_step();\n\nbegin_step(\"Collection of larvae\");\ncomment(\"After the mating period, begin the collection of the resulting larvae. Handle sparingly and with care.\");\nend_step();\n\nend_protocol();\n", "result_baseline4": {"opcode": "COLLECT", "slot": [["String", "larvae"], ["Volume", null], ["Time", null]], "emit": "resulting_larvae"}, "result_baseline5": {"opcode": "Collecting larvae after mating", "slot": [["Time", null], ["String", "specified period"], ["Device", null]], "emit": "resulting larvae"}}]}, "4": {"subject": "Biomedical & Clinical Research", "enum": 4, "protocol": "Larvae Experiment Protocol: Preparation: Place larvae in a pre-filled 1m\u00b3 box with dirt. Feeding: Administer specific food 3-4 times daily at 2-3 hour intervals for optimal growth. Monitoring: Continue feeding until larvae transition to pupals, increasing food supply at this stage. Environmental Change: Upon reaching adulthood, introduce water to the dirt environment for mating. Larvae Collection: Post-mating, collect new larvae.", "compile": [{"i": 0, "sentense": "Larvae Experiment Protocol: Preparation: Place larvae in a pre-filled 1m\u00b3 box with dirt.", "python": "python\ndef larvae_experiment_protocol():\n    box_volume = 1 # m\u00b3\n    dirt = \"dirt\"\n\n    larvae = [\"larva1\", \"larva2\", \"larva3\"] # example list of larvae\n\n    print(\"Preparing for larvae experiment...\")\n    print(\"Placing larvae in a pre-filled\", box_volume, \"m\u00b3 box with\", dirt)\n    print(\"Larvae in box:\", larvae)\n\nlarvae_experiment_protocol()\n", "biocoder": "Python\n# Biocoder format\nfrom biocoder import *\n\n# Creating a Protocol\np = Protocol()\n\n# Defining the preparation step\nbox = Container(\"1m\u00b3 box with dirt\")\nlarvae = Sample(\"Larvae\")\np.add(Dispense(box, larvae, vol=\"1 m\u00b3\"))\n\n# Producing the complete Protocol\np.print()\n", "result_baseline4": {"opcode": "PLACEMENT", "slot": [["Volume", 1], ["String", "dirt"], ["Container", null]], "emit": "Larvae in box"}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 1, "sentense": "Feeding: Administer specific food 3-4 times daily at 2-3 hour intervals for optimal growth.", "python": "python\ndef feed_fish(food, num_times, interval):\n    for i in range(num_times):\n        print(f\"Administering {food} for fish\")\n        time.sleep(interval)\n        \nfood = \"specific food\"\nnum_times = 4\ninterval = 2\n\nfeed_fish(food, num_times, interval)\n", "biocoder": "python\nSolution growth_media = new Solution(\"Growth Media\");\nProcedure incubate = new Procedure(\"Incubate at 37 degrees\");\nProcedure feed = new Procedure(\"Administer Growth Media\");\n\nbegin_protocol(\"Optimal Growth Protocol\")\nfluid_handle(growth_media, incubate)\nfor timepoint in range(0,8,2):\n    fluid_handle(growth_media, feed)\n    incubate(timepoint)\nend_protocol()\n", "result_baseline4": {"opcode": "feed_fish", "slot": [["String", "specific food"], ["Mass", null], ["Time", 2]], "emit": "Administering specific food for fish"}, "result_baseline5": {"opcode": "GROWTH", "slot": [["Container", null], ["Temperature", 37], ["Volume", null]], "emit": "Optimized growth"}}, {"i": 2, "sentense": "Monitoring: Continue feeding until larvae transition to pupals, increasing food supply at this stage.", "python": "python\n# Define initial stage of larvae\nlarvae_stage = True\n\nwhile larvae_stage:\n    # Continue feeding larvae\n    print(\"Feeding larvae\")\n\n    # Check if larvae have transitioned to pupal stage\n    larvae_stage = False\n    # If larvae have transitioned to pupal stage, increase food supply\n    if not larvae_stage:\n        print(\"Increasing food supply\")\n\nprint(\"Larvae have transitioned to pupal stage. Experiment completed.\")\n", "biocoder": "cpp\n#include \"Biocoder.h\"\n\nint main()\n{\n    start_protocol(\"Larvae to Pupal Transition Monitoring Protocol\");\n\n    Fluid food = new_fluid(\"larvae food\", \"l\");\n    Container larvae = new_container(LARVAE);\n\n    while(container_property_check(larvae, \"stage\", \"larvae\"))\n    {\n        first_step(\"Feeding the larvae\");\n        comment(\"Provide a specified amount of food to the larvae at regular intervals.\");\n        measure_fluid(food, A_LITTLE);  // Actual quantity and units need to be defined based on experimental setup\n        add(larvae, food);\n\n        next_step(\"Monitor the larvae\");\n        comment(\"Keeping a close watch for signs that the larvae are transitioning to pupals.\");\n\n        next_step(\"Increase food if necessary\");\n        comment(\"When the larvae reach the transition stage, increase the amount of food provided.\");\n\n        measure_fluid(food, MORE_THAN_BEFORE);  // Actual quantity and units need to be defined based on experimental setup\n        add(larvae, food);\n\n        pause_protocol();\n    }\n\n    end_protocol();\n}\n", "result_baseline4": {"opcode": "feeding", "slot": [["Bool", true]], "emit": "Increasing food supply"}, "result_baseline5": {"opcode": "Transition Monitoring", "slot": [["Container", "LARVAE"], ["Volume", "x l"], ["Volume", "y l"]], "emit": "Larvae to Pupal Transition Monitoring Protocol"}}, {"i": 3, "sentense": "Environmental Change: Upon reaching adulthood, introduce water to the dirt environment for mating.", "python": "python\ndef introduce_water(adulthood):\n    if adulthood:\n        print(\"Water introduced to dirt environment for mating.\")\n    else:\n        print(\"Error: Not an adult, cannot introduce water.\")\n\n# Example usage\nintroduce_water(True)\n", "biocoder": "Python\n# Biocoder program for introducing water to dirt environment for mating upon adulthood\n\nfrom biocoder import *\n\ndef introduce_water():\n    # Step 1: Identify adult organisms\n    adult_organisms_identification = measure_concentration(SOLID, \"adult organisms\")\n    adult_organisms = adult_organisms_identification.result\n    \n    # Step 2: Introduce water to the dirt environment\n    p1000 = Pipettor(P1000)  # Using a P1000 Pipettor for demonstration\n    dirt_environment = Container(\"Dirt environment\")\n\n    water_vol = adult_organisms * Unit(1, 'ml')   # Assume 1ml of water per adult organism\n    water = Solution(\"Water\", water_vol)\n    \n    p1000.transfer(water, dirt_environment, water_vol)\n\n    # Step 3: Initiate mating\n    adults_mating = Mating(adult_organisms)\n    adults_mating.save()\n\nprint(\"Water introduction to dirt environment for mating upon adulthood initiated.\")\nintroduce_water()\n", "result_baseline4": {"opcode": "introduce_water", "slot": [["Bool", true]], "emit": "Print message indicating whether water is introduced to dirt environment for mating or not"}, "result_baseline5": {"opcode": "INTRODUCE_WATER", "slot": [["Container", "Dirt environment"], ["Concentration", null]], "emit": "Mating initiation"}}, {"i": 4, "sentense": "Larvae Collection: Post-mating, collect new larvae.", "python": "python\ndef collect_larvae():\n    # Post-mating, collect new larvae\n    print(\"Collecting new larvae after mating\")\n\n# Call the collect_larvae function to execute the protocol\ncollect_larvae()\n", "biocoder": "Python\n# Biocoder: Larvae Collection Protocol\n\ndef larvae_collection():\n    #Step 1: Post-mating, collect new larvae.\n    post_mating_collect_larvae()\n\ndef post_mating_collect_larvae():\n    new_larvae = Container('New larvae')\n    Collection(new_larvae)\n\nlarvae_collection()\n", "result_baseline4": {"opcode": "collect_larvae", "slot": [], "emit": "Collecting new larvae after mating"}, "result_baseline5": {"opcode": "LARVAE_COLLECTION", "slot": [["Device", null], ["Container", "New larvae"], ["REG", null]], "emit": "Collection of new larvae"}}]}}, "Ecology & Environmental Biology": {"0": {"subject": "Ecology & Environmental Biology", "enum": 0, "protocol": "Thaw frozen samples to room temperature. For homogenization, sterilize a metal spatula, transfer ~50g of sample into an Erlenmeyer flask, add 2 ml of sterilized tap water, and homogenize. Next, place ~20g of homogenized sample into a tissue culture flask, add 20 ml of MDV medium, and gently shake. Autoclave the samples in Erlenmeyer flasks for 15 minutes at 121\u00b0C. Repeat the process of adding sterilized sample and MDV medium to the culture flask, gently shaking for even distribution. Repeat these steps (2.2-2.5) for all samples, including positive controls.", "compile": [{"i": 0, "sentense": "Thaw frozen samples to room temperature.", "python": "python\n# Thaw frozen samples to room temperature\ndef thaw_samples():\n    print(\"Thawing frozen samples to room temperature...\")\n\nthaw_samples()\n", "biocoder": "\n#include <biocoder.h>\n\nvoid setup() {\n  // Thaw frozen samples to room temperature\n  Container samples = new_container(STERILE_EPPENDORF);\n  samples.container_type = FROZEN;\n  thaw(samples, AMBIENT);\n}\n\nint main() {\n  setup();\n  return 0;\n}\n", "result_baseline4": {"opcode": "Thawing", "slot": [["Temperature", null]], "emit": "Samples thawed to room temperature"}, "result_baseline5": {"opcode": "Thaw samples", "slot": [["Container", null], ["Temperature", "room temperature"]], "emit": "Thawed samples at ambient temperature"}}, {"i": 1, "sentense": "For homogenization, sterilize a metal spatula, transfer ~50g of sample into an Erlenmeyer flask, add 2 ml of sterilized tap water, and homogenize.", "python": "python\ndef homogenization(sample_weight):\n    sterilize_spatula()\n    transfer_sample(sample_weight)\n    add_water()\n    homogenize()\n\ndef sterilize_spatula():\n    print(\"Sterilizing metal spatula...\")\n\ndef transfer_sample(sample_weight):\n    print(f\"Transferring {sample_weight}g of sample into an Erlenmeyer flask...\")\n\ndef add_water():\n    print(\"Adding 2 ml of sterilized tap water...\")\n\ndef homogenize():\n    print(\"Homogenizing the sample...\")\n\nsample_weight = 50\nhomogenization(sample_weight)\n", "biocoder": "\nbegin_protocol(\"Homogenization Protocol\");\n\nFluid tap_water = new_fluid(\"sterilized tap water\", vol(2, ML));\nSolid sample = new_solid(\"sample\");\nWeighable_subset sample_subset = weigh(sample, MASS(g, 50));\nContainer flask = new_container(FLASK, Erlenmeyer);\n\ncomment(\"Sterilization\");\nSterilize.spatula();\n\ncomment(\"Sample Transfer\");\nfirst_step;\nTransfer.using_spatula(sample_subset, flask);\n\ncomment(\"Add Water\");\nnext_step;\nTransfer(tap_water, flask);\n\ncomment(\"Homogenization\");\nnext_step;\nHomogenize(flask);\n\nend_protocol();\n", "result_baseline4": {"opcode": "homogenization", "slot": [["Mass", 50], ["Container", "Erlenmeyer flask"], ["Volume", 2]], "emit": "Homogenized sample"}, "result_baseline5": {"opcode": "Homogenization Protocol", "slot": [["Container", "Erlenmeyer"], ["Device", null], ["Mass", 50], ["Volume", 2]], "emit": "Homogenized solution"}}, {"i": 2, "sentense": "Next, place ~20g of homogenized sample into a tissue culture flask, add 20 ml of MDV medium, and gently shake.", "python": "python\n# Protocol for adding homogenized sample to tissue culture flask\n\n# Define variables\nsample_weight = 20 # in grams\nmedium_volume = 20 # in ml\n\n# Calculate and display the amount of homogenized sample\nsample_amount = sample_weight\nprint(f\"Adding {sample_amount}g of homogenized sample to the tissue culture flask...\")\n\n# Add MDV medium to the flask\nprint(f\"Adding {medium_volume} ml of MDV medium to the flask...\")\n\n# Gently shake the flask\nprint(\"Gently shaking the flask...\")\n", "biocoder": "\nsolutions\n{\n\tMedium \"MDV medium\";\n}\n\nprocedure main() \n{\n\tWeigh \"Homogenized sample\", 20;\n\tFlask TCF = new Flask(\"Tissue culture flask\");\n\tTCF.add(\"Homogenized sample\");\n\tTCF.add(\"MDV medium\", 20, ml);\n\tShake(TCF, speed=\"Gentle\");\n}\n", "result_baseline4": {"opcode": "ADD", "slot": [["Mass", 20], ["Volume", 20], ["String", "MDV medium"]], "emit": "Gently shaking the flask..."}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 3, "sentense": "Autoclave the samples in Erlenmeyer flasks for 15 minutes at 121\u00b0C.", "python": "python\nimport time\n\ndef autoclave_samples():\n    print(\"Autoclaving samples in Erlenmeyer flasks...\")\n    time.sleep(900)  # 15 minutes = 900 seconds\n    print(\"Autoclaving process complete.\")\n\nautoclave_samples()\n", "biocoder": "cpp\n#include \"BioCoder.h\"\n\nvoid Autoclave_samples()\n{\n    //Start Protocol\n    start_protocol(\"Autoclave the samples\");\n    \n    Fluid *sample;\n    Container *flask = new_container(FLASK, \"Erlenmeyer flasks\");\n\n    //Step 1: Autoclave the samples\n    sample = auto_sterilize(sample, flask, time_interval(15, MINUTES), 121);\n    \n    end_protocol();\n}\n", "result_baseline4": {"opcode": "autoclave_samples", "slot": [["Container", "Erlenmeyer flasks"], ["Time", 900]], "emit": "Autoclaving process complete."}, "result_baseline5": {"opcode": "AUTOCLAVE", "slot": [["Container", "Erlenmeyer flasks"], ["Time", 15], ["Temperature", 121]], "emit": "Sterilized samples"}}, {"i": 4, "sentense": "Repeat the process of adding sterilized sample and MDV medium to the culture flask, gently shaking for even distribution.", "python": "python\ndef add_sample_to_flask(flask, sample, medium):\n    # Add sterilized sample to culture flask\n    flask += sample\n    # Add MDV medium to culture flask\n    flask += medium\n    return flask\n\ndef shake_flask(flask):\n    # Gently shake culture flask for even distribution\n    return flask\n\n# Initialize culture flask\nflask = []\n\n# Repeat the process of adding sterilized sample and MDV medium to the culture flask, gently shaking for even distribution\nfor i in range(5):  # Repeat 5 times\n    flask = add_sample_to_flask(flask, 'sterilized sample', 'MDV medium')\n    flask = shake_flask(flask)\n\nprint(flask)\n", "biocoder": "\nbegin_protocol(\"Addition of sterilized sample and MDV medium\");\n\nFluid sterilized_sample = new_fluid(\"sterilized sample\");\nFluid mdv_medium = new_fluid(\"MDV medium\");\nContainer culture_flask = new_container(\"culture flask\");\n\nfor (int i=1; i <= n; i++){   // Assuming 'n' is the number of times process needs to be repeated\n    first_step(\"Addition of sterilized sample\");\n    {\n        Pipet* p = new Pipet(P200); // Assuming the volume to be added is within 200\u00b5l range\n        p->pick_up_tip();\n        p->aspirate(sterilized_sample);   // Volume to be aspirated is not specified in the protocol\n        p->dispense(culture_flask);   // Volume to be dispensed is not specified in the protocol\n        p->eject_tip();\n        comment(\"Sterilized sample has been added to the culture flask.\");\n    }\n\n    next_step(\"Addition of MDV medium\");\n    {\n        Pipet* p = new Pipet(P200); // Assuming the volume to be added is within 200\u00b5l range\n        p->pick_up_tip();\n        p->aspirate(mdv_medium);    // Volume to be aspirated is not specified in the protocol\n        p->dispense(culture_flask);  // Volume to be dispensed is not specified in the protocol\n        p->eject_tip();\n        comment(\"MDV medium has been added to the culture flask.\");\n    }\n    \n    next_step(\"Shaking for even distribution\");\n    {\n        vortex(culture_flask);\n        comment(\"Culture flask has been shaken gently for even distribution of the sample and the medium.\");\n    }\n}\n\nend_protocol();\n", "result_baseline4": {"opcode": "CULTURE", "slot": [["Container", "culture flask"], ["String", "sterilized sample"], ["String", "MDV medium"], ["Time", 5]], "emit": "Final culture flask content"}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 5, "sentense": "Repeat these steps (2.2-2.5) for all samples, including positive controls.", "python": "\nsamples = [\"Sample1\", \"Sample2\", \"Sample3\", \"Positive Control\"]\n\nfor sample in samples:\n    print(f\"Processing {sample}\")\n    # Step 2.2\n    step_2_2_result = process_step_2_2(sample)\n    print(f\"Step 2.2 Result: {step_2_2_result}\")\n    \n    # Step 2.3\n    step_2_3_result = process_step_2_3(sample)\n    print(f\"Step 2.3 Result: {step_2_3_result}\")\n    \n    # Step 2.4\n    step_2_4_result = process_step_2_4(sample)\n    print(f\"Step 2.4 Result: {step_2_4_result}\")\n    \n    # Step 2.5\n    step_2_5_result = process_step_2_5(sample)\n    print(f\"Step 2.5 Result: {step_2_5_result}\")\n", "biocoder": "c\n#include \"BioCoder.h\"\n\nvoid main() \n{\n    // Number of samples\n    int n = getNumSamples();\n    \n    // Initialize the samples\n    Fluid sample = new_fluid(\"sample\");\n    Fluid positive_control = new_fluid(\"positive control\");\n    Container all_samples[n];\n    \n    // Loop through all of the samples for steps 2.2-2.5\n    for (int i = 0; i < n; i++) \n    {\n        // Define step 2.2 here\n        operation_step_2_2(all_samples[i]);\n\n        // Define step 2.3 here\n        operation_step_2_3(all_samples[i]);\n\n        // Define step 2.4 here\n        operation_step_2_4(all_samples[i]);\n\n        // Define step 2.5 here\n        operation_step_2_5(all_samples[i]);\n    }\n\n    // Repeat steps for positive control \n    operation_step_2_2(positive_control);\n    operation_step_2_3(positive_control);\n    operation_step_2_4(positive_control);\n    operation_step_2_5(positive_control);\n}\n\n// Here define the functions that perform the operations for steps 2.2-2.5 based on your specific protocol\nvoid operation_step_2_2(Container c) \n{\n    // Add your operation for 2.2 here.\n}\n\nvoid operation_step_2_3(Container c) \n{\n    // Add your operation for 2.3 here.\n}\n\nvoid operation_step_2_4(Container c)\n{\n    // Add your operation for 2.4 here.\n}\n\nvoid operation_step_2_5(Container c)\n{\n    // Add your operation for 2.5 here.\n}\n", "result_baseline4": {"opcode": "Process Samples", "slot": [["Container", null]], "emit": "Processed sample results"}, "result_baseline5": {"opcode": "Perform Operations", "slot": [["Container", "sample"], ["Container", "positive control"]], "emit": "Execute steps 2.2-2.5 for each sample and positive control"}}]}, "1": {"subject": "Ecology & Environmental Biology", "enum": 1, "protocol": "For habituation, mice were placed at the ladder's start and encouraged to move forward using air puffs, repeating until they were accustomed to walking on the rungs. Motor performance was assessed by recording the time and number of foot slips as mice crossed the ladder, with trials repeated 4-5 times daily after a 15-minute interval for 3-4 days to evaluate motor learning. Data analysis involved calculating daily averages of time and foot slips and comparing these between groups. If a mouse failed to place its paws correctly or slipped, this was noted for further analysis, and if video recording was possible, missteps were reviewed afterward.", "compile": [{"i": 0, "sentense": "For habituation, mice were placed at the ladder's start and encouraged to move forward using air puffs, repeating until they were accustomed to walking on the rungs.", "python": "python\ndef habituation_protocol():\n    mouse = \"mice\"\n    ladder_start = \"start\"\n    air_puffs = \"air puffs\"\n    \n    habituated = False\n    \n    while not habituated:\n        mouse_location = ladder_start\n        while mouse_location != \"end\":\n            print(f\"{mouse} is at the {mouse_location}.\")\n            print(f\"{air_puffs} are used to encourage {mouse} to move forward.\")\n            # Update mouse location based on response\n        \n        habituated = True\n\nhabituation_protocol()\n", "biocoder": "\nbegin_protocol(\"Habituation protocol\");\n\nFluid air = new_fluid(\"air\", \"puff\");\nOrganism mice = new_organism(\"mouse\");\n\nLab_equipment ladder = new_lab_equipment(\"ladder\");\n\nCOMMENT(\"STEP 1: Place the mice at the ladder's start\");\noperate_on_organism(ladder, \"{place_start}\", mice);\n\nCOMMENT(\"STEP 2: Use air puff to encourage mice to move forward on ladder rungs\");\n\nWhile(\"{mice_aren't_familiar_with_walking_on_rungs}\") {\n   operate_on_organism_with_fluid(ladder, \"{encourage_forward_movement}\", mice, air);\n}\n\nCOMMENT(\"Repeat the above steps until mice get familiar with walking on ladder rungs\");\n\nend_protocol();\n", "result_baseline4": {"opcode": "HABITUATION", "slot": [["String", "mice"], ["String", "start"], ["String", "air puffs"]], "emit": "Mouse habituated"}, "result_baseline5": {"opcode": "Habituation protocol", "slot": [["String", "place_start"], ["String", "encourage_forward_movement"]], "emit": "mice get familiar with walking on ladder rungs"}}, {"i": 1, "sentense": "Motor performance was assessed by recording the time and number of foot slips as mice crossed the ladder, with trials repeated 4-5 times daily after a 15-minute interval for 3-4 days to evaluate motor learning.", "python": "python\n# Define variables\nnum_trials_per_day = 5\nnum_days = 4\ntime_interval = 15\ntotal_trials = num_trials_per_day * num_days\n\n# Initialize lists to store time and foot slips for each trial\ntime_list = []\nfoot_slips_list = []\n\n# Simulate the experiment\nfor day in range(num_days):\n    for trial in range(num_trials_per_day):\n        time = float(input(f\"Enter time taken for trial {trial+1} on day {day+1}: \"))\n        foot_slips = int(input(f\"Enter number of foot slips for trial {trial+1} on day {day+1}: \"))\n        time_list.append(time)\n        foot_slips_list.append(foot_slips)\n\n# Calculate average time and foot slips\navg_time = sum(time_list) / total_trials\navg_foot_slips = sum(foot_slips_list) / total_trials\n\n# Output results\nprint(f\"Average time taken: {avg_time}\")\nprint(f\"Average number of foot slips: {avg_foot_slips}\")\n", "biocoder": "No program", "result_baseline4": {"opcode": "EXPERIMENT", "slot": [["Time", null], ["Mass", null]], "emit": "Average time taken and foot slips"}, "result_baseline5": {"opcode": "Experiment", "slot": [], "emit": "Data analysis"}}, {"i": 2, "sentense": "Data analysis involved calculating daily averages of time and foot slips and comparing these between groups.", "python": "python\n# Data analysis protocol\n\n# Function to calculate daily average of time\ndef calculate_daily_avg_time(data):\n    daily_time_avg = []\n    for day in data:\n        daily_time_avg.append(sum(day['time']) / len(day['time']))\n    return daily_time_avg\n\n# Function to calculate daily average of foot slips\ndef calculate_daily_avg_foot_slips(data):\n    daily_foot_slips_avg = []\n    for day in data:\n        daily_foot_slips_avg.append(sum(day['foot_slips']) / len(day['foot_slips']))\n    return daily_foot_slips_avg\n\n# Comparison between groups\ndef compare_groups(group1_data, group2_data):\n    group1_time_avg = calculate_daily_avg_time(group1_data)\n    group2_time_avg = calculate_daily_avg_time(group2_data)\n    \n    group1_foot_slips_avg = calculate_daily_avg_foot_slips(group1_data)\n    group2_foot_slips_avg = calculate_daily_avg_foot_slips(group2_data)\n    \n    # Compare daily average time between groups\n    for i in range(len(group1_time_avg)):\n        if group1_time_avg[i] > group2_time_avg[i]:\n            print(f\"Group 1 had a higher daily average time on day {i+1}\")\n        elif group1_time_avg[i] < group2_time_avg[i]:\n            print(f\"Group 2 had a higher daily average time on day {i+1}\")\n        else:\n            print(f\"Both groups had the same daily average time on day {i+1}\")\n            \n    # Compare daily average foot slips between groups\n    for i in range(len(group1_foot_slips_avg)):\n        if group1_foot_slips_avg[i] > group2_foot_slips_avg[i]:\n            print(f\"Group 1 had a higher daily average foot slips on day {i+1}\")\n        elif group1_foot_slips_avg[i] < group2_foot_slips_avg[i]:\n            print(f\"Group 2 had a higher daily average foot slips on day {i+1}\")\n        else:\n            print(f\"Both groups had the same daily average foot slips on day {i+1}\")\n\n# Sample data for testing the protocol\ngroup1_data = [{'time': [10, 15, 20], 'foot_slips': [2, 3, 4]}, {'time': [11, 16, 21], 'foot_slips': [3, 4, 5]}]\ngroup2_data = [{'time': [12, 17, 22], 'foot_slips': [2, 4, 3]}, {'time': [13, 18, 23], 'foot_slips': [4, 3, 2]}]\n\n# Run the protocol with sample data\ncompare_groups(group1_data, group2_data)\n", "biocoder": "No program", "result_baseline4": {"opcode": "compare_groups", "slot": [["Container", "group1_data"], ["Container", "group2_data"]], "emit": "Comparison results between groups"}, "result_baseline5": {"opcode": "Experiment", "slot": [["Time", "24 hours"], ["Device", "Microscope"], ["Container", null]], "emit": "Cell viability analysis"}}, {"i": 3, "sentense": "If a mouse failed to place its paws correctly or slipped, this was noted for further analysis, and if video recording was possible, missteps were reviewed afterward.", "python": "python\n# Check if mouse failed to place paws correctly or slipped\nfailed_to_place_paws = False\nslipped = False\n\n# If mouse failed to place paws correctly or slipped, note for further analysis\nif failed_to_place_paws or slipped:\n    print(\"Mouse failed to place its paws correctly or slipped. Further analysis needed.\")\n\n# If video recording was possible, review missteps afterward\nvideo_recording_possible = True\n\nif video_recording_possible:\n    print(\"Missteps were reviewed afterward.\")\n", "biocoder": "c++\nProcedure mouse_analysis()\n{\n   Start_protocol(\"Mouse Paw Placement Analysis\")\n\n   Mouse mouse_subject(\"Subject 1\");\n\n   Observation mouse_paw_placement(\"If a mouse failed to place its paws correctly or slipped\");\n   \n   if (mouse_subject.behavior == mouse_paw_placement)\n   {\n        note(\"The mouse failed to place its paw correctly or slipped\");\n        if (video_recording==true)\n        {\n           Review_behavior(\"Missteps\");\n        }\n   }\n\n   End_protocol();\n}\n", "result_baseline4": {"opcode": "Note Failure Analysis", "slot": [["Bool", false], ["Bool", false]], "emit": "Further analysis needed"}, "result_baseline5": {"opcode": "Mouse Paw Placement Analysis", "slot": [["Device", "Mouse"], ["Container", null], ["Bool", "video_recording"]], "emit": "Review_behavior"}}]}, "2": {"subject": "Ecology & Environmental Biology", "enum": 2, "protocol": "Premoisten 3 swabs with 1.5 mL of PBST solution and press out excess against the tube's wall. In parallel, for each sampling location, swab target surfaces three times using the 3 swabs together, rotating and switching order each time to ensure consistent application. Return swabs to the tube after breaking at the breakpoint. Collect two negative field controls, one at the start and end of the session, and prepare two unopened PBST tubes as negative media controls. Store all samples in a cooler with ice for up to 12 hours. This method emphasizes parallel actions in swabbing and sample preparation, aligning with a parallel-for execution model in experimental procedures.", "compile": [{"i": 0, "sentense": "Premoisten 3 swabs with 1.5 mL of PBST solution and press out excess against the tube's wall.", "python": "python\ndef premoisten_swabs(swab_count, pbst_volume):\n    total_pbst_volume = swab_count * pbst_volume\n    print(f\"Premoisten {swab_count} swabs with {total_pbst_volume} mL of PBST solution and press out excess against the tube's wall.\")\n\npremoisten_swabs(3, 1.5)\n", "biocoder": "\nbegin_protocol(\"Premoisten 3 swabs with 1.5 mL of PBST solution\");\n\nFluid fluid1 = new_RNase_free(\"PBST solution\", vol(1.5, ML));\nSolid solid1 = new_Solid(\"swabs\");\n\nfirst_step(\"Premoisten 3 swabs\");\npipet_into(solid1, fluid1, vol(0.5, ML));\npipet_into(solid1, fluid1, vol(0.5, ML));\npipet_into(solid1, fluid1, vol(0.5, ML));\n\nsecond_step(\"Press out excess against the tube's wall\");\ncomment(\"Press the swabs against the wall of the tube to remove excess PBST solution.\");\n\nend_protocol();\n", "result_baseline4": {"opcode": "premoisten_swabs", "slot": [["Volume", 3], ["Volume", 1.5]], "emit": "Premoisten swabs with PBST solution"}, "result_baseline5": {"opcode": "Premoisten swabs", "slot": [["Container", "swabs"], ["Volume", 1.5], ["Volume", 0.5], ["Volume", 0.5], ["Volume", 0.5]], "emit": "Excess PBST solution removal"}}, {"i": 1, "sentense": "In parallel, for each sampling location, swab target surfaces three times using the 3 swabs together, rotating and switching order each time to ensure consistent application.", "python": "python\ndef swab_surface(location):\n    for i in range(3):\n        print(f\"Swabbing surface at {location} - Round {i+1}\")\n        # Perform swabbing action with 3 swabs together\n        # Rotate and switch order of swabs each time\n\n# Define sampling locations\nsampling_locations = [\"Location A\", \"Location B\", \"Location C\"]\n\n# Swab target surfaces at each sampling location in parallel\nfor location in sampling_locations:\n    swab_surface(location)\n", "biocoder": "python\n# Biocoder Python code\n\nimport biocoder\n\ndef swab_sampling():\n\n    # Defining the tools and reagents needed\n    swabs = biocoder.Tool('Swabs')\n    sampling_location = biocoder.Location('Sampling location')\n    \n    # In parallel, for each sampling location\n    for location in sampling_location:\n        \n        # Swab target surfaces three times using the 3 swabs together\n        for _ in range(3):\n\n            # Rotate and switch order each time to ensure consistent application\n            biocoder.start_protocol(steps=3)\n            biocoder.touch(location, swabs)\n            biocoder.measure('Rotate and switch order')\n            biocoder.end_protocol()\n        \n\nif __name__ == '__main__':\n    biocoder.run(swab_sampling())\n", "result_baseline4": {"opcode": "Swabbing", "slot": [["Container", "swabs"], ["String", null]], "emit": "Swabbing surface at specified locations"}, "result_baseline5": {"opcode": "Swabbing", "slot": [["Device", null], ["Container", null], ["Time", null]], "emit": "Swabbing target surfaces using swabs"}}, {"i": 2, "sentense": "Return swabs to the tube after breaking at the breakpoint.", "python": "python\ndef return_swabs_to_tube(swabs, breakpoint):\n    if breakpoint <= len(swabs):\n        tube = swabs[breakpoint:]\n        return tube\n    else:\n        print(\"Breakpoint is beyond the length of swabs\")\n        return swabs\n\nswabs = [\"swab1\", \"swab2\", \"swab3\", \"swab4\", \"swab5\"]\nbreakpoint = 2\ntube = return_swabs_to_tube(swabs, breakpoint)\nprint(tube)\n", "biocoder": "python\nfrom biocoder import *\n\ndef swab_return_to_tube():\n  # Materials needed\n  swab = Material('Swab')\n  tube = Material('Tube')\n  \n  p = Protocol()\n  \n  # Step 1: Breaking the swab at the breakpoint and returning it to the tube\n  p.add_step('Break the swab at the breakpoint and return it to the tube.', Inputs(swab), Outputs(swab, tube))\n  \n  return p\n\nprint(swab_return_to_tube())\n", "result_baseline4": {"opcode": "return_swabs_to_tube", "slot": [["Container", "swabs"], ["Length", 2]], "emit": "tube"}, "result_baseline5": {"opcode": "return_to_tube", "slot": [["Device", "Swab"], ["Device", null]], "emit": "Tube"}}, {"i": 3, "sentense": "Collect two negative field controls, one at the start and end of the session, and prepare two unopened PBST tubes as negative media controls.", "python": "python\n# Define the functions for collecting negative field controls and preparing negative media controls\ndef collect_negative_field_control():\n    print(\"Collecting negative field control...\")\n\ndef prepare_negative_media_control():\n    print(\"Preparing negative media control...\")\n\n# Collect negative field control at the start of the session\ncollect_negative_field_control()\n\n# Prepare two unopened PBST tubes as negative media controls\nfor i in range(2):\n    prepare_negative_media_control()\n\n# Collect another negative field control at the end of the session\ncollect_negative_field_control()\n", "biocoder": "\n# Protocol: Collection and Preparation of Negative Controls\n\nbegin_protocol \"Collection and Preparation of Negative Controls\";\n\n# Step 1: Collection of two negative field controls.\n# One at the start and end of the session\nstep\n    \"Collect two negative field controls\"\n    note \"Collect the first negative field control at the beginning of the session, and the second one at the end.\";\n# Step 2: Preparation of two unopened PBST tubes.\nstep\n    \"Prepare two unopened PBST tubes\"\n    note \"These will act as negative media controls.\";\nend_protocol;\n", "result_baseline4": {"opcode": "Negative_Control_Preparation", "slot": [["Device", "PBST tube"], ["Container", "unopened"], ["Container", "unopened"]], "emit": "Negative field controls and negative media controls prepared"}, "result_baseline5": {"opcode": "Collection and Preparation of Negative Controls", "slot": [["String", "Collect two negative field controls"], ["String", "Prepare two unopened PBST tubes"], ["Volume", null]], "emit": "Collection and preparation of negative controls"}}, {"i": 4, "sentense": "Store all samples in a cooler with ice for up to 12 hours.", "python": "python\nsamples = []\n\ndef store_samples_in_cooler(sample, hours):\n    if hours <= 12:\n        cooler = \"cooler with ice\"\n        samples.append(sample)\n        print(f\"Sample {sample} stored in {cooler} for {hours} hours\")\n    else:\n        print(\"Samples can only be stored for up to 12 hours\")\n\nstore_samples_in_cooler(\"Sample 1\", 6)\nstore_samples_in_cooler(\"Sample 2\", 15)\n", "biocoder": "python\n# Biocoder.py\n\nfrom biocoder import *\n\ndef store_samples_in_cooler():\n  # Step 1: Store all samples in a cooler with ice for up to 12 hours.\n  samples = Container('Samples')\n  ice_cooler = Equipment('Ice Cooler')\n  store(samples, ice_cooler, Time(12, 'hr'))\n\nstore_samples_in_cooler()\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 5, "sentense": "This method emphasizes parallel actions in swabbing and sample preparation, aligning with a parallel-for execution model in experimental procedures.", "python": "python\nimport concurrent.futures\n\ndef swab():\n    print(\"Swabbing the sample\")\n\ndef prepare_sample():\n    print(\"Preparing the sample\")\n\n# Create a ThreadPoolExecutor\nwith concurrent.futures.ThreadPoolExecutor() as executor:\n    # Submit tasks for swabbing and preparing sample\n    swab_future = executor.submit(swab)\n    sample_future = executor.submit(prepare_sample)\n\n    # Wait for both tasks to complete\n    swab_future.result()\n    sample_future.result()\n", "biocoder": "python\ndef swab_and_sample_preparation():\n    begin_parallel()\n    begin_step(\"Swabbing\")\n    comment(\"Perform swabbing according to the specific procedure\")\n    end_step(\"Swabbing\")\n\n    begin_step(\"Sample Preparation\")\n    comment(\"Perform sample preparation according to the specific procedure\")\n    end_step(\"Sample Preparation\")\n    end_parallel()\n\n", "result_baseline4": {"opcode": "Swab and Prepare Sample", "slot": [["REG", null], ["Time", null], ["Device", null]], "emit": "None"}, "result_baseline5": {"opcode": "swab_and_sample_preparation", "slot": [["String", "Perform swabbing according to the specific procedure"], ["String", "Perform sample preparation according to the specific procedure"], ["Device", null]], "emit": "Z-stack images"}}]}, "3": {"subject": "Ecology & Environmental Biology", "enum": 3, "protocol": "Premoisten 3 swabs with 1.5 mL of buffer solution (Phosphate Buffered Saline with 0.02% Tween 80, PBST) in a 15 mL falcon tube. Press out excess solution inside the tube, swab target surfaces three times using 3 swabs together, ensuring consistent pressure and speed, and rotate swabs for each sampling. Break the swab at its breakpoint and return it to the falcon tube. Collect two negative field controls, one at the start and one at the end of sampling, and prepare two unopened tubes of PBST as negative media controls. Store all samples in a cooler with ice for up to 12 hours during collection. Proceed with swab extraction, sample aggregation, and subsequent cultivation as per the experimental setup.", "compile": [{"i": 0, "sentense": "Premoisten 3 swabs with 1.5 mL of buffer solution (Phosphate Buffered Saline with 0.02% Tween 80, PBST) in a 15 mL falcon tube."}, {"i": 1, "sentense": "Press out excess solution inside the tube, swab target surfaces three times using 3 swabs together, ensuring consistent pressure and speed, and rotate swabs for each sampling.", "python": "python\ndef collect_samples():\n    excess_solution = 0\n    for _ in range(3):\n        tube = press_out_excess_solution(excess_solution)\n        swabs = [tube.swab() for _ in range(3)]\n        for swab in swabs:\n            swab.apply_pressure()\n            swab.move_at_consistent_speed()\n            swab.rotate()\n            \ndef press_out_excess_solution(amount):\n    return Tube(amount)\n    \nclass Tube:\n    def __init__(self, excess_solution):\n        self.excess_solution = excess_solution\n        \n    def swab(self):\n        return Swab()\n    \nclass Swab:\n    def apply_pressure(self):\n        print(\"Applying consistent pressure\")\n        \n    def move_at_consistent_speed(self):\n        print(\"Moving at consistent speed\")\n        \n    def rotate(self):\n        print(\"Rotating for sampling\")\n        \ncollect_samples()\n", "biocoder": "cpp\n#include \"Biocoder.h\"\n\nint main()\n{\n    start_protocol(\"Surfaces Swabbing Protocol\");\n    \n    Fluid excess_solution = new_fluid(\"excess solution\");\n    Container tube = new_container(STERILE_MICROFUGE_TUBE);\n    \n    first_step(\"Press out Excess Solution\");\n    aspirate(tube, excess_solution, 500);  // Assuming excess solution size is 500 microliter \n\n    next_step(\"Swab Target Surfaces\");\n    comment(\"Swab surfaces three times with 3 swabs together, ensuring consistent pressure and speed. Rotate swabs after each sampling.\");\n\n    // Since Biocoder doesn't cover physical actions such as swabbing, we use a comment to describe the procedure. \n\n    end_protocol();\n}\n", "result_baseline4": {"opcode": "COLLECT", "slot": [["Device", "Tube"], ["Device", "Swab"], ["Time", "3 times"]], "emit": "Z-stack images"}, "result_baseline5": {"opcode": "Surfaces Swabbing Protocol", "slot": [["Container", "STERILE_MICROFUGE_TUBE"], ["String", "Press out Excess Solution"], ["Volume", 500], ["String", "Swab Target Surfaces"]], "emit": "Comment: Swab surfaces three times with 3 swabs together, ensuring consistent pressure and speed. Rotate swabs after each sampling."}}, {"i": 2, "sentense": "Break the swab at its breakpoint and return it to the falcon tube.", "python": "python\ndef break_swab():\n    # Break the swab at its breakpoint\n    swab = \"Swab\"\n    breakpoint = \"Breakpoint\"\n    swab_broken = swab + \" at \" + breakpoint\n    \n    # Return the broken swab to the falcon tube\n    falcon_tube = \"Falcon Tube\"\n    \n    return swab_broken, falcon_tube\n\n# Call the function to break the swab and return it to the falcon tube\nswab_broken, falcon_tube = break_swab()\nprint(\"Broken swab:\", swab_broken)\nprint(\"Returned to falcon tube:\", falcon_tube)\n", "biocoder": "python\n# Biocoder protocol for breaking the swab at its breakpoint and returning it to the falcon tube\n\ndef break_swab_and_return():\n    #Start the protocol\n    begin_protocol(\"Break the swab at its breakpoint and return it to the falcon tube\")\n    \n    #Individual steps in the protocol \n    swab = SolidItems(item_name='swab') \n    falcon_tube = Container(container_name='Falcon tube')\n    \n    comment('Break the swab at its breakpoint')\n    swab.break_at_breakpoint()\n\n    comment('Return the swab to the falcon tube')\n    falcon_tube.add(swab)\n    \n    #End the protocol\n    end_protocol()\n", "result_baseline4": {"opcode": "break_swab", "slot": [["Device", "Swab"], ["Container", "Falcon Tube"]], "emit": "Broken swab and returned to falcon tube"}, "result_baseline5": {"opcode": "SWAB_PROCESSING", "slot": [["Container", "Falcon tube"], ["Container", null], ["String", "swab"], ["Device", null]], "emit": "Processed swab returned to Falcon tube"}}, {"i": 3, "sentense": "Collect two negative field controls, one at the start and one at the end of sampling, and prepare two unopened tubes of PBST as negative media controls.", "python": "python\n# Protocol for collecting negative field controls and preparing negative media controls\n\ndef collect_negative_field_control():\n    print(\"Collecting negative field control at the start of sampling\")\n    # Code for collecting negative field control at the start of sampling\n    \n    print(\"Collecting negative field control at the end of sampling\")\n    # Code for collecting negative field control at the end of sampling\n\ndef prepare_negative_media_control():\n    print(\"Preparing two unopened tubes of PBST as negative media controls\")\n\n# Call the functions to execute the protocol\ncollect_negative_field_control()\nprepare_negative_media_control()\n", "biocoder": "\nbegin_protocol(\"Collective Negative Field and Media Control\");\n\nbegin_step(\"Collect First Negative Field Control\");\ncomment(\"Collect the first negative field control at the start of the sampling\");\nend_step(\"Collect First Negative Field Control\");\n\nbegin_step(\"Prepare PBST Unopened Tubes\");\ncomment(\"Prepare two unopened tubes of Phosphate-Buffered Saline with Tween 20 (PBST) as negative media controls\");\nstore(\"PBST\", tube, cold_room);\nend_step(\"Prepare PBST Unopened Tubes\");\n\nbegin_step(\"Continue Sampling\");\ncomment(\"Carry out your sampling procedure here.\");\nend_step(\"Continue Sampling\");\n\nbegin_step(\"Collect Second Negative Field Control\");\ncomment(\"Collect the second negative field control at the end of the sampling\");\nend_step(\"Collect Second Negative Field Control\");\n\nend_protocol();\n", "result_baseline4": {"opcode": "Collect Negative Controls", "slot": [["Device", null], ["Container", "PBST"]], "emit": "Negative field controls and negative media controls prepared"}, "result_baseline5": {"opcode": "Collective Negative Field and Media Control", "slot": [["Container", "PBST"], ["String", "cold_room"], ["Device", null]], "emit": "Sampling Procedure"}}, {"i": 4, "sentense": "Store all samples in a cooler with ice for up to 12 hours during collection.", "python": "python\n# Define a function to check if the samples have been stored correctly in the cooler with ice\ndef check_samples(samples):\n    if samples == \"stored in cooler with ice for up to 12 hours\":\n        print(\"Samples have been stored correctly in the cooler with ice for up to 12 hours\")\n    else:\n        print(\"Samples have not been stored correctly in the cooler with ice for up to 12 hours\")\n\n# Call the function with the samples as the input\ncheck_samples(\"stored in cooler with ice for up to 12 hours\")\n", "biocoder": "Python\nfrom biocoder import *\n\ndef storage_on_ice(samples):\n    p = Protocol()\n\n    # store samples on ice\n    p.comment('Place all samples in a cooler with ice for up to 12 hours during collection.')\n\n    for s in samples:\n        p.store(s, temp='4 degrees', time='12:00:00')\n\n    return p\n\n# list of samples\nsamples = ['sample1', 'sample2', 'sample3']\nstorage_on_ice(samples)\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "storage_on_ice", "slot": [["Device", null]], "emit": "samples on ice in a cooler for up to 12 hours during collection"}}, {"i": 5, "sentense": "Proceed with swab extraction, sample aggregation, and subsequent cultivation as per the experimental setup.", "python": "python\ndef swab_extraction():\n    print(\"Swab extraction in progress...\")\n\ndef sample_aggregation():\n    print(\"Sample aggregation in progress...\")\n\ndef cultivation():\n    print(\"Cultivation in progress...\")\n\n# Perform the experimental protocol\nswab_extraction()\nsample_aggregation()\ncultivation()\n", "biocoder": "python\nfrom biocoder import *\n\ndef extraction_and_cultivation():\n    # Step 1: Swab Extraction\n    p1 = Protocol.start('Swab Extraction')\n    s1 = SolidItem(name='Swab')\n    Protocol.use(s1)\n    e1 = LiquidItem(name='Extraction Buffer')\n    Protocol.add(e1, s1)\n    Protocol.incubate(s1, room_temp, time='10:00', description='Allow swab to sit in extraction buffer')\n    Protocol.spin(s1, speed='13,000g', time='10:00')\n    supernatant = Protocol.aspirate(s1, volume='100ul')\n    \n    # Step 2: Sample Aggregation\n    p2 = Protocol.start('Sample Aggregation')\n    tube = LiquidItem(name='New Tube')\n    Protocol.add(tube, supernatant)\n    \n    # Step 3: Subsequent Cultivation\n    p3 = Protocol.start('Subsequent Cultivation')\n    c1 = SolidItem(name='Cultivation Plate')\n    Protocol.add(c1, tube)\n    Protocol.incubate(c1, temp='37\u00b0C', time='48:00', shaking=True, description='Cultivate samples in plate at 37\u00b0C for 48 hours')\n\nextraction_and_cultivation()\n", "result_baseline4": {"opcode": "Experimental Protocol", "slot": [["String", "Swab extraction"], ["String", "Sample aggregation"], ["String", "Cultivation"]], "emit": "Finished experimental protocol execution"}, "result_baseline5": {"opcode": "Extraction and Cultivation", "slot": [["Container", "Swab"], ["Container", "Extraction Buffer"], ["Volume", "100ul"], ["Container", "New Tube"], ["Container", "Cultivation Plate"], ["Temperature", "37\u00b0C"], ["Time", "48:00"], ["Bool", null]], "emit": "Cultivated samples in plate at 37\u00b0C for 48 hours"}}]}, "4": {"subject": "Ecology & Environmental Biology", "enum": 4, "protocol": "Always ensure containers are not tightly sealed to prevent pressure buildup and heed warnings about ensuring adequate ventilation to avoid oxygen deficiency from inert gas displacement. Protect yourself against liquid nitrogen (LN2) splatter. Label cryogenic tubes with sample name, date frozen, and initials before aliquoting 1 mL samples. Fill an insulated pan with LN2 to about 2 cm depth and place a CoolRack in it to cool to -150\u00b0C in approximately 15 minutes; pre-chilling the CoolRack in a -80\u00b0C freezer can save LN2 and time. Place cryogenic tubes in the CoolRack on dry ice for snap freezing, leaving them for 1 minute before transferring to a freezer box with forceps, then store in a -80\u00b0C freezer. For warming, thaw tubes at 4\u00b0C.", "compile": [{"i": 0, "sentense": "Always ensure containers are not tightly sealed to prevent pressure buildup and heed warnings about ensuring adequate ventilation to avoid oxygen deficiency from inert gas displacement.", "python": "python\ndef experimental_protocol():\n    containers_tightly_sealed = False\n    adequate_ventilation = True\n    \n    if not containers_tightly_sealed and adequate_ventilation:\n        print(\"Experiment can proceed safely.\")\n    else:\n        print(\"Ensure containers are not tightly sealed and there is adequate ventilation before proceeding with the experiment.\")\n\nexperimental_protocol()\n", "biocoder": "python \n\n# Step 1: Preparation\ncomment(\"During the entire procedure make sure that the containers are not tightly sealed.\")\ncomment(\"This helps to prevent pressure buildup.\")\ncomment(\"Also, ensure adequate ventilation to avoid oxygen deficiency from inert gas displacement.\")\n\n", "result_baseline4": {"opcode": "experimental_protocol", "slot": [["Bool", false], ["Bool", true]], "emit": "Print whether experiment can proceed safely or not"}, "result_baseline5": {"opcode": "Preparation", "slot": [["String", "containers are not tightly sealed"], ["String", "adequate ventilation to avoid oxygen deficiency"]], "emit": "prevent pressure buildup and inert gas displacement"}}, {"i": 1, "sentense": "Protect yourself against liquid nitrogen (LN2) splatter.", "python": "python\ndef protect_against_ln2_splatter():\n    # Wear appropriate personal protective equipment (PPE) such as gloves, face shield, and apron.\n    wear_gloves = True\n    wear_face_shield = True\n    wear_apron = True\n\n    # When handling LN2, always use a proper container such as a dewar or cryogenic flask.\n    handling_container = \"cryogenic flask\"\n\n    # Pour LN2 slowly and carefully to minimize splashing.\n    pour_slowly = True\n    pour_carefully = True\n\n    # In case of accidental splatter, immediately wash affected area with lukewarm water and seek medical attention if necessary.\n    accidental_splatter = True\n    wash_with_lukewarm_water = True\n    seek_medical_attention = True\n\n# Call the function to execute the protocol\nprotect_against_ln2_splatter()\n", "biocoder": "Python\n'''\nFunction name : Protect_against_LN2\nInput : None\nOutput : None\nRequirements : Protective gown, laboratory gloves, safety goggles, safety shoes\nProcedure :\n1. Wear safety gown.\n2. Wear laboratory gloves.\n3. Wear safety goggles.\n4. Wear safety shoes.\n'''\n\ndef Protect_against_LN2():\n    start_protocol(\"Protect against Liquid Nitrogen Splatter\")\n    \n    comment(\"This protocol is designed to provide instructions for how to protect yourself against liquid nitrogen (LN2) splatter.\")\n    \n    next_step(\"Put on a protective gown\")\n    next_step(\"Put on laboratory gloves\")\n    next_step(\"Put on safety goggles to protect your eyes from splatter\")\n    next_step(\"Wear safety shoes for foot protection\")\n    \n    end_protocol()\n    \nProtect_against_LN2()\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 2, "sentense": "Label cryogenic tubes with sample name, date frozen, and initials before aliquoting 1 mL samples.", "python": "\n# Protocol for labeling cryogenic tubes before aliquoting samples\n\nsample_name = \"Sample1\"\ndate_frozen = \"2022-12-31\"\ninitials = \"AB\"\n\ndef label_cryogenic_tubes(sample_name, date_frozen, initials):\n    # Print labeling information\n    print(f\"Labeling cryogenic tube with:\")\n    print(f\"Sample name: {sample_name}\")\n    print(f\"Date frozen: {date_frozen}\")\n    print(f\"Initials: {initials}\")\n\n# Call function to label cryogenic tubes\nlabel_cryogenic_tubes(sample_name, date_frozen, initials)\n", "biocoder": "\n#include \"BioCoder.h\"\n\nvoid main() {\n\n\t// Step 1: Labeling cryogenic tubes\n\tFluid sample = new_fluid(\"Sample\");\n\tContainer cryogenic_tube = new_container(STERILE_CRYOGENIC_TUBE);\n\t\n\tchar* date = get_input(\"Enter the current date: \");\n\tchar* initials = get_input(\"Enter your initials: \");\n\tProperty* tube_label = new_property(\"Tube label\");\n\tchar* sample_name = toString(sample);\n\tadd_property(tube_label, \"Name\", sample_name);\n\tadd_property(tube_label, \"Date Froze\", date);\n\tadd_property(tube_label, \"Initials\", initials);\n\tlabel(cryogenic_tube, tube_label);\n\n\t// Step 2: Aliquoting 1 mL samples into the cryogenic tubes\n\tvolume aliquot_vol = vol(1, ML);\n\tContainer sample_in_tube = aliquot(cryogenic_tube, sample, aliquot_vol);\n}\n", "result_baseline4": {"opcode": "Labeling Cryogenic Tubes", "slot": [["String", "Sample1"], ["Time", "2022-12-31"], ["String", "AB"]], "emit": "Printing labeling information"}, "result_baseline5": {"opcode": "ALIQUOT", "slot": [["Container", "cryogenic_tube"], ["Container", "sample_in_tube"], ["Volume", {"value": 1, "unit": "mL"}]], "emit": "Aliquoted samples into cryogenic tubes"}}, {"i": 3, "sentense": "Fill an insulated pan with LN2 to about 2 cm depth and place a CoolRack in it to cool to -150\u00b0C in approximately 15 minutes; pre-chilling the CoolRack in a -80\u00b0C freezer can save LN2 and time.", "python": "python\nimport time\n\ndef cool_rack_with_ln2():\n    # Fill insulated pan with LN2 to 2 cm depth\n    ln2_depth = 2\n    \n    print(\"Filling insulated pan with LN2 to 2 cm depth...\")\n    time.sleep(2)  # Simulate filling with LN2\n    \n    # Place CoolRack in LN2 to cool to -150\u00b0C\n    coolrack_temp = -150\n    \n    print(\"Placing CoolRack in LN2 to cool to -150\u00b0C...\")\n    time.sleep(15*60)  # Simulate cooling for 15 minutes\n    \n    print(\"CoolRack is now cooled to -150\u00b0C\")\n\n# Pre-chill CoolRack in -80\u00b0C freezer\ndef pre_chill_coolrack():\n    freezer_temp = -80\n    \n    print(\"Pre-chilling CoolRack in -80\u00b0C freezer...\")\n    time.sleep(2*60)  # Simulate pre-chilling for 2 minutes\n    \n    print(\"CoolRack is now pre-chilled in -80\u00b0C freezer\")\n\n# Main program\npre_chill_coolrack()\ncool_rack_with_ln2()\n", "biocoder": "Python\n# Biocoder representation of the protocol\n\nfrom biocoder import *\n\n# Protocol starts here\np = Protocol()\n\n# Step 1: Fill an insulated pan with LN2\npan = Container('Insulated pan', State.LIQUID)\np.add(pan.fill(Nitrogen.LIQUID, Volume.centi_liter(2)), 'Fill an insulated pan with LN2 to about 2 cm depth')\n\n# Step 2: Place a CoolRack in the pan\ncool_rack = Container('CoolRack', State.SOLID)\np.add(pan.place(cool_rack), 'Place a CoolRack in it')\n\n# Step 3: Cool the CoolRack to -150\u00b0C in approximately 15 minutes\np.add(cool_rack.incubate_conditional(Time(minutes=15), Temperature.celsius(-150)), 'Cool the CoolRack to -150\u00b0C in approximately 15 minutes')\n\n# Step 4: Pre-chilling the CoolRack in a -80\u00b0C freezer\nfreezer = Equipment('Freezer', State.LIQUID, Temperature.celsius(-80))\np.add(cool_rack.store_in(freezer, Time(minutes=15)), 'Pre-chill the CoolRack in a -80\u00b0C freezer to save LN2 and time')\n\n# End of the protocol\np.print()\n\n", "result_baseline4": {"opcode": "CoolRack Cooling Protocol", "slot": [["Temperature", "-80\u00b0C"], ["Length", "2 cm"], ["Device", "CoolRack"]], "emit": "CoolRack is now cooled to -150\u00b0C"}, "result_baseline5": {"opcode": "Cooling", "slot": [["Container", "CoolRack"], ["Temperature", null], ["Time", "15 minutes"]], "emit": "Cool the CoolRack to -150\u00b0C in approximately 15 minutes"}}, {"i": 4, "sentense": "Place cryogenic tubes in the CoolRack on dry ice for snap freezing, leaving them for 1 minute before transferring to a freezer box with forceps, then store in a -80\u00b0C freezer.", "python": "python\n# Place cryogenic tubes in CoolRack on dry ice for snap freezing\ndef snap_freeze(tubes):\n    print(\"Placing cryogenic tubes in CoolRack on dry ice for snap freezing...\")\n    # Wait for 1 minute\n    time.sleep(60)\n\n    # Transfer tubes to freezer box with forceps\n    print(\"Transferring tubes to freezer box with forceps...\")\n\n    # Store in a -80\u00b0C freezer\n    print(\"Storing tubes in a -80\u00b0C freezer\")\n\n# Example usage\ntubes = [\"Tube1\", \"Tube2\", \"Tube3\"]\nsnap_freeze(tubes)\n", "biocoder": "\nbegin_protocol(\"Snap Freezing Protocol\");\n\nFluid cryogenic_tubes = new_Fluid(\"Cryogenic Tubes\");\nContainer cool_rack = new Container(\"Cool Rack\");\nLocation freezer = new Location(\"-80 C Freezer\");\n\nfirst_step(\"Place Cryogenic Tubes in CoolRack\");\n{\nplace(cryogenic_tubes, cool_rack);\ncomment(\"Cryogenic Tubes are now placed at CoolRack on dry ice for snap freezing.\");\n}\n \nnext_step(\"Leave them for 1 minute\");\n{\nstore(cool_rack, RT, time(1, MINS));\n}\n\nnext_step(\"Transfer to freezer box with forceps\");\n{\ntransfer(cryogenic_tubes, freezer);\ncomment(\"Cryogenic Tubes are now transferred to a freezer box using forceps.\");\n}\n\nnext_step(\"Store in -80\u00b0C Freezer\");\n{\nstore(cryogenic_tubes, freezer, time(-80, DEGREES_C));\ncomment(\"Cryogenic Tubes are now stored in a -80\u00b0C freezer.\");\n}\n\nend_protocol();\n", "result_baseline4": {"opcode": "snap_freeze", "slot": [["Container", "cryogenic tubes"], ["Temperature", "-80\u00b0C"], ["Device", "CoolRack"]], "emit": "freezer box with forceps"}, "result_baseline5": {"opcode": "Snap Freezing Protocol", "slot": [["Container", "Cool Rack"], ["Time", "1 minute"], ["Device", "forceps"]], "emit": "Cryogenic Tubes are now stored in a -80\u00b0C freezer."}}, {"i": 5, "sentense": "For warming, thaw tubes at 4\u00b0C.", "python": "python\ndef thaw_tubes():\n    print(\"Thaw tubes at 4\u00b0C\")\n\n# Call the function to thaw tubes\nthaw_tubes()\n", "biocoder": "\n#include \"BioCoder.h\"\n\nvoid main() {\n    start_protocol(\"Warming Protocol\");\n\n    // Step 1: Thaw tubes at 4 degrees Celsius\n    Thaw(\"Tubes\", 4);\n\n    end_protocol();\n}\n", "result_baseline4": {"opcode": "THAW", "slot": [["Temperature", "4\u00b0C"]], "emit": "Thaw tubes"}, "result_baseline5": {"opcode": "WARM", "slot": [["Container", "Tubes"], ["Temperature", 4]], "emit": "Thawed tubes"}}]}}, "Bioengineering & Technology": {"0": {"subject": "Bioengineering & Technology", "enum": 0, "protocol": "Grow yeast cells with GFP-fusion on solid media, transfer to a microscope slide covered with a coverslip, and acquire Z-sections using a spinning disk confocal microscope.", "compile": [{"i": 0, "sentense": "Grow yeast cells with GFP-fusion on solid media, transfer to a microscope slide covered with a coverslip, and acquire Z-sections using a spinning disk confocal microscope.", "python": "python\ndef grow_yeast_cells():\n    print(\"Step 1: Grow yeast cells with GFP-fusion on solid media\")\n    \ndef transfer_to_microscope_slide():\n    print(\"Step 2: Transfer yeast cells to a microscope slide covered with a coverslip\")\n    \ndef acquire_Z_sections():\n    print(\"Step 3: Acquire Z-sections using a spinning disk confocal microscope\")\n    \n# Main program\nif __name__ == \"__main__\":\n    grow_yeast_cells()\n    transfer_to_microscope_slide()\n    acquire_Z_sections()\n", "biocoder": "python\n# Protocol: Imaging GFP-tagged yeast cells with confocal microscopy in Biocoder format\n\n# Step 1: Preparation of the yeast cells\nYeast_strain yeast_cells = Yeast_strain(\"GFP-tagged yeast cells\")\nBegin_incubation(yeast_cells)\n{\n    Incubate(yeast_cells, \"30 celsius\", TimePeriod(2, \"days\"))\n}\n\n# Step 2: Preparation of the microscope slide\nSlide slide = Slide(SlideType.Frosted)\nslide.set_number_of_section(\"Z-section\")\n\n# Step 3: Transfer of yeast cells to the microscope slide\nTransfer(yeast_cells, slide)\n\n# Step 4: Covering of the microscope slide\nCoverSlip cover_slip = CoverSlip()\nApply_cover_slip(slide, cover_slip)\n\n# Step 5: Microscopy imaging\nMicroscope microscope = Microscope(MicroscopeType.Spinning_disk_confocal)\nLoad_slide(microscope, slide)\nCapture_image(microscope)\n\n# End of the protocol\n", "result_baseline4": {"opcode": "ACQUIRE", "slot": [["Device", "spinning disk confocal microscope"], ["Container", "microscope slide covered with coverslip"], ["REG", null]], "emit": "Z-sections"}, "result_baseline5": {"opcode": "Imaging", "slot": [["Device", "Spinning disk confocal microscope"], ["Container", "Slide"], ["Temperature", "30 celsius"]], "emit": "Captured Z-stack images"}}]}, "1": {"subject": "Bioengineering & Technology", "enum": 1, "protocol": "Grow yeast cells transformed with GFP-fusion on solid media, then transfer them to a microscope slide and cover with a coverslip. Acquire Z-sections using a spinning disk confocal microscope as described.", "compile": [{"i": 0, "sentense": "Grow yeast cells transformed with GFP-fusion on solid media, then transfer them to a microscope slide and cover with a coverslip.", "python": "python\ndef grow_yeast_cells():\n    # code to grow yeast cells transformed with GFP-fusion on solid media\n\ndef transfer_to_microscope_slide():\n    # code to transfer yeast cells to a microscope slide\n\ndef cover_with_coverslip():\n    # code to cover the slide with a coverslip\n\n# Main program\nif __name__ == \"__main__\":\n    grow_yeast_cells()\n    transfer_to_microscope_slide()\n    cover_with_coverslip()\n", "biocoder": "\n# Biocoder protocol for yeast cell microscopy \n\n# Starting materials\nSolutions yeast_cells, solid_media, GFP_fusion;\nEquipment microscope, coverslip;\n\n# Procedure: Grow yeast cells\nstep \n    \"1. Grow yeast cells transformed with GFP-fusion on solid media\"\n    begin\n        YeastCellGrowth(yeast_cells, solid_media, GFP_fusion);\n    end\n\n# Procedure: Transfer Cells to Slide \nstep \n    \"2. Transfer grown yeast cells to microscope slide\"\n    begin\n        TransferToSlide(yeast_cells, microscope);\n    end\n\n# Procedure: Cover with Coverslip\nstep\n    \"3. Cover the slide with a coverslip\"\n    begin\n        AddCoverslip(microscope,coverslip);\n    end\n\n# End of protocol\n", "result_baseline4": {"opcode": "GROW", "slot": [["Device", "microscope slide"], ["Container", "coverslip"], ["Container", null]], "emit": "yeast cells transformed with GFP-fusion"}, "result_baseline5": {"opcode": "GROW", "slot": [["REG", "yeast_cells"], ["REG", "solid_media"], ["REG", "GFP_fusion"]], "emit": "Z-stack images"}}, {"i": 1, "sentense": "Acquire Z-sections using a spinning disk confocal microscope as described.", "python": "python\ndef acquire_z_sections():\n    # Connect to spinning disk confocal microscope\n    microscope = connect_to_microscope()\n\n    # Acquire Z-sections\n    z_sections = microscope.acquire_z_sections()\n\n    return z_sections\n\ndef connect_to_microscope():\n    # Code to connect to spinning disk confocal microscope\n    pass\n\n# Main program\nz_sections = acquire_z_sections()\nprint(z_sections)\n", "biocoder": "c++\n#include \"biocoder.h\"\n\nvoid setup()\n{\n    // This is where initial setup parameters would go\n}\n\nvoid loop()\n{\n    // This is where the actual process steps would go\n}\n\nint main()\n{\n    // Set up\n    setup();\n\n    // Perform protocol\n    loop();\n\n    // Cleanup and end\n    end_protocol();\n    return 0;\n}\n", "result_baseline4": {"opcode": "ACQUIRE", "slot": [["Device", "spinning disk confocal microscope"], ["REG", "Z-sections"]], "emit": "Z-stack images"}, "result_baseline5": {"opcode": "perform_protocol", "slot": [["String", "initial setup parameters"], ["String", "actual process steps"]], "emit": "Cleanup and end"}}]}, "2": {"subject": "Bioengineering & Technology", "enum": 2, "protocol": "Prior to the onset of directed differentiation, pluripotent stem cells are cultured in maintenance medium with 1% or 2% DMSO for 24-48h. Proceed with desired differentiation protocol after this treatment.", "compile": [{"i": 0, "sentense": "Prior to the onset of directed differentiation, pluripotent stem cells are cultured in maintenance medium with 1% or 2% DMSO for 24-48h.", "python": "python\ndef culture_stem_cells(DMSO_concentration, duration):\n    if DMSO_concentration == 1 or DMSO_concentration == 2:\n        maintenance_medium = \"maintenance medium\"\n        DMSO_percentage = str(DMSO_concentration) + \"% DMSO\"\n        culture_time = str(duration) + \"h\"\n        \n        print(f\"Culture pluripotent stem cells in {maintenance_medium} with {DMSO_percentage} for {culture_time}\")\n\n# Example usage\nculture_stem_cells(1, 24)\n", "biocoder": "\n# Begin\nbegin_protocol \"Directed differentiation of pluripotent stem cells\";\n\n# Materials\ncomment \"Materials:\";\nFluid *maintenance_medium = new_fluid (\"maintenance medium\");\nChemical *DMSO = new_chemical (\"DMSO\");\n\n# Pluripotent stem cells cultivation before directed differentiation\nfirst_step\n\"Prior to the onset of directed differentiation, pluripotent stem cells are cultured in maintenance medium with 1% or 2% DMSO for 24-48h.\";\nFluid *medium_with_DMSO = mix (maintenance_medium, DMSO, 1, PERCENT); // or change value to 2 for 2% DMSO\nPlate *cell_plate = new_plate (PLURIPOTENT_STEM_CELLS);\ncell_plate->add (medium_with_DMSO);\ncell_plate->incubate (ROOM, \"24-48h\", CO2_5_PERCENT);\n\n# End\nend_protocol();\n\n# Return\nreturn 0;\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "Directed differentiation of pluripotent stem cells", "slot": [["Container", "maintenance_medium"], ["Container", "DMSO"], ["Container", "medium_with_DMSO"], ["Container", "cell_plate"], ["Temperature", "ROOM"], ["Time", "24-48h"], ["Concentration", "1% or 2%"], ["Mass", "1"], ["Volume", null], ["Speed", null]], "emit": "Pluripotent stem cells cultivation before directed differentiation"}}, {"i": 1, "sentense": "Proceed with desired differentiation protocol after this treatment.", "python": "python\n# Define a function to proceed with desired differentiation protocol\ndef desired_differentiation_protocol(treatment):\n    print(\"Proceeding with desired differentiation protocol after treatment:\", treatment)\n\n# Call the function with the treatment mentioned in the protocol\ndesired_differentiation_protocol(\"treatment\")\n", "biocoder": "\nprotocol differentiation_protocol:\nbegin_protocol(\"Differentiation Protocol\")\n\n     comment(\"Proceed with desired differentiation protocol after this treatment.\")\n\n     // Further steps would be included here, based on the specifics of the desired differentiation protocol. \n     // For instance: \n     // step(\"Add differentiation media to the culture flask.\") \n     // step(\"Incubate the cells under appropriate conditions.\")\n     // step(\"Monitor the cells for signs of differentiation.\")\n     // And so forth... \n\nend_protocol()\n", "result_baseline4": {"opcode": "", "slot": [], "emit": ""}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}]}, "3": {"subject": "Bioengineering & Technology", "enum": 3, "protocol": "Place larvae in a 1m^3 box filled with dirt, feed them the specified food 3-4 times a day at 2-3 hour intervals for optimal growth. Continue until larvae become pupae, at which point increase food quantity. Once pupae develop into adults, introduce water to the environment for mating. After mating, collect the new larvae.", "compile": [{"i": 0, "sentense": "Place larvae in a 1m^3 box filled with dirt, feed them the specified food 3-4 times a day at 2-3 hour intervals for optimal growth.", "python": "python\ndef feed_larvae(food, times_per_day, hours_interval):\n    for i in range(times_per_day):\n        print(f\"Feeding larvae {food}...\")\n        # Feed larvae the specified food\n        # Wait for the specified hours interval before feeding them again\n\nfood = \"specified food\"\ntimes_per_day = 3\nhours_interval = 2\n\nfeed_larvae(food, times_per_day, hours_interval)\n", "biocoder": "\n#include \"BioCoder.h\"\n\nint main()\n{\n    start_protocol(\"Larvae Growth Protocol\");\n\n    //Step 1\n    Fluid *dirt = new_fluid(\"dirt\");\n    Container *box = new_container(BOX, dirt, 1);\n    Container *larvae = new_container(LARVAE);\n    first_step(\"Place larvae in a 1m^3 box filled with dirt.\");\n    transfer(larvae, box);\n\n    //Step 2\n    Fluid *specified_food = new_fluid(\"specified food\");\n    Container *food_container = new_container(CONTAINER, specified_food);\n    next_step(\"Feed them the specified food 3-4 times a day at 2-3 hour intervals for optimal growth.\");\n    \n    //Loop for feeding larvae 3-4 times a day\n    Time *day = new_time(0, DAY, 1);\n    for (int i = 0; i < 4; i++)\n    {\n        transfer(food_container, box);\n        comment(\"Repeat this step 3-4 times a day at 2-3 hour intervals\");\n        incubate(box, room_temp, new_time(3, HRS, 0));\n\n        if (i == 2)\n        {\n            comment(\"You can stop feeding the larvae after 3 times if you deem it optimal. Otherwise, feed them one more time.\");\n            pause(day);\n        }\n        else if (i == 3)\n        {\n            comment(\"Pause for 2-3 hours between feedings.\");\n            pause_for(new_time(2, HRS, 0));\n        }\n    }\n    \n    end_protocol();\n}\n", "result_baseline4": {"opcode": "FEED", "slot": [["String", "specified food"], ["Mass", null], ["Time", 2]], "emit": "Feeding larvae specified food..."}, "result_baseline5": {"opcode": "LARVAE_GROWTH", "slot": [["Container", "larvae"], ["Container", null], ["Time", "2-3 hours"], ["Time", "optimal growth"]], "emit": "feeding specified food"}}, {"i": 1, "sentense": "Continue until larvae become pupae, at which point increase food quantity.", "python": "python\nwhile not larvae_become_pupae:\n    pass\n\nincrease_food_quantity()\n", "biocoder": "python\n#BIOCODER_Protocol_Start\n\nfrom biocoder import *\n\ndef main():\n# Create the materials and equipment required for the protocol\n    fly_larvae = Solid('Drosophila larvae')\n    fly_food = Solid('Drosophila food')\n\n# Create the protocol\n    p = Protocol()\n\n# Step 1: Monitor the larvae\n    p.start_event(\"Monitor the larvae daily to observe any noticeable difference in its behaviour or the signs of transformation\")\n\n# Step 2: Increase the food quantity once they become pupae\n    p.comment(\"Once the larvae transform into pupae,\")\n    p.add(fly_food, 5.0, Units.mL)\n    p.incubate(fly_larvae, ambient, Time(value=24.0, unit=Time.HR))\n    p.end_event()\n\n# Step 3: Continue monitoring until adulthood\n    p.comment(\"Continue monitoring the pupae until they reach adulthood.\")\n\n# Print a human-readable version of the protocol\n    print(p)\n\n# Run the protocol\n    p.run()\n\nif __name__ == '__main__':\n    main()\n\n#BIOCODER_Protocol_End\n", "result_baseline4": {"opcode": "increase_food_quantity", "slot": [["String", "food_quantity"]], "emit": "increase in larval growth"}, "result_baseline5": {"opcode": "Monitor", "slot": [["Container", "Drosophila larvae"], ["Container", "Drosophila food"], ["Time", "24.0 HR"]], "emit": "Observation of larval behavior and transformation signs"}}, {"i": 2, "sentense": "Once pupae develop into adults, introduce water to the environment for mating.", "python": "python\n# Define a function to introduce water for mating\ndef introduce_water_for_mating():\n    print(\"Water has been introduced to the environment for mating.\")\n\n# Main program\nif __name__ == \"__main__\":\n    # Pupae develop into adults\n    adults_developed = True\n\n    # Check if pupae have developed into adults\n    if adults_developed:\n        introduce_water_for_mating()\n", "biocoder": "Biocoder\nbegin_protocol(\"Introduce Water for Mating\");\n\n//Begin after pupae have developed into adults\n\n//Step 1: Introduction of water to the environment\nStep(\"Introduce water to the environment\");\n\nComment(\"This step is done to provide an ideal environment for the mating process.\");\n\nend_protocol();\n", "result_baseline4": {"opcode": "introduce_water_for_mating", "slot": [["Bool", true], ["String", null]], "emit": "Water has been introduced to the environment for mating."}, "result_baseline5": {"opcode": "Introduce Water", "slot": [["String", "water"], ["String", "environment"], ["String", null]], "emit": "Mating process enhancement"}}, {"i": 3, "sentense": "After mating, collect the new larvae.", "python": "python\n# Collect new larvae after mating\ndef collect_larvae():\n    print(\"Collecting new larvae after mating\")\n\n# Call the function to collect larvae\ncollect_larvae()\n", "biocoder": "Python\n# Biocoder python format\n\ndef collect_larvae():\n  start_protocol(\"Collection of New Larvae After Mating.\")\n  \n  # Step 1: Mating of samples.\n  comment(\"Start with the mating of your samples.\")\n\n  # Step 2: Collection of new Larvae.\n  comment(\"After successful mating, collect the new larvae.\")\n  \n  end_protocol()\n\ncollect_larvae()\n", "result_baseline4": {"opcode": "collect_larvae", "slot": [], "emit": "Collecting new larvae after mating"}, "result_baseline5": {"opcode": "LARVAE_COLLECTION", "slot": [["Container", "mating samples"], ["Container", "new larvae"]], "emit": "successful collection"}}]}, "4": {"subject": "Bioengineering & Technology", "enum": 4, "protocol": "Recruit 7 mandibular models and apply radio opaque markers. Record 10 predetermined linear measurements, perform CBCT scanning of each model, and convert DICOM files into STL format. Use SLS and FFF printers for 3D printing the models. Record the same 10 linear measurements on the printed models and compare these values against the reference models and each other.", "compile": [{"i": 0, "sentense": "Recruit 7 mandibular models and apply radio opaque markers.", "python": "python\nmandibular_model = [] \n\ndef apply_radio_opaque_markers(model):\n    model.append('radio_oqaque_marker')\n\nfor i in range(7):\n    mandibular_model.append([])\n    apply_radio_opaque_markers(mandibular_model[i])\n\nprint(mandibular_model)\n", "biocoder": "python\ndef main():\n\n    start_protocol(\"Radio opaque marker application\")\n    \n    # Define the 7 mandibular models\n    mandibular_models = new_material(ref=\"Mandibular models\", num=7)\n    \n    # Define radio opaque markers\n    radio_opaque_markers = new_material(ref=\"Radio opaque markers\")\n\n    comment(\"Step 1: Recruit 7 mandibular models\")\n    next_step(\"Place the 7 mandibular models on the workbench\")\n\n    comment(\"Step 2: Apply radio opaque markers\")\n    for model in mandibular_models:\n        next_step(\"Apply the radio opaque marker to model #{}\".format(model.name))\n        apply_to(radio_opaque_markers, model)\n\n    end_protocol()\n", "result_baseline4": {"opcode": "apply_radio_opaque_markers", "slot": [["Container", "mandibular_model"]], "emit": "updated mandibular_model"}, "result_baseline5": {"opcode": "Radio opaque marker application", "slot": [["Container", "Mandibular models"], ["Container", "Radio opaque markers"], ["String", "Place the 7 mandibular models on the workbench"], ["String", "Apply the radio opaque marker to model #7"]], "emit": "Complete radio opaque marker application"}}, {"i": 1, "sentense": "Record 10 predetermined linear measurements, perform CBCT scanning of each model, and convert DICOM files into STL format.", "python": "python\ndef record_linear_measurements(num_measurements):\n    measurements = []\n    for _ in range(num_measurements):\n        measurement = float(input(\"Enter linear measurement: \"))\n        measurements.append(measurement)\n    return measurements\n\ndef cbct_scanning(num_models):\n    for i in range(num_models):\n        model_num = i + 1\n        print(f\"Performing CBCT scanning for model {model_num}\")\n\ndef convert_to_stl(num_models):\n    for i in range(num_models):\n        model_num = i + 1\n        print(f\"Converting DICOM files to STL format for model {model_num}\")\n\nnum_models = 10\nlinear_measurements = record_linear_measurements(10)\ncbct_scanning(num_models)\nconvert_to_stl(num_models)\n", "biocoder": "\n# Biocoder code for CBCT scanning and DICOM to STL conversion protocol\n\nbegin_protocol(\"CBCT scanning and DICOM to STL conversion\");\n\n# Step 1: Record 10 predetermined linear measurements\ncomment(\"Step 1: Record 10 predetermined linear measurements\");\nNumber measurements = 10;\nIterate i from 1 to measurements;\nbegin_loop(i)\n   // Add the measurements\n   Fluid measurement = measure (\"Linear\", vol(1, ML), TA);\n   Material object = new_material (\"Object\", measurement);\n   store(object, RT, min_time(0));\nend_loop\n\n# Step 2: Perform CBCT scanning of each model\ncomment(\"Step 2: Perform CBCT scanning of each model\");\nIterate j from 1 to measurements;\nbegin_loop(j)\n   comment(\"Performing CBCT scan for Model \" + j);\n   // Simulating the CBCT scanning process, as Biocoder currently does not support operations related to CT Scanning directly\n   Material scan = new_material (\"CBCT Scan\", measurement);\n   store(scan, RT, min_time(0));\nend_loop\n\n# Step 3: Convert DICOM files into STL format\ncomment(\"Step 3: Convert DICOM files into STL format\");\nIterate k from 1 to measurements;\nbegin_loop(k)\n   comment(\"Converting DICOM file of scanned Model \" + k + \" into STL format\");\n   // Simulating the file conversion process, as Biocoder currently does not support operations related to file conversion directly\n   Material STL_conversion = new_material (\"STL conversion\", measurement);\n   store(STL_conversion, RT, min_time(0) );\nend_loop\n\nend_protocol();\n", "result_baseline4": {"opcode": "record_linear_measurements", "slot": [["Volume", null]], "emit": "list of linear measurements"}, "result_baseline5": {"opcode": "CBCT Scanning and DICOM to STL Conversion", "slot": [["Container", "Object"], ["Time", null], ["Device", "CBCT Scanner"]], "emit": "STL files of scanned models"}}, {"i": 2, "sentense": "Use SLS and FFF printers for 3D printing the models.", "python": "python\ndef print_3d_models(printer_type):\n    if printer_type == 'SLS' or printer_type == 'FFF':\n        print(f\"Using {printer_type} printer for 3D printing the models.\")\n    else:\n        print(\"Invalid printer type. Please use SLS or FFF printers for 3D printing.\")\n\n# Example usage\nprint_3d_models('SLS')\nprint_3d_models('FFF')\nprint_3d_models('SLA')\n", "biocoder": "No program", "result_baseline4": {"opcode": "print_3d_models", "slot": [["String", "SLS"], ["String", "FFF"]], "emit": "3D printing the models"}, "result_baseline5": {"opcode": "Experiment", "slot": [["Device", null], ["Time", "30 minutes"], ["Container", null]], "emit": "Data analysis results"}}, {"i": 3, "sentense": "Record the same 10 linear measurements on the printed models and compare these values against the reference models and each other.", "python": "python\n# Define function to record linear measurements and compare values\ndef compare_measurements(model1, model2):\n    measurements1 = [5.2, 6.1, 7.8, 9.0, 4.5, 3.2, 6.7, 8.3, 5.9, 7.1]\n    measurements2 = [5.5, 6.3, 7.5, 8.8, 4.8, 3.5, 6.5, 8.1, 5.7, 7.3]\n\n    for i in range(10):\n        print(f\"Measurement {i+1}:\")\n        print(f\"Model 1 - {model1}: {measurements1[i]}\")\n        print(f\"Model 2 - {model2}: {measurements2[i]}\")\n        \n        if measurements1[i] == measurements2[i]:\n            print(\"Measurements are the same\")\n        elif measurements1[i] > measurements2[i]:\n            print(f\"{model1} measurement is larger than {model2}\")\n        else:\n            print(f\"{model2} measurement is larger than {model1}\")\n        \n        print(\"\\n\")\n\n# Compare linear measurements on two printed models\ncompare_measurements(\"Printed Model 1\", \"Printed Model 2\")\n", "biocoder": "\n#include \"BioCoder.h\"\n\nvoid main() {\n\t//Step 1: Record the same 10 linear measurements on the printed models\n\tFluid* printed_models = new_fluid(\"printed models\");\n\tplate* model_plate = new_plate(PRINTED_MODELS, 10);\n\tmeasure_fluid_volume(printed_models, model_plate);\n\n\t//Step 2: Compare these values against the reference models\n\tFluid* reference_models = new_fluid(\"reference models\");\n\tplate* reference_plate = new_plate(REFERENCE_MODELS, 10);\n\tmeasure_fluid_volume(reference_models, reference_plate);\n\n\tcompare_fluid_volumes(printed_models, reference_models);\n\n\t//Step 3: Compare these values each other\n\tcompare_fluid_volumes_each_other(printed_models);\n} \n", "result_baseline4": {"opcode": "COMPARE", "slot": [["String", "Printed Model 1"], ["String", "Printed Model 2"]], "emit": "Comparison of linear measurements"}, "result_baseline5": {"opcode": "Measure", "slot": [["Container", "printed models"], ["Container", "reference models"], ["Volume", null]], "emit": "Comparison results"}}]}}, "Bioinformatics & Computational Biology": {"0": {"subject": "Bioinformatics & Computational Biology", "enum": 0, "protocol": "To evaluate CSC triage algorithms, review clinical data and existing algorithms, define the crisis, select and devise algorithms, define clinical endpoints, and select patient cohorts. Obtain IRB approval, create a case report form, choose a secure data management system, determine data entry method, conduct pilot data acquisition, complete data acquisition, apply triage algorithms, and calculate priority scores. Test algorithm accuracy using AUROC, simulate clinical decision-making in small patient groups using a bootstrap method, format input files with patient outcomes and priority scores, run simulations, and analyze decision-making efficacy.", "compile": [{"i": 0, "sentense": "To evaluate CSC triage algorithms, review clinical data and existing algorithms, define the crisis, select and devise algorithms, define clinical endpoints, and select patient cohorts.", "python": "python\ndef evaluate_triage_algorithm():\n    # Step 1: Review clinical data and existing algorithms\n    clinical_data = get_clinical_data()\n    existing_algorithms = get_existing_algorithms()\n    \n    # Step 2: Define the crisis\n    crisis_definition = define_crisis()\n    \n    # Step 3: Select and devise algorithms\n    selected_algorithm = select_algorithm(existing_algorithms)\n    \n    # Step 4: Define clinical endpoints\n    clinical_endpoints = define_endpoints()\n    \n    # Step 5: Select patient cohorts\n    patient_cohorts = select_cohorts(clinical_data)\n    \n    return selected_algorithm, clinical_endpoints, patient_cohorts\n", "biocoder": "No program", "result_baseline4": {"opcode": "evaluate_triage_algorithm", "slot": [["REG", "clinical data"], ["REG", "existing algorithms"], ["String", "crisis definition"], ["REG", "selected algorithm"], ["REG", "clinical endpoints"], ["REG", "patient cohorts"]], "emit": "selected_algorithm, clinical_endpoints, patient_cohorts"}, "result_baseline5": {"opcode": "experiment", "slot": [["Time", "24 hours"], ["Container", "Petri dish"], ["Temperature", "37\u00b0C"]], "emit": "cell viability assay"}}, {"i": 1, "sentense": "Obtain IRB approval, create a case report form, choose a secure data management system, determine data entry method, conduct pilot data acquisition, complete data acquisition, apply triage algorithms, and calculate priority scores."}, {"i": 2, "sentense": "Test algorithm accuracy using AUROC, simulate clinical decision-making in small patient groups using a bootstrap method, format input files with patient outcomes and priority scores, run simulations, and analyze decision-making efficacy.", "python": "python\nimport numpy as np\nfrom sklearn.metrics import roc_auc_score\nfrom sklearn.utils import resample\n\n# Step 1: Define the algorithm accuracy evaluation function using AUROC\ndef evaluate_algorithm_performance(true_labels, predicted_scores):\n    return roc_auc_score(true_labels, predicted_scores)\n\n# Step 2: Simulate clinical decision-making in small patient groups using a bootstrap method\ndef bootstrap_simulation(data, num_iterations=1000):\n    results = []\n    for _ in range(num_iterations):\n        bootstrap_data = resample(data)\n        # Apply decision-making algorithm and collect results\n        results.append(0)  # Placeholder for decision outcome\n    return results\n\n# Step 3: Format input files with patient outcomes and priority scores\n# Assume we have input_data with patient outcomes and priority scores\n\n# Step 4: Run simulations\nbootstrap_results = bootstrap_simulation(input_data)\n\n# Step 5: Analyze decision-making efficacy\ndecision_accuracy = sum(bootstrap_results) / len(bootstrap_results)\nprint(\"Decision-making efficacy:\", decision_accuracy)\n", "biocoder": "No program", "result_baseline4": {"opcode": "bootstrap_simulation", "slot": [["Device", null], ["Volume", null]], "emit": "Decision-making efficacy"}, "result_baseline5": {"opcode": "No program", "slot": [], "emit": "No output"}}]}, "1": {"subject": "Bioinformatics & Computational Biology", "enum": 1, "protocol": "Download and install STNMF from GitHub, link: https://github.com/jiankliu/STNMF-SNN. Process data by generating effective spike-triggered stimulus images (STE) from neuron spike trains and stimulus array, applying Singular Value Decomposition (SVD) for spatial and temporal filters. Use STNMF on STE to infer subunits' spatial receptive field, obtaining weight matrix W and module matrix M. Analyze M and W to infer temporal filters, nonlinearity, and synaptic weights of subunits. For detailed computational analysis, apply algorithms to calculate temporal filter, nonlinearity, and classify spikes into modules based on synaptic connection weights, aiming to reveal complex neuronal network dynamics.", "compile": [{"i": 0, "sentense": "Download and install STNMF from GitHub, link: https://github.com/jiankliu/STNMF-SNN.", "python": "python\n# Python program to describe the experimental protocol for downloading and installing STNMF from GitHub\n\nimport os\n\n# Step 1: Download STNMF from GitHub\nos.system('git clone https://github.com/jiankliu/STNMF-SNN.git')\n\n# Step 2: Install STNMF\nos.chdir('STNMF-SNN')\nos.system('python setup.py install')\n\nprint(\"STNMF has been successfully downloaded and installed.\")\n", "biocoder": "No program", "result_baseline4": {"opcode": "DOWNLOAD_INSTALL", "slot": [["String", "STNMF"], ["String", "GitHub"], ["String", "setup.py"]], "emit": "STNMF has been successfully downloaded and installed."}, "result_baseline5": {"opcode": "Experimental Protocol", "slot": [["REG", null], ["Device", null], ["Container", null], ["Time", null]], "emit": "Data analysis and visualization"}}, {"i": 1, "sentense": "Process data by generating effective spike-triggered stimulus images (STE) from neuron spike trains and stimulus array, applying Singular Value Decomposition (SVD) for spatial and temporal filters.", "python": "python\nimport numpy as np\n\ndef generate_ste(neuron_spikes, stimulus_array):\n    # Generate spike-triggered stimulus images (STE) \n    ste = np.zeros((neuron_spikes.shape[0], stimulus_array.shape[1]))\n\n    for i in range(neuron_spikes.shape[0]):\n        for j in range(neuron_spikes.shape[1]):\n            if neuron_spikes[i,j] == 1:\n                ste[i] += stimulus_array[j]\n\n    return ste\n\ndef apply_svd(ste):\n    # Apply Singular Value Decomposition (SVD) for spatial and temporal filters\n    u, s, vh = np.linalg.svd(ste, full_matrices=False)\n\n    spatial_filter = u[:,0]\n    temporal_filter = vh[0,:]\n\n    return spatial_filter, temporal_filter\n\n# Example usage\nneuron_spikes = np.array([[0, 1, 0, 0], [1, 0, 1, 1]])\nstimulus_array = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.0, 1.1, 1.2]])\n\nste = generate_ste(neuron_spikes, stimulus_array)\nspatial_filter, temporal_filter = apply_svd(ste)\n\nprint(\"Spatial filter:\", spatial_filter)\nprint(\"Temporal filter:\", temporal_filter)\n", "biocoder": "python\n# Biocoder format for the experimental protocol\n\ndef process_data(neuron_spike_trains, stimulus_array):\n    \"\"\"\n    Process data by generating effective spike-triggered stimulus images (STE) from neuron spike trains \n    and stimulus array, applying Singular Value Decomposition (SVD) for spatial and temporal filters.\n    Here, neuron_spike_trains refers to the temporal sequence of action potentials generated by a neuron,\n    and stimulus_array corresponds to the input stimuli received by the neuron.\n    \"\"\"\n    # Step 1: Generate spike-triggered stimulus images (STE)\n    ste_images = generate_ste_images(neuron_spike_trains, stimulus_array)\n    print(\"Spike-triggered stimulus images (STE) have been successfully generated.\")\n\n    # Step 2: Apply Singular Value Decomposition (SVD) for spatial and temporal filters\n    spatial_filter, temporal_filter = svd(ste_images)\n    print(\"Singular Value Decomposition (SVD) has been applied successfully.\")\n\n    return spatial_filter, temporal_filter\n\n\ndef generate_ste_images(neuron_spike_trains, stimulus_array):\n    \"\"\"\n    This function represents the step to generate STE images using neuron spike trains and stimulus array.\n    Actual implementation might involve signal processing and image generation techniques.\n    \"\"\"\n    pass\n\n\ndef svd(ste_images):\n    \"\"\"\n    This function represents the step to apply Singular Value Decomposition (SVD) for spatial and temporal filters.\n    Actual implementation might involve linear algebra techniques.\n    \"\"\"\n    pass\n", "result_baseline4": {"opcode": "STE", "slot": [["Device", null], ["Container", null], ["Container", null]], "emit": "Spatial and temporal filters"}, "result_baseline5": {"opcode": "", "slot": [], "emit": ""}}, {"i": 2, "sentense": "Use STNMF on STE to infer subunits' spatial receptive field, obtaining weight matrix W and module matrix M. Analyze M and W to infer temporal filters, nonlinearity, and synaptic weights of subunits.", "python": "python\n# Import necessary libraries\nimport numpy as np\nfrom scipy.optimize import nnls\n\n# Define the STE matrix\nSTE = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\n\n# Define the number of subunits\nK = 2\n\n# Initialize weight matrix W and module matrix M\nW = np.random.rand(len(STE), K)\nM = np.random.rand(K, K)\n\n# Perform STNMF to infer subunits' spatial receptive field\ndef STNMF(STE, W, M):\n    for i in range(100):\n        # Update W\n        W = W * (STE.dot(M.T) / (W.dot(M).dot(M.T)))\n        \n        # Update M\n        M = M * (W.T.dot(STE) / (W.T.dot(W).dot(M)))\n    \n    return W, M\n\n# Perform STNMF on STE\nW, M = STNMF(STE, W, M)\n\n# Analyze M and W to infer temporal filters, nonlinearity, and synaptic weights of subunits\ndef analyze_subunits(W, M):\n    # Infer temporal filters\n    temporal_filters = W\n    \n    # Infer nonlinearity\n    nonlinearity = np.mean(M, axis=0)\n    \n    # Infer synaptic weights of subunits\n    synaptic_weights = np.zeros(K)\n    for i in range(K):\n        synaptic_weights[i] = nnls(W, STE.dot(M[i]))[0][0]\n    \n    return temporal_filters, nonlinearity, synaptic_weights\n\ntemporal_filters, nonlinearity, synaptic_weights = analyze_subunits(W, M)\n\nprint(\"Temporal Filters:\")\nprint(temporal_filters)\nprint(\"Nonlinearity:\")\nprint(nonlinearity)\nprint(\"Synaptic Weights of Subunits:\")\nprint(synaptic_weights)\n", "biocoder": "No program", "result_baseline4": {"opcode": "STNMF", "slot": [["Container", "STE matrix"], ["Container", "W weight matrix"], ["Container", "M module matrix"]], "emit": "Temporal Filters, Nonlinearity, Synaptic Weights"}, "result_baseline5": {"opcode": "No program", "slot": [], "emit": "None"}}, {"i": 3, "sentense": "For detailed computational analysis, apply algorithms to calculate temporal filter, nonlinearity, and classify spikes into modules based on synaptic connection weights, aiming to reveal complex neuronal network dynamics.", "python": "python\ndef calculate_temporal_filter(data):\n    # Apply algorithm to calculate temporal filter\n    return temporal_filter\n\ndef calculate_nonlinearity(data):\n    # Apply algorithm to calculate nonlinearity\n    return nonlinearity\n\ndef classify_spikes(data, synaptic_weights):\n    # Apply algorithm to classify spikes into modules based on synaptic connection weights\n    return spike_modules\n\n# Sample data for testing the protocol\ndata = [0.2, 0.5, 0.8, 0.3, 0.6]\nsynaptic_weights = {'neuron1': [0.1, 0.5, 0.8, 0.3, 0.6], 'neuron2': [0.3, 0.2, 0.7, 0.4, 0.9]}\n\ntemporal_filter = calculate_temporal_filter(data)\nnonlinearity = calculate_nonlinearity(data)\nspike_modules = classify_spikes(data, synaptic_weights)\n\nprint(\"Temporal Filter:\", temporal_filter)\nprint(\"Nonlinearity:\", nonlinearity)\nprint(\"Spike Modules:\", spike_modules)\n", "biocoder": "No program", "result_baseline4": {"opcode": "SPIKE_CLASSIFICATION", "slot": [["Device", null], ["Container", null], ["Time", null]], "emit": "Spike Modules"}, "result_baseline5": {"opcode": "experiment", "slot": [["Time", null], ["Device", "microscope"], ["Container", "petri dish"]], "emit": "cell growth"}}]}, "2": {"subject": "Bioinformatics & Computational Biology", "enum": 2, "protocol": "Access PAD2 for TF colocalization analysis by selecting signal files from the database for targeted analysis within specific genomic regions identified by ChromHMM. Open PAD2 website, navigate to select signals, and choose TFs or histone marks of interest. Optionally, upload personal signal files for analysis. After selection, specify the genomic region of interest for colocalization assessment through Pearson\u2019s correlation of ChIP-seq profiles. Investigate signal correlation within these regions by viewing and downloading heatmap and ranked correlation plots. This streamlined approach involves selecting signal files, determining genomic regions for analysis, and utilizing correlation data to understand protein colocalization, all performed through the PAD2 platform.", "compile": [{"i": 0, "sentense": "Access PAD2 for TF colocalization analysis by selecting signal files from the database for targeted analysis within specific genomic regions identified by ChromHMM.", "python": "python\ndef perform_colocalization_analysis(genomic_regions, signal_files):\n    # Access PAD2 for TF colocalization analysis\n    # Select signal files from the database for targeted analysis within specific genomic regions identified by ChromHMM\n    # Perform TF colocalization analysis using selected signal files and genomic regions\n    \n    print(\"Performing TF colocalization analysis for genomic regions:\", genomic_regions)\n    print(\"Using signal files:\", signal_files)\n\n# Sample input data\ngenomic_regions = [\"enhancer\", \"promoter\"]\nsignal_files = [\"signal_file1.txt\", \"signal_file2.txt\"]\n\n# Call the function with the sample input data\nperform_colocalization_analysis(genomic_regions, signal_files)\n", "biocoder": "pseudo\nprocedure Access_PAD2_tf_colocalization():\n\nbegin_step(\"Access PAD2 for TF colocalization analysis\")\ncomments(\"This process requires selection of signal files from the database for targeted analysis within specific genomic regions identified by ChromHMM.\")\n# Since Biocoder doesn't support interactions with databases or files, \n# this step is more a guideline to the conduct of the research.\n\nend_step(\"Access PAD2 for TF colocalization analysis\")\n\nend_procedure()\n", "result_baseline4": {"opcode": "perform_colocalization_analysis", "slot": [["Container", "genomic_regions"], ["Container", "signal_files"]], "emit": "TF colocalization analysis"}, "result_baseline5": {"opcode": "Access PAD2_tf_colocalization", "slot": [["Device", null], ["String", "signal files from the database"], ["String", "specific genomic regions identified by ChromHMM"]], "emit": "targeted analysis"}}, {"i": 1, "sentense": "Open PAD2 website, navigate to select signals, and choose TFs or histone marks of interest."}, {"i": 2, "sentense": "Optionally, upload personal signal files for analysis.", "python": "python\ndef analyze_signal(signal_files):\n    if signal_files:\n        for file in signal_files:\n            # Read and process the signal file\n            print(f\"Analyzing signal file: {file}\")\n            # Add your signal processing code here\n    else:\n        print(\"No signal files provided for analysis.\")\n\n# Sample signal files\nsignal_files = ['signal1.txt', 'signal2.txt', 'signal3.txt']\n\n# Perform signal analysis\nanalyze_signal(signal_files)\n", "biocoder": "python\ndef personal_signal_files_analysis():\n  begin_protocol(\"Personal Signal Files Analysis\")\n  comment(\"Upload personal signal files for analysis\")\n\n  step(\"Optionally, upload personal signal files for analysis.\")\n  end_protocol()\n", "result_baseline4": {"opcode": "analyze_signal", "slot": [["Container", "signal_files"]], "emit": "Signal analysis results"}, "result_baseline5": {"opcode": "personal_signal_files_analysis", "slot": [["String", "Upload personal signal files for analysis"], ["String", "Optionally, upload personal signal files for analysis."], ["String", null]], "emit": "null"}}, {"i": 3, "sentense": "After selection, specify the genomic region of interest for colocalization assessment through Pearson\u2019s correlation of ChIP-seq profiles."}, {"i": 4, "sentense": "Investigate signal correlation within these regions by viewing and downloading heatmap and ranked correlation plots."}, {"i": 5, "sentense": "This streamlined approach involves selecting signal files, determining genomic regions for analysis, and utilizing correlation data to understand protein colocalization, all performed through the PAD2 platform."}]}, "3": {"subject": "Bioinformatics & Computational Biology", "enum": 3, "protocol": "Install STNMF by downloading from GitHub (https://github.com/jiankliu/STNMF-SNN) and adding to MATLAB path. Preprocess data by generating effective spike-triggered stimulus images from stimulus array and spike trains, using Singular Value Decomposition for spatial and temporal filters, and forming an N\u00d7P matrix STE. Decompose STE with STNMF to obtain weight matrix W and module matrix M, preset subunits number, reshape M for stimulus frame size. Analyze M and W to infer subunits' temporal filter, nonlinearity, and synaptic connection weights by calculating spatial filter and temporal filter convolution, creating generator signal, and visualizing nonlinearity. Obtain synaptic connection weights and spike trains by averaging W matrix columns, determining ON-OFF attribute, and classifying spikes into corresponding modules.", "compile": [{"i": 0, "sentense": "Install STNMF by downloading from GitHub (https://github.com/jiankliu/STNMF-SNN) and adding to MATLAB path.", "python": "python\nimport os\n\n# Step 1: Download STNMF from GitHub\nos.system(\"git clone https://github.com/jiankliu/STNMF-SNN.git\")\n\n# Step 2: Add STNMF to MATLAB path\nos.system(\"addpath(genpath('STNMF-SNN'))\")\n\nprint(\"STNMF has been successfully installed.\")\n", "biocoder": "c++\n#include \"Biocoder.h\"\n\nvoid setup()\n{\n  start_protocol(\"STNMF installation\");\n\n  comment(\"This protocol must be performed in a computer system with MATLAB installed.\");\n\n  comment(\"Step 1: Download STNMF from GitHub\");\n  string object = download_from_url(\n      \"https://github.com/jiankliu/STNMF-SNN\");\n\n  comment(\"Unzip the downloaded file if it is a .zip file. You can execute this action with suitable software on your PC.\");\n\n  comment(\"Step 2: Add the file to the MATLAB path\");\n  const char *command =\n      \"addpath(genpath('/path/to/STNMF-SNN'))\";\n  comment(\n      command,\n      \"Note: Replace '/path/to/STNMF-SNN' with the path where you have downloaded the STNMF.\");\n}\n\nint main()\n{\n  setup();\n\n  return 0;\n}\n", "result_baseline4": {"opcode": "install_STNMF", "slot": [["String", "git clone https://github.com/jiankliu/STNMF-SNN"], ["String", "addpath(genpath('STNMF-SNN'))"], ["String", null]], "emit": "STNMF has been successfully installed."}, "result_baseline5": {"opcode": "STNMF installation", "slot": [["String", "This protocol must be performed in a computer system with MATLAB installed."], ["String", "Step 1: Download STNMF from GitHub"], ["String", "Unzip the downloaded file if it is a .zip file. You can execute this action with suitable software on your PC."], ["String", "Step 2: Add the file to the MATLAB path"]], "emit": "addpath(genpath('/path/to/STNMF-SNN'))"}}, {"i": 1, "sentense": "Preprocess data by generating effective spike-triggered stimulus images from stimulus array and spike trains, using Singular Value Decomposition for spatial and temporal filters, and forming an N\u00d7P matrix STE.", "python": "python\nimport numpy as np\n\ndef generate_STE(stimulus_array, spike_trains, num_components):\n    # Perform Singular Value Decomposition to obtain spatial and temporal filters\n    U, s, Vt = np.linalg.svd(stimulus_array, full_matrices=False)\n    spatial_filters = U[:, :num_components]\n    temporal_filters = Vt[:num_components, :]\n    \n    # Generate effective spike-triggered stimulus images\n    STE = np.dot(spatial_filters, np.dot(np.diag(s), temporal_filters))\n    \n    return STE\n\n# Example usage\nstimulus_array = np.random.rand(100, 50)  # Example stimulus array of shape 100x50\nspike_trains = np.random.randint(0, 2, 100)  # Example spike trains of length 100\nnum_components = 5  # Number of components to keep for STE calculation\n\nSTE = generate_STE(stimulus_array, spike_trains, num_components)\nprint(STE)\n", "biocoder": "c#\nBEGIN_PROTOCOL(\"Preprocessing Data\");\n\n// Pesudo code for the preprocessing in Biocoder form\nCOMMENT(\"Define variables\");\n\nSOLUTION(\"stimulus array\");\nSOLUTION(\"spike trains\");\n\nCOMMENT(\"Generate spike-triggered stimulus images\");\n\nCODE_SNIPPET(\"\nfor each data in stimulus array:\n  for each spike in spike trains:\n    Form images using spike and data\n\");\n\nCOMMENT(\"Apply Singular Value Decomposition (SVD) for spatial and temporal filters\");\n\nCODE_SNIPPET(\"\nfor each image:\n  Apply SVD for spatial filter\n  Apply SVD for temporal filter\n\");\n\nCOMMENT(\"Form a N\u00d7P matrix STE (Spike-Triggered Ensemble)\");\n\nCODE_SNIPPET(\"\nForm STE matrix using spatial and temporal filters\n\");\n\nEND_PROTOCOL();\n", "result_baseline4": {"opcode": "GENERATE_STE", "slot": [["Container", "stimulus_array"], ["Container", "spike_trains"], ["Length", 5]], "emit": "STE"}, "result_baseline5": {"opcode": "Preprocessing Data", "slot": [["String", "stimulus array"], ["String", "spike trains"], ["String", null]], "emit": "Spike-Triggered Ensemble (STE) matrix"}}, {"i": 2, "sentense": "Decompose STE with STNMF to obtain weight matrix W and module matrix M, preset subunits number, reshape M for stimulus frame size."}, {"i": 3, "sentense": "Analyze M and W to infer subunits' temporal filter, nonlinearity, and synaptic connection weights by calculating spatial filter and temporal filter convolution, creating generator signal, and visualizing nonlinearity.", "python": "python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Step 1: Calculate spatial filter\ndef calculate_spatial_filter(M, W):\n    spatial_filter = np.dot(W, M.T)\n    return spatial_filter\n\n# Step 2: Calculate temporal filter convolution\ndef calculate_temporal_filter_convolution(M, temporal_filter):\n    temporal_filter_convolution = np.dot(temporal_filter, M)\n    return temporal_filter_convolution\n\n# Step 3: Create generator signal\ndef create_generator_signal(spatial_filter, temporal_filter_convolution):\n    generator_signal = spatial_filter * temporal_filter_convolution\n    return generator_signal\n\n# Step 4: Visualize nonlinearity\ndef visualize_nonlinearity(generator_signal):\n    nonlinearity = np.maximum(generator_signal, 0)\n    plt.plot(generator_signal, nonlinearity, label='Nonlinearity')\n    plt.xlabel('Generator Signal')\n    plt.ylabel('Nonlinearity')\n    plt.legend()\n    plt.show()\n\n# Main function to run the protocol\ndef main(M, W, temporal_filter):\n    spatial_filter = calculate_spatial_filter(M, W)\n    temporal_filter_convolution = calculate_temporal_filter_convolution(M, temporal_filter)\n    generator_signal = create_generator_signal(spatial_filter, temporal_filter_convolution)\n    visualize_nonlinearity(generator_signal)\n\n# Example input data\nM = np.random.randn(100, 50)\nW = np.random.randn(10, 50)\ntemporal_filter = np.random.randn(10, 1)\n\n# Run the protocol\nmain(M, W, temporal_filter)\n", "biocoder": "\nbegin_protocol(\"Analyze M and W to infer subunits' temporal filter, nonlinearity, and synaptic connection weights\");\n\ncomment(\"Step 1: Calculate spatial filter and temporal filter convolution\");\nFluid spatial_filter = new_fluid(\"spatial_filter\");\nFluid temporal_filter = new_fluid(\"temporal_filter\");\nFluid convolution_result = new_fluid(\"convolution_result\");\n\ncalc_convolution(spatial_filter, temporal_filter, convolution_result);\n\ncomment(\"Step 2: Create generator signal\");\nFluid generator_signal = new_fluid(\"generator_signal\");\ncreate_generator_signal(generator_signal);\n\ncomment(\"Step 3: Visualize nonlinearity\");\nFluid nonlinearity = new_fluid(\"nonlinearity\");\nvisualize_nonlinearity(nonlinearity);\n\nend_protocol();\n", "result_baseline4": {"opcode": "Run", "slot": [["Container", "M"], ["Container", "W"], ["Container", "temporal_filter"]], "emit": "Visualization of Nonlinearity"}, "result_baseline5": {"opcode": "Analyze", "slot": [["String", "M and W"], ["String", "subunits' temporal filter, nonlinearity, and synaptic connection weights"], ["Device", null]], "emit": "spatial filter, temporal filter convolution, generator signal, visualize nonlinearity"}}, {"i": 4, "sentense": "Obtain synaptic connection weights and spike trains by averaging W matrix columns, determining ON-OFF attribute, and classifying spikes into corresponding modules.", "python": "python\nimport numpy as np\n\n# Obtain synaptic connection weights by averaging W matrix columns\nW_matrix = np.random.rand(5, 5)  # Example W matrix\naverage_weights = np.mean(W_matrix, axis=0)\n\n# Determine ON-OFF attribute\nthreshold = 0.5\non_off_attribute = [1 if weight > threshold else 0 for weight in average_weights]\n\n# Classify spikes into corresponding modules\nspike_train = np.random.randint(2, size=(5, 10))  # Example spike train data\nmodule_classification = np.argmax(spike_train, axis=0)\n\nprint(\"Average synaptic connection weights:\", average_weights)\nprint(\"ON-OFF attribute:\", on_off_attribute)\nprint(\"Module classification:\", module_classification)\n", "biocoder": "Biocoder\nprocedure main() {\n    Solutions W_matrix;\n    Solutions synaptic_weights;\n    Solutions spike_trains;\n    Solutions ON_OFF_attribute;\n    Solutions modules;\n\n    step(\"Start Protocol\",\n        \"In this protocol we will get synaptic connection weights and \" +\n        \"spike trains averaging over the columns of the weight matrix W and \"+\n        \"determine ON-OFF attribute, finally classifying spikes into corresponding modules.\");\n\n    step(\"Obtain Synaptic Connection Weights\",\n        \"Average the columns of the weight matrix W to obtain the synaptic connection weights. \"+\n        \"The resulting synaptic weights are stored in the 'synaptic_weights' solution.\");\n\n    step(\"Determine ON-OFF Attribute\",\n        \"Using your analysis method of choice, determine the ON-OFF attribute of the system. \" +\n        \"The results are stored in the 'ON_OFF_attribute' solution.\");\n\n    step(\"Classify Spikes Into Modules\",\n        \"Given the spike trains, classify them into corresponding modules according \" +\n        \"to your classification criteria. The final classification is stored in the \"+\n        \"'modules' solution.\");\n\n    step(\"End Protocol\",\n        \"The synaptic connection weights and spike trains have been obtained, \"+\n        \"and the spikes have been classified.\");\n}\n", "result_baseline4": {"opcode": "Obtain synaptic connection weights", "slot": [["Device", null], ["Container", null], ["Bool", 0.5]], "emit": "Average synaptic connection weights"}, "result_baseline5": {"opcode": "Obtain Synaptic Connection Weights", "slot": [["Container", "weight matrix W"], ["Container", "synaptic_weights"]], "emit": "synaptic connection weights"}}]}, "4": {"subject": "Bioinformatics & Computational Biology", "enum": 4, "protocol": "To format phosphoproteomic data for CausalPath analysis, first ensure the data is in the required format, potentially using R for reformatting. Adjust parameters in parameters.txt to match your analysis needs, including specifying input files and analysis options. Execute the CausalPath algorithm via command line with the necessary files in the same directory, producing results in various formats for detailed network analysis. Visualization of the phosphoproteomic network can be done through the CausalPath website or alternative tools like Newt or ChiBE, providing insights into causal relationships and network dynamics. This process involves critical steps such as data preparation, parameter adjustment, algorithm execution, and result visualization, each contributing to the comprehensive analysis of phosphoproteomic data.", "compile": [{"i": 0, "sentense": "To format phosphoproteomic data for CausalPath analysis, first ensure the data is in the required format, potentially using R for reformatting.", "python": "python\n# Python program to format phosphoproteomic data for CausalPath analysis\n\ndef reformat_data(input_data):\n    # code to format the data for CausalPath analysis\n    formatted_data = input_data # placeholder, actual code will depend on the specific data format requirements\n    return formatted_data\n\n# Sample phosphoproteomic data\ninput_data = [\"protein1:phospho1\", \"protein2:phospho2\", \"protein3:phospho3\"]\n\n# Reformat the data for CausalPath analysis\nformatted_data = reformat_data(input_data)\n\nprint(\"Formatted phosphoproteomic data for CausalPath analysis:\")\nprint(formatted_data)\n", "biocoder": "No program", "result_baseline4": {"opcode": "reformat_data", "slot": [["Container", "phosphoproteomic data"]], "emit": "formatted_data"}, "result_baseline5": {"opcode": "Experimental Protocol", "slot": [["Time", null], ["Bool", null], ["Concentration", "10mM"], ["Temperature", null]], "emit": "Data Analysis"}}, {"i": 1, "sentense": "Adjust parameters in parameters.txt to match your analysis needs, including specifying input files and analysis options.", "python": "python\n# Read parameters from parameters.txt\nwith open('parameters.txt', 'r') as f:\n    parameters = f.readlines()\n\n# Define input files and analysis options\ninput_file1 = parameters[0].strip()\ninput_file2 = parameters[1].strip()\nanalysis_option1 = parameters[2].strip()\nanalysis_option2 = parameters[3].strip()\n\n# Perform analysis with input files and options\n# Add your code here\n", "biocoder": "No program", "result_baseline4": {"opcode": "Perform analysis", "slot": [["String", "input_file1"], ["String", "input_file2"], ["String", "analysis_option1"], ["String", "analysis_option2"]], "emit": "Analysis results"}, "result_baseline5": {"opcode": "No action specified", "slot": [], "emit": "No output specified"}}, {"i": 2, "sentense": "Execute the CausalPath algorithm via command line with the necessary files in the same directory, producing results in various formats for detailed network analysis.", "python": "python\nimport os\n\n# Command to execute the CausalPath algorithm with necessary files\ncommand = \"CausalPath -i input_file.txt -o output_file.txt -f detailed_results\"\n\n# Execute the command in the same directory\nos.system(command)\n", "biocoder": "bash\n# Execute the CausalPath algorithm in a Bash shell\n./CausalPath inputFile outputFile\n", "result_baseline4": {"opcode": "execute CausalPath algorithm", "slot": [["String", "CausalPath -i input_file.txt -o output_file.txt -f detailed_results"], ["String", "os.system(command)"], ["Device", null]], "emit": "output_file.txt"}, "result_baseline5": {"opcode": "Execute", "slot": [["String", "CausalPath algorithm"], ["String", "inputFile"], ["String", "outputFile"]], "emit": "Processed data"}}, {"i": 3, "sentense": "Visualization of the phosphoproteomic network can be done through the CausalPath website or alternative tools like Newt or ChiBE, providing insights into causal relationships and network dynamics."}, {"i": 4, "sentense": "This process involves critical steps such as data preparation, parameter adjustment, algorithm execution, and result visualization, each contributing to the comprehensive analysis of phosphoproteomic data.", "python": "python\ndef data_preparation():\n    # This function prepares the phosphoproteomic data\n    print(\"Data preparation step\")\n\ndef parameter_adjustment():\n    # This function adjusts the parameters for the algorithm\n    print(\"Parameter adjustment step\")\n\ndef algorithm_execution():\n    # This function executes the algorithm on the prepared data\n    print(\"Algorithm execution step\")\n\ndef result_visualization():\n    # This function visualizes the results of the algorithm\n    print(\"Result visualization step\")\n\n# Main function to run the protocol\ndef run_protocol():\n    data_preparation()\n    parameter_adjustment()\n    algorithm_execution()\n    result_visualization()\n\n# Run the protocol\nrun_protocol()\n", "biocoder": "\n# Begin Protocol\n\n## Step 1: Data Preparation\n  # Input data\n  # Clean data (Remove missing values, etc.)\n  # Normalize data (If necessary)\n  # Split data into training and testing sets\n\n## Step 2: Parameter Adjustment\n  # Define model parameters\n  # Tune parameters using cross validation\n\n## Step 3: Algorithm Execution\n  # Train model on the training set\n  # Test model on testing set\n  # Record model performance\n\n## Step 4: Result Visualization\n  # Generate confusion matrix\n  # Plot ROC curve\n  # Compute and display performance metrics\n\n# End Protocol\n", "result_baseline4": {"opcode": "Protocol Execution", "slot": [["Device", null], ["String", "phosphoproteomic data"], ["String", "algorithm parameters"]], "emit": "Result visualization step"}, "result_baseline5": {"opcode": "Data Analysis", "slot": [["Time", null], ["String", "Training and Testing Data"], ["String", "Model Parameters"], ["String", "Cross Validation"], ["String", "Training Model"], ["String", "Testing Model"], ["String", "Model Performance"], ["Bool", null], ["String", "Confusion Matrix"], ["String", "ROC Curve"], ["String", "Performance Metrics"]], "emit": "Data Analysis Report"}}]}}}