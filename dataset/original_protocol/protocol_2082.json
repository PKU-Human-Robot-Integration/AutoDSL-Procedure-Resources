{
  "id": 2196,
  "origin_website": "Cell",
  "title": "Protocol for analysis of RNA-sequencing and proteome profiling data for subgroup identification and comparison",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nPreparation of RNA-seq data for cluster analysis\nTiming:  < 30 min\nBoth RNA-seq and proteomic data require transformation and/or normalization prior to analysis. For analysis of RNA-seq data, the TPM values are used for cluster analysis as they account for gene length and sequencing depth, and the RNA-seq count data is used for differential analysis. To prepare these two datasets for analyses, RNA annotations are added. To prepare the TPM data for cluster analysis, protein-coding mRNAs are log-transformed, and low level mRNAs are removed as background noise.\nAdd annotations to RNA features for the TPM and COUNT data loaded in above.\nNote: Additional annotations of RNA features are necessary for downstream analysis, particularly when comparing to proteomic data. For the purpose of this protocol, it is critical to add two types of annotations to the RNA features: the gene biotype and the HGNC symbol. The former allows filtering for protein-coding mRNAs, while the latter serves as a common identifier type in analyses involving both mRNA and protein data.\n>GRCh37.87 <- useMart(biomart = \"ENSEMBL_MART_ENSEMBL\",\n                          host = \"dec2016.archive.ensembl.org\",\n                          dataset = \"hsapiens_gene_ensembl\")\n>RNA.anno <- getBM(attributes = c(\"ensembl_gene_id\", “hgnc_symbol\", \"entrezgene\", \"gene_biotype\"), filters = \"ensembl_gene_id\", values = COUNT$EnsemblGeneID, mart = GRCh37.87, useCache = F) %>%\n  set_colnames(c(\"EnsemblGeneID\", \"HGNCSymbol\", \"EntrezID\", \"Biotype\")) %>%\n  dplyr::mutate(EntrezID = as.character(EntrezID)) %>%\n  group_by(EnsemblGeneID, Biotype) %>%\n  dplyr::summarise(HGNCSymbol = ifelse(length(unique(HGNCSymbol)) > 1, paste(unique(HGNCSymbol), collapse = \", \"), unique(HGNCSymbol)), EntrezID = ifelse(length(unique(EntrezID)) > 1, paste(unique(EntrezID), collapse = \", \"), unique(EntrezID))) %>%\n  ungroup %>%\n  mutate_all(function(x) na_if(x, \"NA\")) %>%\n  mutate_all(function(x) na_if(x, \"\"))\n>head(RNA.anno)\n# A tibble: 6 × 4\n    EnsemblGeneID      Biotype              HGNCSymbol   EntrezID\n    <chr>                <chr>                 <chr>        <chr>\n1  ENSG00000000003    protein_coding    TSPAN6      7105\n2  ENSG00000000005    protein_coding    TNMD        64102\n3  ENSG00000000419    protein_coding    DPM1        8813\n4  ENSG00000000457    protein_coding    SCYL3        57147\n5  ENSG00000000460    protein_coding    C1orf112    55732\n6  ENSG00000000938    protein_coding    FGR          2268",
    ">COUNT <- left_join(COUNT, RNA.anno, by = \"EnsemblGeneID\")\n>TPM <- left_join(TPM, RNA.anno, by = \"EnsemblGeneID\")\n>COUNT %>%\n  dplyr::select(where(is.character), where(is.numeric)) %>%\n  head\n# A tibble: 6 × 44\n    EnsemblGeneID      Start        En        Strand      Biotype    HGNCSymbol\n    <chr>                <chr>        <chr>    <chr>      <chr>       <chr>\n1  ENSG00000223972    11869;11…  1222…    +;+;+…    transc…    DDX11L1\n2  ENSG00000227232    14363;14…  1482…    -;-;-…    unproc…    WASH7P\n3  ENSG00000243485    29554;30…  3003…    +;+;+…    lincRNA    MIR1302-2\n4  ENSG00000237613    34554;35…  3517…    -;-;-…    lincRNA    FAM138A\n5  ENSG00000268020    52473;53…  5331…    +;+;+       unproc…  OR4G4P\n6  ENSG00000240361    62948      63887    +           unproc…  OR4G11P\n# … with 38 morevariables:EntrezID <chr>,Length<dbl>,\n#S1 <dbl>, S2 <dbl>,S3 <dbl>, S4 <dbl>, S5 <dbl>,\n#S6 <dbl>, S7 <dbl>,S8 <dbl>, S9 <dbl>,S10 <dbl>,\n#S11 <dbl>, S12 <dbl>,S13 <dbl>, S14 <dbl>, S15 <dbl>,\n#S16 <dbl>, S17 <dbl>,S19 <dbl>, S21 <dbl>, S22 <dbl>,\n#S23 <dbl>, S24 <dbl>,S25 <dbl>, S26 <dbl>, S27 <dbl>,\n#S28 <dbl>, S29 <dbl>,S30 <dbl>, S31 <dbl>, …\nNote: Three feature annotation columns are added to the COUNT and TPM data: Biotype, HGNCSymbol and EntrezID, corresponding to the biotype, HGNC symbol and Entrez ID of each gene. The addition of Entrez IDs is optional but sometimes necessary depending on downstream analysis requirements.\nNote: Users wishing to use a different genome assembly may do so by changing the “host” and “dataset” arguments to obtain gene annotations from a different version or species, respectively.\nPrepare log-transformed TPM matrix\nNote: For cluster analysis, a matrix of log2-transformed TPM values is needed. Here, a numeric matrix is generated from the TPM values of protein-coding genes. Lowly expressed mRNAs, defined here as those expressed below 1 TPM in more than 50% of the cohort, are removed before being log2-transformed.\n>logTPM <- TPM %>%\n  filter(., Biotype == \"protein_coding\") %>%\n  column_to_rownames(\"EnsemblGeneID\") %>%\n  dplyr::select(matches(\"S\\\\d{1,2}\")) %>%\n  as.matrix %>% {\n    mat = .\n    mat %>%\n      is_greater_than(1) %>%\n      rowSums %>%\n      is_weakly_greater_than(ncol(mat)*0.5) %>%\n      mat[.,] %>% return\n  } %>%\n  add(1) %>%\n  log2",
    ">logTPM[1:5, 1:8]\n                              S1            S2          S3          S4\nENSG00000187634    6.121744    5.120782    7.141506    1.659699\nENSG00000188976    5.596282    5.030179    5.147660    4.232472\nENSG00000187961    4.295906    2.720688    3.048589    2.280037\nENSG00000188290    4.405557    4.465438    4.933465    4.386167\nENSG00000187608    3.753190    3.237547    3.458798    3.622116\n                              S5            S6            S7          S8\nENSG00000187634    3.180383    3.709654    2.282866    3.597135\nENSG00000188976    5.044459    4.852175    4.906102    5.338667\nENSG00000187961    3.991705    3.105126    3.108855    4.104080\nENSG00000188290    4.704014    3.947958    3.864484    5.879325\nENSG00000187608    2.700303    2.703028    2.438892    4.112869\nNote: The gene expression threshold is arbitrarily set but should take into consideration the research question and cohort composition. Users wishing to adjust the gene expression threshold may do so by changing the 8th and 10th lines in the code chunk above. The is_greater_than(1) line identifies all TPM measurements above 1 while the is_weakly_greater_than(ncol(mat)∗0.5) identifies features with expression above 1 TPM in 50% or more of the cohort.\nCritical: A small constant (in this case 1) must be added to all TPM values prior to log2-transformation to avoid errors arising from taking the logarithm of zeroes. We prefer to use a constant of 1 because log2 of 1 returns zero.\nPreparation of proteomic data for cluster analysis\nTiming:  < 1 h\nSimilar to RNA-seq data, the proteomic data should be transformed and normalized. Additionally, the PSM data should be converted into peptide and eventually protein -level data for analysis. Since the proteomic data were generated based on relative abundance, all identified proteins with quantitative values are used.",
    "Note: Measurements obtained from RNA-seq and quantitative proteomic mass spectrometry are distinct in nature due to the differences in the corresponding technology. While RNA-seq can provide absolute counts, our TMT-based proteomic method estimated the abundances of PSMs in each sample relative to other samples within the same run. The two datasets therefore require different preparation steps for transformation and normalization to account for differences such as their data distributions. For further details on RNA-seq and quantitative proteomic mass spectrometry comparisons, see references (Nesvizhskii, 2010[href=https://www.wicell.org#bib20]; Ning et al., 2012[href=https://www.wicell.org#bib21]; Wang et al., 2014[href=https://www.wicell.org#bib31]).\nNormalize and aggregate PSMs into proteins.\nNote: The PSM abundance measurements loaded in above are aggregated into peptide and then into protein abundance using the median values as the representation. Variance stabilizing normalization (VSN) is applied to normalize and transform peptide abundances prior to collapsing into proteins. The measurements from ambiguously mapped peptides (ie. present in more than one protein) are excluded.\n>PRO <- PSM %>%\n  lapply(., function(x) {\n    pep <- x %>%\n      filter(., `Number of Protein Groups` == 1) %>%\n      dplyr::select(`Master Protein Accessions`, `Annotated Sequence`, 16:25) %>%\n      dplyr::rename(ProteinAccession = `Master Protein Accessions`, Sequence = `Annotated Sequence`) %>%\n      dplyr::mutate(Sequence =\n        toupper(str_extract(Sequence,\n                    \"(?<=\\\\.).*(?=\\\\.)\"))) %>%\n      na.omit %>%\n      filter(., !grepl(\"sp\", ProteinAccession)) %>%\n      group_by(ProteinAccession, Sequence) %>%\n      summarise_all(median) %>%\n      ungroup\n    pep <- pep %>%\n      dplyr::select(-ProteinAccession, -Sequence) %>%\n      as.matrix %>%\n      justvsn %>%\n      data.frame(ProteinAccession = pep$ProteinAccession, .)\n    pro <- pep %>%\n      group_by(ProteinAccession) %>%\n      summarise_all(median) %>%\n      ungroup\n    return(pro)\n  })\n>head(PRO$TMT1)\n# A tibble: 6 × 11\n    ProteinAccession      S8      S9    S14    S21      S20      S30    S40\n    <fct>                <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n1  A0AUZ9              5.57    6.20    6.84    5.88    6.29    7.00    5.89\n2  A0AV96              3.22    2.22    3.20    2.61    4.01    2.37    2.20\n3  A0AVF1              1.12    1.32    0.785  0.878    1.05  0.944  1.17\n4  A0AVT1              4.84    4.70    5.20    5.08    4.85    5.77    5.11",
    "5  A0FGR8              3.95    4.28    4.64    4.05    4.70    4.48    4.35\n6  A0JNW5              1.12    2.16    2.06    1.65    1.65    1.38    2.08\n# … with 3 more variables: S22 <dbl>, P1 <dbl>, SM1 <dbl>\n>sapply(PRO, nrow)\nTMT1 TMT2 TMT3 TMT4 TMT5\n8183 7882 8058 7498 7847\nNote: Users may opt for their preferred normalization method by changing the justvsn function on the 18th line in the above code to their desired function. For example, the normalizeBetweenArrays() function from the limma package can be used to perform median or quantile -normalization. We use VSN in our protocol as it was shown to be superior in reducing variation between technical replicates (Välikangas et al., 2018[href=https://www.wicell.org#bib30]). After variance stabilizing normalization, the peptide abundance values are in log2-scale and no further transformation is necessary.\nCompile protein abundance from separate TMT runs.\nNote: As mentioned earlier, each proteomic run may identify a different set of proteins. For proteomic analysis of the entire cohort of specimens, only proteins identified and quantitated across all specimens are used.\n>TMT <- sapply(PRO, function(x) x[,-1] %>% colnames) %>%\n  melt %>%\n  extract(,2:3) %>%\n  set_colnames(c(\"Batch\", \"SampleID\"))\n>head(TMT)\n    Batch    SampleID\n1    TMT1      S8\n2    TMT1      S9\n3    TMT1      S14\n4    TMT1      S21\n5    TMT1      S20\n6    TMT1      S30\n>PRO <- PRO %>%\n  purrr::reduce(inner_join, by = \"ProteinAccession\")\n>PRO\n# A tibble: 6,037 × 51\n  ProteinAccession  S8      S9      S14      S21      S20      S30      S40\n  <fct                <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n1  A0AV96              3.22    2.22    3.20    2.61    4.01    2.37    2.20\n2  A0AVF1              1.12    1.32    0.785  0.878  1.05    0.944  1.17\n3  A0AVT1              4.84    4.70    5.20    5.08    4.85    5.77    5.11\n4  A0FGR8              3.95    4.28    4.64    4.05    4.70    4.48    4.35\n5  A0MZ66              5.22    4.77    4.38    4.71    4.72    4.34    3.90\n6  A1IGU5              5.39    7.23    6.18    6.54    4.71    7.04    5.61\n7  A1KXE4              2.41    3.26    2.34    2.97    2.49    3.01    3.45",
    "8  A1L0T0              6.17    5.81    7.36    5.45    6.97    5.71    4.92\n9  A1L188              3.09    2.84    3.20    3.44    3.02    2.57    3.56\n10A1L390              5.23    4.21    4.46    4.03    2.38    2.71    4.17\n# … with 6,027 more rows, and 43 more variables: S22 <dbl>,\n#  P1 <dbl>, SM1 <dbl>, S12 <dbl>, S5 <dbl>, S4 <dbl>,\n#  S28 <dbl>, S25 <dbl>, S2 <dbl>, S7 <dbl>, S29 <dbl>,\n#  P2 <dbl>, SM2 <dbl>, S27 <dbl>, S39 <dbl>, S36 <dbl>,\n#  S1 <dbl>, S13 <dbl>, S19 <dbl>, S35 <dbl>, S34 <dbl>,\n#  P3 <dbl>, SM3 <dbl>, S15 <dbl>, S18 <dbl>, S17 <dbl>,\n#   S26 <dbl>, S10 <dbl>, S24 <dbl>, S32 <dbl>, S38 <dbl>, …\nAdd annotations to protein features to enable downstream analysis and mRNA-protein comparison.\n>PRO <- getBM(attributes = c(\"uniprot_swissprot\", \"hgnc_symbol\", \"entrezgene\"), filters = \"uniprot_swissprot\", values = PRO$ProteinAccession, mart = GRCh37.87, useCache = F) %>%\n  set_colnames(c(\"ProteinAccession\", \"HGNCSymbol\", \"EntrezID\")) %>%\n  dplyr::mutate(EntrezID = as.character(EntrezID)) %>%\n  group_by(ProteinAccession) %>%\n  dplyr::summarise(HGNCSymbol =\n  ifelse(length(unique(HGNCSymbol)) > 1,\n  paste(unique(HGNCSymbol), collapse = \", \"),\n  unique(HGNCSymbol)), EntrezID =\n  ifelse(length(unique(EntrezID)) > 1,\n  paste(unique(EntrezID), collapse = \", \"),\n  unique(EntrezID))) %>%\n  ungroup %>%\n  mutate_all(function(x) na_if(x, \"NA\")) %>%\n  mutate_all(function(x) na_if(x, \"\")) %>%\n  left_join(PRO, ., by = \"ProteinAccession\") %>%\n  dplyr::select(ProteinAccession, HGNCSymbol, EntrezID, everything())\n>PRO\n# A tibble: 6,037 × 53\n    ProteinAccession  HGNCSymbol   EntrezID  S8      S9      S14\n    <chr>              <chr>        <chr>       <dbl>  <dbl>   <dbl>\n1  A0AV96              RBM47        54502      3.22    2.22    3.20\n2  A0AVF1              TTC26        79989      1.12    1.32    0.785\n3  A0AVT1              UBA6          55236      4.84    4.70    5.20\n4  A0FGR8              ESYT2        57488      3.95    4.28    4.64\n5  A0MZ66              SHTN1        57698      5.22    4.77    4.38\n6  A1IGU5              ARHGEF37      389337    5.39    7.23    6.18\n7  A1KXE4              FAM168B      130074    2.41    3.26    2.34\n8  A1L0T0              ILVBL        10994      6.17    5.81    7.36\n9  A1L188              NDUFAF8      284184    3.09    2.84    3.20\n10  A1L390              PLEKHG3      26030      5.23    4.21    4.46\n# … with 6,027 morerows,and47 more variables:S21 <dbl>,\n#S20<dbl>, S30 <dbl>, S40 <dbl>, S22 <dbl>, P1 <dbl>,",
    "#SM1 <dbl>, S12 <dbl>,S5 <dbl>, S4 <dbl>, S28 <dbl>,\n#S25<dbl>, S2 <dbl>,S7 <dbl>, S29 <dbl>, P2 <dbl>,\n#SM2 <dbl>, S27 <dbl>,S39 <dbl>, S36 <dbl>, S1 <dbl>,\n#S13<dbl>, S19 <dbl>,S35 <dbl>, S34 <dbl>, P3 <dbl>,\n#SM3 <dbl>, S15 <dbl>,S18 <dbl>, S17 <dbl>, S26 <dbl>, …\nNote: HGNC symbols are added to the protein data as with RNA-seq data. To facilitate subsequent analyses that involve both mRNAs and proteins, the same column name, HGNCSymbol, is used here.\nCheck for batch effects.\nNote: It is recognized that multiplex proteomic profiling, particularly using TMT-based approaches, suffers from batch-to-batch variations (Brenes et al., 2019[href=https://www.wicell.org#bib1]). These batch effects can jeopardize comparability between runs, so it is critical to ascertain whether batch effects are present in the dataset. The following code generates a quick principal component analysis (PCA) plot from the normalized protein data where the samples are color-coded according to their TMT run batch. As shown in Figure 1[href=https://www.wicell.org#fig1]A, batch-related sample variations are evident in our proteomic dataset where the technical replicates of the pooled internal standard (P1∼5; solid circles) are dispersed yet cluster with other samples from the same runs. This result suggests the batch effects related to the TMT runs are pronounced and conceal the proteomic similarities expected between the technical replicates.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1672-Fig1.jpg\nFigure 1. Principal component analysis of the proteomic profiles before and after applying batch correction\n(A) Principal component analysis (PCA) plot of samples based on their proteomic profiles. The samples are color-coded according to tandem mass tag (TMT) run. The patient specimen samples are shown as hollowed circles. Technical replicates of the pooled internal standard sample (P1∼5) and cell line supermix (SM1∼5) are shown as solid circles and solid triangles, respectively.",
    "(B) PCA plot of the same samples after applying ComBat to mitigate the observed batch effects. The samples are color-coded and shown as in (A).\n>PRO %>%\ncolumn_to_rownames(\"ProteinAccession\") %>%\ndplyr::select(-HGNCSymbol, -EntrezID) %>%\nas.matrix %>%\nt %>%\nprcomp %>% {\n    mat = .\n    dat <- TMT %>%\n      dplyr::mutate(Type = ifelse(SampleID %in% paste0(\"SM\", 1:5), 17, ifelse(SampleID %in% paste0(\"P\", 1:5), 19, 1)))\n    autoplot(., data = TMT, colour = \"Batch\", label = F, shape = dat$Type, size = 2) +\n      theme_pubr(base_size = 10)\n  }\nOptional: For subgroup identification, it is critical to mitigate prominent batch effects (if present) to prevent them from confounding the true biological variations (Leek et al., 2010[href=https://www.wicell.org#bib13]). Several batch effect correction methods exist (Nygaard et al., 2016[href=https://www.wicell.org#bib22]). For our analysis, we use ComBat to correct for the batch effects in our proteomic data prior to subgroup identification. ComBat uses an empirical Bayes approach for batch correction which avoids over-correction in datasets with small batch sizes (Johnson et al., 2007[href=https://www.wicell.org#bib11]). The code below applies ComBat to correct for the TMT run-associated batch effects and uses PCA plot to check for post-correction sample dispersion. As shown in Figure 1[href=https://www.wicell.org#fig1]B, ComBat effectively reduces batch-associated clustering and results in comparability between the technical replicates of the pooled internal standard (P1∼5; solid circles) while leaving the technical replicates of the cell line supermix (SM1∼5; solid triangles) in a distinct cluster.\n>PRO.CB <- PRO %>%\n  dplyr::select(-HGNCSymbol, -EntrezID) %>%\n  column_to_rownames(\"ProteinAccession\") %>%\n  as.matrix %>%\n  ComBat(dat = ., batch = TMT$Batch)\n>PRO.CB[1:5, 1:5]\n                S8          S9        S14        S21        S20\nA0AV96  3.951024  3.063534  3.935030  3.408637  4.662523\nA0AVF1  3.518845  3.706400  3.208412  3.294879  3.455464\nA0AVT1  4.931518  4.804685  5.255306  5.151811  4.937922\nA0FGR8  4.458965  4.772773  5.112917  4.558818  5.171048\nA0MZ66  5.275175  4.840055  4.461929  4.784848  4.793794\n>PRO.CB %>%\n  t %>%\n  prcomp %>% {\n    mat = .\n    dat <- TMT %>%",
    "dplyr::mutate(Type = ifelse(SampleID %in% paste0(\"SM\", 1:5), 17, ifelse(SampleID %in% paste0(\"P\", 1:5), 19, 1)))\n    autoplot(., data = TMT, colour = \"Batch\", label = F, shape = dat$Type, size = 2) +\n      theme_pubr(base_size = 10)\n  }\nNote: Correction of batch effects should be limited to data on which exploratory analysis is performed. For differential analysis of data with known batch effects, the batch information can be included as a covariate in the statistical model to accommodate batch-related differences. This approach is demonstrated in the differential analysis[href=https://www.wicell.org#sec2.5] section below.\nCluster analysis of RNA-seq and proteomic data\nTiming: 1 h ∼ days (depending on the sample size and computing power)\nNon-negative matrix factorization (NMF) is used to perform cluster analysis for the identification of subgroups. To ensure the identification of robustly segregated subgroups, a consensus approach is utilized to aggregate results from multiple iterations. Running consensus NMF can become time-consuming as the sample size increases. We therefore first perform a rank survey using a few iterations to identify the optimal number of clusters (rank), then increase the number of iterations to derive robust subgroup assignments at the optimal rank. In addition, only the most variable features (mRNAs or proteins) are used in the cluster analysis.\nCreate wrapper function to perform NMF.\nNote: Since NMF will be run for four separate instances (ie. rank survey and final clustering using mRNA or protein), a wrapper function to perform NMF can be utilized to minimize code repetition. Below, a wrapper function is created to 1) select the top 25% most variably expressed mRNAs or variably abundant proteins based on coefficient of variation ranking, 2) median-center feature expression/abundance, and 3) perform NMF using a specified rank(s) and number of iterations.\n>doNMF <- function(mat, rank, nrun, save = T, save.name = NULL) {\n  if(save & is.null(save.name)) {",
    "stop(\"A file name (save.name) must be provided for the result to be saved\")\n  }\n  newmat <- apply(mat, 1, sd) %>%\n    divide_by(rowMeans(mat)) %>%\n    order(decreasing = T) %>%\n    mat[., ] %>%\n    extract(1:round(nrow(mat)*0.25), )\n  newmat <- apply(newmat, 1, median) %>%\n    sweep(newmat, 1, ., \"-\") %>%\n    as.matrix\n  res <- posneg(newmat) %>%\n    subset(., rowSums(.) > 0) %>%\n    nmf(x = ., rank = rank, nrun = nrun, seed = 123456)\n  if (save) {\n    saveRDS(res, save.name)\n  }\n  return(res)\n}\nCritical: As with most clustering approaches, a random seed is used to initialize each NMF run. To ensure reproducible results, a 6-digit random seed number must be provided and is used to initialize the random number generator when running NMF. In the above wrapper function, the number 123456 is used.\nCritical: NMF requires an input matrix of non-negative values, but standardization may result in negative values. In the above code, the posneg() function is used to split the positive and negative values, where the latter are transformed into non-negative values and added as additional features that maintain variations across samples.\nNote: Since running NMF can become very time-consuming, we recommend saving the result as soon as the computation is complete to avoid its accidental loss. The above wrapper function includes a parameter to save a copy of the result in .rds format that can be easily read back into the workspace using the function readRDS().\nPerform rank surveys by assuming a range of ranks and running NMF for 50 iterations at each possible rank. The quality measures of the result from each rank can then be evaluated (next step) to choose the optimal rank at which the samples are best segregated into clusters.\n>rank.r <- doNMF(logTPM, 2:7, 50, save.name = \"RankSurvey_mRNA.rds\")\n>rank.p <- colnames(PRO.CB) %>%\n  str_detect(., \"S\\\\d{1,2}\") %>%\n  PRO.CB[, .] %>%\n  doNMF(., 2:7, 50, save.name = \"RankSurvey_protein.rds\")",
    "Note: For the proteomic data, the technical control samples are excluded from the cluster analysis to prevent their inclusion from confounding the identification of potential subgroups from the specimens. The sample exclusion was done using line 4 of the above code chunk which selects columns based on their names containing “S” followed by a one-to-two digit number.\nNote: Considering that our cohort contains 35–36 samples with proteome and transcriptome data, respectively, we only test a range of ranks up to 7. Users with larger sample size may increase the range of ranks by changing the second parameter (“2:7” in the above code chunk) of the doNMF function.\nExamine cophenetic and silhouette coefficients to determine the optimal ranks.\nNote: The cophenetic correlation and silhouette width of a cluster result reflect how well the cluster result recapitulates the inter-sample distances in the original data and how well each sample is grouped in its cluster compared to neighboring clusters, respectively. These two coefficients from the consensus NMF at each rank tested can be evaluated to determine the optimal rank at which samples fall into distinct clusters. The code below plots the cophenetic and silhouette coefficients at the rank of 2–7 for mRNA and protein -based rank surveys. As shown in Figures 2[href=https://www.wicell.org#fig2]A and 2B, the consensus cophenetic correlation and silhouette coefficients peak at the rank of 2 or 4 in both mRNA and protein -based analyses suggesting 2 or 4 is likely the optimal rank for NMF analysis using either data type.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1672-Fig2.jpg\nFigure 2. Rank surveys of consensus non-negative matrix factorization on mRNA or protein measurements\n(A) Cophenetic correlation and silhouette coefficients (y-axis) at the rank 2–7 (x-axis) from consensus non-negative matrix factorization (NMF) using the top 25% variably expressed mRNAs.",
    "(B) Cophenetic correlation and silhouette coefficients (y-axis) at the rank 2–7 (x-axis) from consensus NMF using the top 25% variably abundant proteins.\n>rank.r$measures %>% {\n  dat = .\n  c <- ggline(dat, x = \"rank\", y = \"cophenetic\", xlab = \"Rank\", ylab = \"Cophenetic coefficient\", ggtheme = theme_pubr(base_size = 10))\n  s <- ggline(dat, x = \"rank\", y = \"silhouette.consensus\", xlab = \"Rank\", ylab = \"Silhouette coefficient\", ggtheme = theme_pubr(base_size = 10))\n  ggarrange(c, s, ncol = 2)\n}\n>rank.p$measures %>% {\n  dat = .\n  c <- ggline(dat, x = \"rank\", y = \"cophenetic\", xlab = \"Rank\", ylab = \"Cophenetic coefficient\", ggtheme = theme_pubr(base_size = 10))\n  s <- ggline(dat, x = \"rank\", y = \"silhouette.consensus\", xlab = \"Rank\", ylab = \"Silhouette coefficient\", ggtheme = theme_pubr(base_size = 10))\n  ggarrange(c, s, ncol = 2)\n}\nNote: While the cophenetic correlation and silhouette coefficients are helpful for choosing the optimal rank, the ultimate decision of the optimal rank should also take into consideration the research question and the cohort examined. For our analysis, while the coefficients appear the highest at the rank of 2, we had performed auxiliary NMF analyses which indicated the cluster solutions at the rank of 4 align more with clusters of biological differences. We therefore determined the rank of 4 to be the optimal rank.\nPerform NMF at the optimal ranks to obtain subgroup assignments.",
    "Note: Since one of the goals of this protocol is to draw comparisons between paired transcriptome and proteome, only the samples with both RNA and protein information are used to determine the subgroup assignments and for further analyses. To determine the subgroup assignment of each sample, the consensus cluster solution at the rank of 4 is obtained by running consensus NMF for 200 iterations using either mRNA or protein data. Hierarchical cluster analysis is then performed using the resultant consensus matrix to obtain the subgroup assignments.\n>samp <- intersect(colnames(logTPM), colnames(PRO.CB))\n>nmf.r <- logTPM[, samp] %>%\ndoNMF(., 4, 200, save.name = \"NMF_mRNA.rds\")\n>nmf.p <- PRO.CB[, samp] %>%\ndoNMF(., 4, 200, save.name = \"NMF_protein.rds\")\n>assignment.r <- cutree(hclust(as.dist(1-nmf.r@consensus)), 4)\n>assignment.p <- cutree(hclust(as.dist(1-nmf.p@consensus)), 4)\nCompare mRNA and protein -derived subgroup assignments.\n>rbind(mRNA = assignment.r,Protein = assignment.p)\n          S1  S2  S3  S4  S5  S6  S7  S8  S9  S10  S11  S12  S13  S14  S15\nmRNA       1  1  2  2  3  3  3  3  2    3    1    1    1    3    1\nProtein   1  1  2  2  3    3  3  3  2    3    1    1    2    3    2\n        S16  S17  S19  S21  S22  S23  S24  S25  S26  S27  S28  S29  S30\nmRNA       4   2   3     2     1     3     3     4     2     3     2     2    4\nProtein   4   3     2     2     1     3     1     4     2     3     2     2    2\n        S31  S32  S33  S37  S38  S39  S40\nmRNA       3     1     2     1     2     4     4\nProtein   3     2     2     1     2     4     4\nNote: Comparison of subgroup assignments from different analyses can be done using various approaches. The simplest and most intuitive is to tabulate the subgroup assignments for visual comparison as shown above. Evidently, the subgroup assignments derived from mRNA or protein -based clustering are highly concordant.",
    "Optional: The NMF-derived subgroup assignments can be superimposed onto PCA plot to provide a visualization of the spatial separation between samples of the different subgroups. In the below code, PCA is performed using log-transformed TPM or batch-corrected abundance from mRNAs or proteins, respectively, and plotted with the samples color-coded according to their mRNA or protein -derived subgroup assignments. As shown in Figure 3[href=https://www.wicell.org#fig3]A and 3B, PCA plots using the first two principal components largely recapitulate NMF-derived subgroups.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1672-Fig3.jpg\nFigure 3. Consensus NMF-derived subgroups illustrated using PCA plots\n(A and B) Analysis and visualization strategies adapted from Yang et al. (Yang et al., 2021[href=https://www.wicell.org#bib36]). (A) PCA plot using all expressed mRNAs. The samples are color-coded according to their NMF-derived subgroups. (B) PCA plot using all proteins. The samples are color-coded according to their NMF-derived subgroups.\n>assignment.r[colnames(logTPM)] %>%\n  na.omit %>%\n  as.data.frame %>%\n  set_colnames(\"Subgroup\") %>%\n  dplyr::mutate(Subgroup = as.character(Subgroup)) %>% {\n    sg = .\n    logTPM[, rownames(sg)] %>%\n      t %>%\n      prcomp %>%\n      autoplot(., data = sg, colour = \"Subgroup\", shape = 19, label = F) +\n      scale_color_brewer(palette = \"Set1\") +\n      theme_pubr(base_size = 12)\n  }\n>assignment.p[colnames(PRO.CB)] %>%\n  na.omit %>%\n  as.data.frame %>%\n  set_colnames(\"Subgroup\") %>%\n  dplyr::mutate(Subgroup = as.character(Subgroup)) %>% {\n    sg = .\n    PRO.CB[, rownames(sg)] %>%\n      t %>%\n      prcomp %>%\n      autoplot(., data = sg, colour = \"Subgroup\", shape = 19, label = F) +\n      scale_color_brewer(palette = \"Set1\") +\n      theme_pubr(base_size = 12)\n  }\nComparison of mRNA and protein variation\nTiming:  < 30 min\nGiven availability of paired transcriptome and proteome data, it can be informative to compare the transcriptome and proteome profiles of each sample, especially if the correlation between transcriptome and proteome is not known for the particular disease/condition of interest. Here, correlation analysis is used to compare the correlation between individual mRNAs and proteins in each specimen and across the cohort.",
    "Identify genes with paired mRNA and protein data.\nNote: As mentioned earlier, HGNC gene symbols are used as the identifiers when cross-referencing RNA and protein. However, Ensembl gene IDs and protein accessions, the primary identifiers used in RNA and protein datasets respectively, should be preserved to prevent unnecessary loss of data.\n>genes <- intersect(COUNT$HGNCSymbol, PRO$HGNCSymbol) %>%\n  extract(!is.na(.))\n>paired.TPM <- TPM %>%\n  filter(., HGNCSymbol %in% genes) %>%\n  dplyr::select(HGNCSymbol, any_of(samp)) %>%\n  group_by(HGNCSymbol) %>%\n  summarise_all(median) %>%\n  ungroup %>%\n  column_to_rownames(\"HGNCSymbol\") %>%\n  add(1) %>%\n  log2\n>paired.PRO <- PRO[,c(\"ProteinAccession\", \"HGNCSymbol\")] %>%\n  filter(., HGNCSymbol %in% genes) %>%\n  left_join(., PRO.CB %>% as.data.frame %>% rownames_to_column(\"ProteinAccession\"),\n        by = \"ProteinAccession\") %>%\n  dplyr::select(HGNCSymbol, any_of(samp)) %>%\n  group_by(HGNCSymbol) %>%\n  summarise_all(median) %>%\n  ungroup %>%\n  column_to_rownames(\"HGNCSymbol\")\nCompute mRNA-protein correlation for each sample.\nNote: The correlation between paired transcriptome and proteome can be computed for each sample to evaluate how well the transcriptome and proteome landscapes are correlated with respect to mRNA expression and protein abundance in each sample on a global scale. The correlations can then be plotted (as shown in Figure 4[href=https://www.wicell.org#fig4]A) for visual inspection. The code below computes and plots the mRNA-protein correlation for each sample.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1672-Fig4.jpg\nFigure 4. Correlations between mRNA expression and protein abundance\n(A and B) Analysis and visualization strategies adapted from Yang et al. (2021)[href=https://www.wicell.org#bib36]. (A) Sample-wise mRNA-protein correlation computed as Spearman’s Rho (y-axis). Samples are ordered along the x-axis based on increasing correlation. (B) The distribution of gene-wise mRNA-protein correlations computed as Spearman’s Rho (x-axis). A histogram of 20 bins is shown with height of each bar proportional to the number of genes in each bin. The median correlation is depicted by a red vertical line.\n>cor(paired.TPM, paired.PRO, method = \"spearman\") %>%\n  as.data.frame %>%\n  set_colnames(\"Rho\") %>%\n  rownames_to_column(\"Sample\") %>%",
    "ggdotchart(., x = \"Sample\", y = \"Rho\", ggtheme = theme_pubr(base_size = 10), add = \"segment\", ylim = c(0, 1), ylab = \"mRNA-protein correlation (rho)\")\nCompute correlation between mRNA and protein variation for each gene to evaluate how well mRNA and protein variations are correlated in the sample cohort.\n>cor(t(paired.TPM), t(paired.PRO), method = \"spearman\") %>%\n  diag %>%\n  gghistogram(., bins = 20, theme = theme_pubr(base_size = 10), fill = \"gray\",\n        xlab = \"mRNA-protein correlation (rho)\",\n        ylab = \"Number of genes\")\nNote: As shown in Figure 4[href=https://www.wicell.org#fig4]B, based on the list of genes with paired mRNA and protein information, diverse correlations between mRNA and protein variations are evident in our cohort specimens.\nDifferential analysis\nTiming:  < 30 min\nDifferential analysis of gene expression or protein abundance can be performed using the same analysis workflow, with slight differences in their input structures. Here, we illustrate our workflow for differential analysis of gene expression and protein abundance between the four subgroups identified earlier. For simplicity, only the mRNA-derived subgroup assignments are used. Differential analysis through the limma r package uses linear models and an empirical Bayes approach that allow analysis of data as a whole and permit inclusion of covariates (e.g., batch effects) that may confound with analysis objectives in the model design (Ritchie et al., 2015[href=https://www.wicell.org#bib24]). In addition to differential analysis, a gene set test is performed to showcase added functionalities of the limma package in identifying biological differences from molecular comparisons.",
    "DGEList objects from the edgeR package (Robinson et al., 2010[href=https://www.wicell.org#bib26]) and ExpressionSet objects from the Biobase package (Huber et al., 2015[href=https://www.wicell.org#bib10]) are two input formats accepted by limma. Both DGEList and ExpressionSet objects are of the S4 class that are designed to store expression, phenotype and feature data. For our purpose of analyzing transcriptome and proteome data, the transcriptome data are converted into a DGEList object while the proteome data are converted into an ExpressionSet object for analysis using limma.\nNote: The utility of a DGEList class object is to facilitate normalization and transformation of count data and is not applicable to the proteomic data showcased in this protocol. Users working with microarray data may wish to proceed with an ExpressionSet object followed by appropriate normalization.\nConstruct a DGEList object from the RNA-seq data.\nNote: As mentioned earlier, the raw counts are used in the differential analysis, as compared to the TPMs in the cluster analyses. Since differential analysis compares gene-level measurements between groups, gene-length normalization is irrelevant. Instead, raw counts can be normalized to scale for library size and composition differences using the trimmed mean of M values (TMM) method from edgeR (Robinson and Oshlack, 2010[href=https://www.wicell.org#bib25]).\n>dge <- COUNT %>% {\n  dat = .\n  p <- assignment.r %>%\n    as.data.frame %>%\n    set_colnames(\"Subgroup\") %>%\n    dplyr::mutate(Subgroup = paste0(\"Subgroup\", Subgroup))\n  m <- dat %>%\n    dplyr::select(EnsemblGeneID, one_of(rownames(p))) %>%\n    column_to_rownames(\"EnsemblGeneID\") %>%\n    as.matrix\n  f <- dat %>%\n    dplyr::select(-matches(\"S\\\\d{1,2}\")) %>%\n    column_to_rownames(\"EnsemblGeneID\")\n  res <- DGEList(counts = m,\n                  samples = p,\n                  genes = f)\n  fkeep <- rowSums(cpm(res) > 1) >= round(nrow(p)∗0.1)\n  res <- res[fkeep, keep.lib.sizes = F] %>%\n    calcNormFactors(., method = \"TMM\")\n  res\n}\n>dim(dge)\n[1] 25373 35",
    "Note: As done in the preparatory steps of cluster analysis, noise-level RNAs are removed from the constructed DGEList object. Here, only RNAs with expression above 1 count-per-million (CPM) in at least 10% of the cohort are retained for further analyses.\nNote: The DGEList is analogous to a list of three objects: a gene matrix (counts), a feature annotation dataframe (genes) and a sample annotation dataframe (samples).\nConstruct an ExpressionSet object from the proteomic data.\nNote: For differential abundance analysis of proteomic data, the normalized protein abundance values are used. To account for the TMT-associated batch effects in the linear modeling, the batch covariate (eg. TMT run) is added to the sample annotations.\n>eset <- PRO %>% {\n  dat = .\n  p <- assignment.r %>%\n    as.data.frame %>%\n    set_colnames(\"Subgroup\") %>%\n    merge(., TMT, by.x = \"row.names\", by.y = \"SampleID\") %>%\n    column_to_rownames(\"Row.names\") %>%\n    dplyr::mutate(Subgroup = paste0(\"Subgroup\", Subgroup)) %>%\n    extract(samp,) %>%\n    new(\"AnnotatedDataFrame\", .)\n  m <- dat %>%\n    dplyr::select(ProteinAccession, one_of(samp)) %>%\n    column_to_rownames(\"ProteinAccession\") %>%\n    as.matrix\n  f <- dat %>%\n    dplyr::select(ProteinAccession, HGNCSymbol, EntrezID) %>%\n    column_to_rownames(\"ProteinAccession\") %>%\n    new(\"AnnotatedDataFrame\", .)\n  ExpressionSet(assayData = m,\n          phenoData = p,\n          featureData = f)\n}\n>eset\nExpressionSet (storageMode: lockedEnvironment)\nassayData: 6037 features, 35 samples\n  element names: exprs\nprotocolData: none\nphenoData\n  sampleNames: S1 S2 … S40 (35 total)\n  varLabels: Subgroup Batch\n  varMetadata: labelDescription\nfeatureData\n  featureNames: A0AV96 A0AVF1 … Q9Y6Y8 (6037 total)\n  fvarLabels: HGNCSymbol EntrezID\n  fvarMetadata: labelDescription\nexperimentData: use 'experimentData(object)'\nAnnotation:\nNote: Similar to a DGEList, the ExpressionSet contains a protein abundance matrix (assayData), a feature annotation dataframe (featureData) and a sample annotation dataframe (phenoData).\nCreate a wrapper function to perform limma.",
    "Note: Differential analysis using limma involves several steps that are mostly identical regardless of the input. As such, a wrapper function can be created to reduce code repetition, as previously done for performing NMF. In addition to differential analysis capabilities, limma is equipped with a function camera() that performs a competitive gene set test against any reference gene panel of interest (Wu and Smyth, 2012[href=https://www.wicell.org#bib35]). This added capability can be leveraged to develop a streamlined workflow combining differential analysis and gene set tests.\n>doLimma <- function(dat, type, model.m, contr.m, gs = NULL)\n  {\n  if (type == \"rna\") {\n    v <- voom(dat, design = model.m)\n    if (!is.null(gs)) {\n      gset <- gs %>%\n        ids2indices(., id = dat$genes$HGNCSymbol)\n    }\n  } else if (type == \"protein\") {\n    v <- dat\n    if (!is.null(gs)) {\n      gset <- gs %>%\n        ids2indices(., id = fData(dat)$HGNCSymbol)\n    }\n  } else {\n    stop(\"Data type must be specified.\")\n  }\n  vfit <- lmFit(v, model.m) %>%\n    contrasts.fit(., contrasts = contr.m)\n  efit <- eBayes(vfit)\n  if (!is.null(gs)) {\n    groups = colnames(contr.m)\n    cam <- groups %>%\n      setNames(.,.) %>%\n      as.list %>%\n      lapply(., function(x) {\n        camera(v, gset, model.m, contrast = contr.m[,x])\n      })\n    return(list(v=v, efit = efit, camera = cam))\n  } else {\n    list(v = v, efit = efit)\n  }\n}\nNote: Since the transcriptome data was only subjected to normalization, the wrapper function transforms the transcriptome data using voom prior to performing the analysis. The proteome data, on the other hand, was subjected to transformation during variance-stabilizing normalization and no further processing is required.",
    "Note: A model matrix and a contrast matrix are required to perform linear modeling and to specify group comparisons. These matrices are left for the users to supply to the wrapper function to allow flexibility to add or modify as appropriate. Examples of how these matrices can be constructed are shown in steps 19 and 20.\nNote: The above wrapper function outputs a list containing the input (v), the result of fitted gene-wise linear model as a MArrayLM object (efit), and a gene set test result if applicable (camera).\nImport reference gene sets for gene set testing.\n>Hallmark <- getGmt(\"h.all.v7.4.symbols.gmt\") %>%\ngeneIds\n>length(Hallmark)\n[1] 50\n>Hallmark$HALLMARK_PANCREAS_BETA_CELLS\n[1]   \"PAX6\"      \"NEUROD1\"  \"ISL1\"    \"NKX2-2\"   \"PCSK1\"\n[6]  \"NKX6-1\"    \"SLC2A2\"   \"SEC11A\" \"DCX\"      \"SPCS1\"\n[11]\"FOXA2\"     \"GCK\"       \"MAFB\"    \"INS\"       \"PDX1\"\n[16]\"ABCC8\"     \"IAPP\"       \"SRP9\"     \"NEUROG3\"  \"FOXO1\"\n[21]\"AKT3\"    \"GCG\"       \"DPP4\"     \"PAX4\"    \"SYT13\"\n[26]\"SCGN\"    \"HNF1A\"     \"STXBP1\"  \"CHGA\"     \"VDR\"\n[31]\"PCSK2\"     \"INSM1\"    \"SST\"      \"ELP4\"    \"SRPRB\"\n[36]\"PAK3\"     \"G6PC2\"     \"PKLR\"     \"LMO2\"    \"SRP14\"\nNote: For illustrative purpose, here we only use the Hallmark gene sets from MSigDB, which consist of 50 curated gene sets with cancer relevance (Liberzon et al., 2015[href=https://www.wicell.org#bib16]) downloaded from www.gsea-msigdb.org/gsea/downloads.jsp[href=http://www.gsea-msigdb.org/gsea/downloads.jsp] - msigdb and saved to the working directory. This same code is applicable to any other gene sets from MSigDB.\nNote: In theory, any reference gene panels of the same data structure (a list of named objects, each containing a vector of genes) can be used in placed of the “Hallmark” gene set generated from the above code.\nCritical: The type of gene identifiers used in the reference gene panels must also be present in the data to be analyzed. In our example, our transcriptome and proteome data contain HGNC symbols, thus the MSigDB gene sets consisting of HGNC symbols were used.\nPerform differential analysis using transcriptomic data.",
    "Note: Here, differential expression analysis is performed to compare RNA expression between each subgroup to the average of the other subgroups. Since one subgroup was very different from the others (Subgroup 4, purple in Figure 3[href=https://www.wicell.org#fig3]), it was not included in the analysis of the other three subgroups as reflected in the contrast matrix design.\n>lm.r <- dge %>% {\n  dat = .\n  model.m <- model.matrix(∼0 + factor(Subgroup), dat$samples) %>%\n    set_colnames(paste0(\"Subgroup\", 1:4))\n    contr.m <- makeContrasts(Subgroup1 = Subgroup1 - (Subgroup2 + Subgroup3)/2,\n                  Subgroup2 = Subgroup2 - (Subgroup1 + Subgroup3)/2,\n                  Subgroup3 = Subgroup3 - (Subgroup1 + Subgroup2)/2,\n                  Subgroup4 = Subgroup4 - (Subgroup1 + Subgroup2 + Subgroup3)/3,\n                  levels = colnames(model.m))\n  doLimma(dat, \"rna\", model.m = model.m, contr.m = contr.m, Hallmark)\n}\nNote: The model (model.m) and contrast (contr.m) matrices can be changed to suit users’ needs, depending on the experimental context and analysis objectives, such as if a different comparison is desired. A model matrix can be constructed using the model.matrix function where a formula and phenotype data should be supplied. In the above code chunk, the sample annotation dataframe from the RNA DGEList is used as the phenotype data and the “Subgroup” column from it used to define the groups of interest. A contrast matrix specifies the desired comparisons and can be constructed using the makeContrasts function. In the above example, four comparisons are made, one for each evaluation between a subgroup (Subgroup1∼4 preceding the minus sign) and others (Subgroups following the minus sign). Users interested in other comparisons may alter the formula accordingly. For instance, to compare Subgroup 4 to all other subgroups, one can use: “Subgroup4 = Subgroup4 – (Subgroup1 + Subgroup2 + Subgroup3)/3”.\nPerform differential analysis using proteomic data.\n>lm.p <- eset %>% {\n  dat = .\n  model.m <- model.matrix(∼0 + factor(Subgroup) + factor(Batch),\n                              pData(dat)) %>%\n    set_colnames(c(paste0(\"Subgroup\", 1:4), paste0(\"TMT\", 2:5)))",
    "contr.m <- makeContrasts(Subgroup1 = Subgroup1 - (Subgroup2 + Subgroup3)/2,\n                  Subgroup2 = Subgroup2 - (Subgroup1 + Subgroup3)/2,\n                  Subgroup3 = Subgroup3 - (Subgroup1 + Subgroup2)/2,\n                  Subgroup4 = Subgroup4 - (Subgroup1 + Subgroup2 + Subgroup3)/3,\n                  levels = colnames(model.m))\n  doLimma(dat, \"protein\", model.m = model.m, contr.m = contr.m, Hallmark)\n}\nNote: The code for running differential protein abundance analysis is nearly identical to that used for differential mRNA expression analysis, with the addition of the batch covariate (TMT run grouping) in the design matrix to account for the batch effects associated with the different TMT runs. In experiments where confounding variables are known, users may replace the “Batch” covariate or add to the formula to account for more than one covariate that can adversely impact the analysis.\nExtract differential analysis results.\nNote: Differential mRNA expression or protein abundance analysis results can be easily extracted using the topTable() function on the MArrayLM object outputted by limma. A set of significantly differential genes for each subgroup is derived by imposing expression/abundance and/or significance thresholds. The code below illustrates how to extract the significantly differential genes for each subgroup from the transcriptomic and proteomic data. As in our previous work (Yang et al., 2021[href=https://www.wicell.org#bib36]), a significance threshold is set at adjusted p-value < 0.05, and log-fold change thresholds of 2 and 1 are set for mRNA and protein, respectively.\n>deg <- paste0(\"Subgroup\", 1:4) %>%\n  setNames(., .) %>%\n  as.list %>%\n  lapply(., function(x) topTable(lm.r$efit, coef = x, p.value = 0.05, lfc = 2, n = Inf))\n>dap <- paste0(\"Subgroup\", 1:4) %>%\n  setNames(., .) %>%\n  as.list %>%\n  lapply(., function(x) topTable(lm.p$efit, coef = x, p.value = 0.05, lfc = 1, n = Inf))",
    "Note: The output from the above code is a Iist of data frames, each containing significantly differential genes for a subgroup from the transcriptomic (deg) or proteomic (dap) data. The number of significantly differential genes varies between subgroups and data as shown below.\n>sapply(deg, nrow)\nSubgroup1  Subgroup2  Subgroup3  Subgroup4\n      332         527         905        1124\n>sapply(dap, nrow)\nSubgroup1  Subgroup2  Subgroup3  Subgroup4\n        34          75         203         112\nNote: The significance threshold here is imposed on the adjusted p-value, after correction for multiple comparisons. The default p-value adjustment method is the Benjamini-Hochberg procedure.\nNote: To obtain the entirety of the differential analysis results, one can drop the p.value and lfc parameter.\nNote: The gene set test results are structured as data frames with each row corresponding to a gene set and test statistics in columns. Below is a demonstration of the gene set test result from one of the subgroups.\n>head(lm.r$camera$Subgroup4)\n                                          NGenes    Direction\nHALLMARK_E2F_TARGETS                      197            Up\nHALLMARK_G2M_CHECKPOINT                  190            Up\nHALLMARK_MYC_TARGETS_V1                  195            Up\nHALLMARK_INTERFERON_GAMMA_RESPONSE    193          Down\nHALLMARK_MYC_TARGETS_V2                  58            Up\nHALLMARK_INTERFERON_ALPHA_RESPONSE    94          Down\n                                                      PValue              FDR\nHALLMARK_E2F_TARGETS                      1.979853e-47  9.899264e-46\nHALLMARK_G2M_CHECKPOINT                  2.665669e-33  6.664172e-32\nHALLMARK_MYC_TARGETS_V1                  2.409791e-17  4.016318e-16\nHALLMARK_INTERFERON_GAMMA_RESPONSE    1.850506e-07  2.313132e-06\nHALLMARK_MYC_TARGETS_V2                  2.334552e-07  2.334552e-06\nHALLMARK_INTERFERON_ALPHA_RESPONSE    5.432535e-07  4.527113e-06"
  ],
  "subjectAreas": [
    "Rnaseq",
    "Bioinformatics",
    "Cancer",
    "Proteomics",
    "Gene Expression"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}