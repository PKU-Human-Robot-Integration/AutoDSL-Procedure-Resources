{
  "id": 4184,
  "origin_website": "Cell",
  "title": "Annotating cell types in human single-cell RNA-seq data with CellO",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nInstall the CellO package and its dependencies using Anaconda\nTiming: 10 min\nInstall CellO and its dependencies\nCreate an isolated virtual environment using Anaconda. To do so, run the following commands in your terminal window, hitting enter after each line:\nconda activate\nconda create -y -n cello_env python=3.7 graphviz\nconda activate cello_env\nAt the command line within the terminal window, run the following commands:\npip install pygraphviz leidenalg scanpy cello-classify\nIf you wish to implement this protocol using the provided Jupyter notebook, then you will need to install Jupyter as well. To do so, run the following command:\npip install jupyter\nVerify that CellO is installed correctly\nAt the command line within the terminal window, run the command:\npython This will start the Python shell. Once running, run the following command:\nimport cello Once finished, you can exit the Python shell by typing Ctrl+D.\nOptional: Download and launch the Jupyter notebook that implements this protocol\nDownload the CellO tutorial Jupyter notebook from GitHub. To do so, at the command line, enter the following command:\ncurl -O https://raw.githubusercontent.com/deweylab/CellO/master/tutorial/cello_tutorial.ipynb[href=https://raw.githubusercontent.com/deweylab/CellO/master/tutorial/cello_tutorial.ipynb]\nLaunch the Jupyter notebook. To do so, run the following command:\njupyter notebook cello_tutorial.ipynb\nAfter entering this command, the Jupyter notebook will open automatically in your computer’s default web browser.\nLoad the expression matrix into Python and preprocess the data\nTiming: 5 min\nImport necessary Python packages\nRun the following commands in the Python shell to import the Python packages that we will need for this protocol:\nimport cello\nimport os\nimport pandas as pd\nimport scanpy as sc\nfrom anndata import AnnData\nLoad the single-cell expression matrix using Pandas and Scanpy",
    "We will load the expression matrix into a Pandas dataframe. From this dataframe, we will instantiate an AnnData object. AnnData objects represent annotated single-cell expression matrices and are used by the Scanpy library. To perform these steps, run the following Python commands:\ndf = pd.read_csv(\n  \"GSM3516673_MSK_LX682_NORMAL_dense.csv.gz\",\n  index_col=0 )\nadata = AnnData(df)\nNote: AnnData objects use the rows of the data matrix to store the observations (i.e., cells) and the columns to store the features (i.e., genes). Thus, in this protocol, the expression matrix is a cell-by-gene matrix rather than a gene-by-cell matrix.\nNormalize and cluster the data\nVariant 1: Normalize and cluster the data explicitly using Scanpy.\nNormalize expression data into units of log transcripts per million (TPM). This can be accomplished with the following calls to Scanpy: sc.pp.normalize_total(adata, target_sum=1e6) sc.pp.log1p(adata)\nAnnotate the 10,000 most highly expressed genes for performing clustering. Note, that CellO will operate on all of the genes. These most highly expressed genes will be used only for clustering and visualization. sc.pp.highly_variable_genes(adata, n_top_genes=10000)\nPerform principal component analysis (PCA). To cluster the data in Scanpy, we first compute the first 50 principal components of each sample using PCA. This can be performed with Scanpy using the following command: sc.pp.pca( adata, n_comps=50, use_highly_variable=True )\nCompute nearest-neighbors graph. Before we run Leiden, we must compute the nearest neighbors graph on the cells. We do so by finding the nearest 15 cells to each cell using the Euclidean distance between the first 50 principal components. This can be performed with Scanpy using the following command: sc.pp.neighbors(adata, n_neighbors=15)\nCluster the cells with Leiden. This can be performed with Scanpy using the following command: sc.tl.leiden(adata, resolution=2.0)",
    "Variant 2: Using CellO’s wrapper function. CellO provides a wrapper function for normalizing and clustering a UMI counts matrix provided as an AnnData object by wrapping the steps in Variant 1 above: cello.normalize_and_cluster(   adata,   n_pca_components=50,   n_neighbors=15,   n_top_genes=10000,   cluster_res=2.0 )\nCritical: CellO requires that the input expression matrix is normalized using estimated transcripts per million (TPM) and then transformed via log(TPM+1). For UMI count data, TPM are equivalent to counts per million (CPM). CellO’s normalize_and_cluster wrapper function performs this normalization for UMI data specifically. For non-UMI count data, the steps required to derive log(TPM+1) will depend on the units of expression. For a discussion on TPM and its relationships to other units of expression, such as reads per kilobase per million mapped reads (RPKM), see Li et al. (2010)[href=https://www.wicell.org#bib6].\nCritical: CellO must operate on dense expression profiles resembling those produced by bulk RNA-seq assays. To run CellO on single-cell data, we cluster the single cells and aggregate the sparse expression profiles of the cells within each cluster to form a dense expression profile. Furthermore, because CellO operates on cell clusters, it is important that the cells are not under-clustered. The Leiden algorithm’s resolution parameter controls the granularity of clusters. To increase cluster granularity, the resolution parameter should be increased. In this protocol, we use a resolution of 2.0, which is higher than the default value provided by Scanpy. We set this parameter higher in order to avoid under-clustering. On new data, we encourage the user to examine the quality of the clusters via dimension-reduction scatterplots, such as UMAP plots (see Step 11), in order to detect under clustering.\nOptional: Use pre-computed, custom clusters",
    "If one has loaded, or computed, a Python list storing each cell’s cluster assignment, where the ith element of the list is the cluster id corresponding to the ith cell’s cluster, then one can store these clusters within the AnnData object, adata, in order to be annotated by CellO. For example, if this Python list is called ‘clusts’, then one can run the Python statement: adata.obs['clusters'] = clusts\nThis statement will create a new column in the adata.obs dataframe called “clusters” with the content of the clusts list.\nCritical: The list, clusts, must store cluster ids for cells that are ordered in the same order as the rows of adata.obs.\nClassify cells with CellO\nTiming: 45 min\nSpecify CellO’s resource location\nWe specify the location of CellO’s resources database. CellO requires a database storing pre-trained models as well as training data for training new models. These data are stored in a directory named “resources”. If this directory is not present in the target location, CellO will download it automatically and store it at the target location. We specify this location as follows:\ncello_resource_loc = os.getcwd()\nCritical: CellO’s resources database requires approximately 5GB of disk space.\nRun CellO\nVariant 1: Training a new model. CellO will examine the input gene expression matrix and determine whether the genes match those expected by one of CellO’s pre-trained models. If the genes expected by the pre-trained models are not a subset of the genes in the provided expression matrix, CellO will train a new model using CellO’s built-in training set. This model can be saved and re-used for classifying future datasets that assay the expression of these same genes.\nSpecify the file prefix for CellO’s newly trained model. The file storing the model will be named <prefix>.model.dill:\nmodel_prefix = 'GSM3516673_MSK_LX682_NORMAL′",
    "Run CellO using the following command:\ncello.scanpy_cello(\n  adata,\n  clust_key='leiden',\n  rsrc_loc=cello_resource_loc,\n  out_prefix=model_prefix,\n  log_dir=os.getcwd()\n) If not found, CellO will download the resources and place them in cello_resource_loc. Also, if using custom clustering, the clust_key parameter should be set to the name of the column in adata.obs that stores each cell’s cluster.\nNote: CellO is packaged with pre-trained models that were trained using CellO’s built-in training set. Each pre-trained model was trained using a different subset of genes. CellO will check whether the input expression matrix is comprised of expression data for the same set of genes as those on which a pre-trained model was trained. If no matching model can be found, then a new model will need to be trained using the built-in training set on the subset of genes shared by the training set and the given gene expression matrix. In Step 9.a above, we train a new model according to the genes in the current gene expression matrix. During training, CellO will output a message detailing how many genes it was able to match with the training set. In the data analyzed in this protocol, the message should read: Of 18804 genes in the input file, 15754 were found in the training set of 58243 genes. To view the specific genes that the program was unable to match, CellO outputs a file called “genes_absent_from_training_set.tsv” that stores the names of the unmatched genes.\nVariant 2: Using an existing model. In Step 9.a, we describe how to run CellO using a newly trained model that is trained on the gene set provided in the expression matrix. If a model has already been trained using an appropriate gene set, we can run CellO using the existing model stored in <prefix>.model.dill as follows:\ncello.scanpy_cello(\n  adata,\n  clust_key='leiden',\n  rsrc_loc=cello_resource_loc,\n  model_file=f'{model_prefix}.model.dill'\n)",
    "If using custom clustering, the clust_key parameter should be set to the name of the column in adata.obs that stores each cell’s cluster.\nNote: Step 9 may produce a warning with text similar to the following: “UserWarning: Trying to unpickle estimator LogisticRegression from version 0.22.2.post1 when using version 0.24.1. This might lead to breaking code or invalid results. Use at your own risk.” This warning is issued by scikit-learn, the Python library used to train CellO’s models. As of scikit-learn version 0.24.1, this warning can be safely ignored.\nVisualize cell type annotations overlaid on UMAP plot\nTiming: 1 min\nRun UMAP\nVariant 1: We will run UMAP (McInnes et al., 2018[href=https://www.wicell.org#bib8]) using Scanpy with the following command:\nsc.tl.umap(adata)\nVariant 2: If one has pre-computed UMAP coordinates stored in a matrix (e.g., a multi-dimensional numpy array), then one can easily load these coordinates into the adata AnnData object. For example, if the UMAP coordinates are stored in an Nx2 dimensional matrix named ‘umap_mtx’, where N is the number of cells in the adata object, then one can load them into the AnnData object as follows:\nadata.obsm['X_umap'] = umap_mtx\nCritical: In Step 10.b., the rows of the matrix, umap_mtx, must correspond to the rows of adata.obs.\nCreate UMAP plot with cells colored by cluster\nVariant 1: Use the clusters computed via the Leiden algorithm:\nsc.pl.umap(adata, color='leiden', title='Clusters') This will produce the scatterplot shown in Figure 2[href=https://www.wicell.org#fig2]A.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/945-Fig2.jpg\nFigure 2. Output UMAP plots\nUMAP plots with cells annotated by (A) cluster, (B) most-specific cell type as annotated by CellO, (C) the probability that each cell is a T cell, and (D) the binary decisions made by CellO regarding whether each cell is either a T cell or not.",
    "Variant 2: If one followed the optional Step 7 and is using custom, pre-computed clusters rather than those produced by Leiden, then one must set the ‘color’ parameter to be the name of the column in the adata.obs dataframe that stores each cell’s cluster assignment. For example, in Step 7, the column name storing the custom clustering is “clusters” and thus, the command to create the UMAP plot would be:\nsc.pl.umap(\n    adata,\n    color='clusters',\n    title='Clusters'\n)\nCreate UMAP plot with cells colored by most-specific predicted cell type\nWithin the dataframe, adata.obs, CellO has populated a new column, named \"Most specific cell type\", that stores the deepest cell type within the Cell Ontology that each cell is annotated with. We will color each cell in the UMAP plot using this column as follows:\nsc.pl.umap(adata, color='Most specific cell type') This will produce the scatterplot shown in Figure 2[href=https://www.wicell.org#fig2]B.\nCreate UMAP plot with cells colored according their probability of being T cells\nThe probability that each cell is of each cell type are stored in columns within adata.obs that follow the pattern “<cell type> (probability)”. For example, the probability that each cell is a T cell is stored in the column “T cell (probability)”. To color each cell according to the probability that each is a T cell, run the command:\nsc.pl.umap(adata, color='T cell (probability)', vmin=0.0, vmax=1.0) This will produce the scatterplot shown in Figure 2[href=https://www.wicell.org#fig2]C.\nCreate UMAP plot with cells colored according whether they are classified as being T cells.\nThe binary classification that each cell is of each cell type is stored in columns within adata.obs that follow the pattern “<cell type> (binary)”. To color each cell according to whether each cell is predicted to be a T cell, run the command:",
    "sc.pl.umap(adata, color='T cell (binary)') This will produce the scatterplot shown in Figure 2[href=https://www.wicell.org#fig2]D.\nVisualize cell type probabilities overlaid on Cell Ontology graph\nTiming: 1 min\nVisualize cell type probabilities assigned to a specific cluster overlaid on the Cell Ontology graph.\nCellO’s outputs are hierarchical. That is, CellO assigns each cell a probability for each cell type within a subgraph of the Cell Ontology. For a given cluster, one can visualize these probabilities overlaid on the ontology graph. In the command below, we will plot the probabilities assigned to Cluster 21 (Figure 2[href=https://www.wicell.org#fig2]A). We will restrict our plot to include only cell types for which CellO assigned a probability greater than 0.5:\ncello.cello_probs(\n    adata,\n    '21′,\n    cello_resource_loc,\n    0.5,\n    clust_key='leiden'\n)\nThe result of this function call is depicted in Figure 3[href=https://www.wicell.org#fig3].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/945-Fig3.jpg\nFigure 3. Output ontology graph plot\nThe probability that cells in Cluster 21 from Figure 1[href=https://www.wicell.org#fig1] are of each cell type for all cell types whose probability assignments are greater than 0.5.\nSave CellO’s output to a file\nTiming: 1 min\nSave CellO’s output to a tab-separated value (TSV) file:\ncello.write_to_tsv(\n    adata,\n    'GSM3516673_MSK_LX682_NORMAL.CellO_output.tsv'\n)"
  ],
  "subjectAreas": [
    "Rnaseq",
    "Bioinformatics"
  ],
  "bigAreas": [
    "Bioinformatics & Computational Biology"
  ]
}