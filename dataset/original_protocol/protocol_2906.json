{
  "id": 3076,
  "origin_website": "Cell",
  "title": "Protocol for predicting drug-resistant protein mutations to an ERK2 inhibitor using RESISTOR",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\n      Here we describe the step-by-step details of how to use RESISTOR. These\n      steps include how to 1) specify the K∗ positive and negative designs; 2)\n      run OSPREY to compute each mutant’s positive and negative K∗ scores; 3)\n      process the data to assign mutational probabilities and hotspot scores;\n      and, 4) assign Pareto ranks to each prospective mutant. As a demonstration\n      case, we use RESISTOR to predict ERK2 mutants likely to arise in melanoma\n      that may ablate the efficacy of the ERK1/2 inhibitor SCH7.\n    \nSpecifying the K∗ positive and negative designs\nTiming: 1 h\n      In this step, we create the YAML files that are used to specify the input\n      for the positive and negative K∗ designs. Positive design refers to\n      improving the interaction between a protein and its endogenous ligand,\n      which in this context is ERK2 with ATP. Negative design refers to ablating\n      the binding between a protein and its targeting inhibitor, here ERK2 and\n      SCH7. By this point, we assume you have completed the steps in the section\n      before you begin[href=https://www.wicell.org#before-you-begin], including having\n      downloaded the PDB structure files 4qta.pdb and 2y9q.pdb,\n      and the FASTA-formatted cDNA sequence file\n      ENST00000215832.10.fasta.\n    \n        Prepare each of the structure files.\n        \n            Open a terminal shell and activate the AmberTools environment you\n            created in before you begin[href=https://www.wicell.org#before-you-begin]:\n            \n> conda activate AmberTools22\n            Run pdb4amber on the two ERK2 structures to add any missing\n            atoms:\n            \n> pdb4amber --add-missing-atoms -i 2y9q.pdb -o\n                  2y9q.p4a.pdb\n> pdb4amber --add-missing-atoms -i 4qta.pdb -o\n                  4qta.p4a.pdb\nNote: pdb4amber renumbers\n              the residues in the input structures, starting from 1. We\n              would like to keep our canonical residue numbering, and luckily\n              pdb4amber outputs a mapping file from the original numbers\n              to the new numbers it assigned the residues. This file is titled\n              the name of the input file for pdb4amber, suffixed with",
    "_renum.txt, e.g., 2y9q.p4a_renum.txt. Within the OSPREY\n              distribution there’s a program called p4a-undo.py (found in\n              the osprey3.3/resistor directory) which re-assigns\n              the original numbering and chain identifiers.\n            \n            Using the same AmberTools22 conda environment, run\n            p4a-undo.py with each of the two output structures from\n            pdb4amber:\n            \n> python p4a-undo.py 2y9q.p4a.pdb\n                  2y9q.p4a_renum.txt > 2y9q.renum.pdb\n> python p4a-undo.py 4qta.p4a.pdb\n                  4qta.p4a_renum.txt > 4qta.renum.pdb\n            Add hydrogens to the AMP-PNP and SCH7 structures using a molecular\n            modeling program such as Maestro.\n            \nNote: Epik27[href=https://www.wicell.org#bib25]\n              in Maestro19[href=https://www.wicell.org#bib19] is quite good at correctly\n              predicting\n              \np  K a \n              and protonation states for small molecules. You will also need to\n              compute the net charge of the small molecules for step 3, which\n              Epik and Maestro provide. SCH7’s net charge is +1, whereas AMP-PNP\n              has a net charge of -4.\n            \n            Save the resulting protonated structures as 2y9q.h.pdb and\n            4qta.h.pdb.\nCritical: Ensure when saving\n              these protonated structures that the resulting PDB files do not\n              contain trailing whitespace (if it does, remove it using your text\n              editor) and the chain identifiers have been correctly preserved.\n            \n        Split the structure files into their protein and ligand components.\n        \nOpen 2y9q.h.pdb in a text editor.\n            Extract the ATOM records corresponding to ERK2 and save them to a\n            file called 2y9q.erk2.pdb.\n            Extract the ATOM records corresponding to AMP-PNP and save them as a\n            file called 2y9q.amppnp.pdb.\n            Do the same for 4qta.h.pdb, saving the corresponding files as\n            4qta.erk2.pdb and 4qta.sch7.pdb.\n        Generate the forcefield parameters and connectivity templates for SCH7\n        and AMP-PNP.\n        \nActivate your AmberTools environment, as in step 1a.\n            Use the antechamber program from AmberTools to generate\n            template files (files with a .prepi extension), and\n            parmchk2 to generate forcefield modification files (files\n            with a .frcmod extension):\n          \n> antechamber -i 2y9q.amppnp.pdb -fi pdb -o amppnp.prepi -fo prepi\n          -c bcc -nc -4\n> parmkch2 -i amppnp.prepi -f prepi -a Y -o amppnp.frcmod",
    "> antechamber -i 4qta.sch7.pdb -fi pdb -o sch7.prepi -fo prepi -c\n          bcc -nc +1\n> parmkch2 -i sch7.prepi -f prepi -a Y -o sch7.frcmod\nNote: For more information about these and\n      other possible flags to the antechamber and parmchk2 programs, see section\n      16.1 of the Amber 22 Reference Manual, available from\n      http://www.ambermd.org[href=http://www.ambermd.org].25[href=https://www.wicell.org#bib26]\n        Create template coordinates for the small molecules.\n        \n            Locate the gen-templ-coords.sh script you will use to\n            generate the template coordinates (in the\n            osprey3.3/resistor directory of the OSPREY\n            distribution).\n          \n            Add the executable bit to the script by running the following\n            command:\n            \n> chmod u+x gen-templ-coords.sh\n            Run gen-templ-coords.sh once for each of the ligands, using\n            Unix pipe redirection to save the output.\n            gen-templ-coords.sh expects as input the path of the ligand\n            structure and the three-letter residue name of the ligand used in\n            the structure:\n            \n> ./gen-templ-coords.sh 2y9q.amppnp.pdb\n                  ANP > amppnp.tc\n> ./gen-templ-coords.sh 4qta.sch7.pdb\n                  38Z > sch7.tc\n        Generate rotamers for AMP-PNP and SCH7\n        \n            To allow the ligands to translate, rotate, and flex slightly, we\n            define the flexible dihedrals for the ligands.\n          \n            Determine the molecule-specific dihedrals using Maestro or other\n            molecular visualization software.\n            Figure 2[href=https://www.wicell.org#fig2] demonstrates determining the dihedrals\n            in Maestro.\n            \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Fig2.jpg\n                  Figure 2. Demonstration of using Maestro to compute the\n                  H62-N6-C6-C5 and C2′-C1′-N9-C4 dihedral angles for the extra\n                  rotamers definition of AMP-PNP\n                \n                  The red lines and numbers show the dihedrals and the computed\n                  angles. In Figure 3[href=https://www.wicell.org#fig3], these dihedrals are\n                  included in the rotamer definition for AMP-PNP. The values\n                  -3.8 and 106.9 are rounded to their nearest whole value, -4\n                  and 107, respectively.\n                \n            Create a text file listing the dihedrals. The format of the file,\n            and the rotamer specification for AMP-PNP is shown in\n            Figure 3[href=https://www.wicell.org#fig3].\n            \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Fig3.jpg\n                  Figure 3. Definition of a rotamer for AMP-PNP. We specify 10\n                  dihedrals\n                \n                  These dihedrals allow K∗ in OSPREY to minimize continuously in",
    "a voxel around the dihedrals to search for low-energy\n                  conformations. This rotamer is defined by its atom names from\n                  the PDB file, 2y9q. Lines that begin with an exclamation point\n                  (!) are comments. The comments here explain the structure of\n                  the file.\n                \nSave the file as amppnp.rot.\n            Repeat steps a-d for SCH7, saving that file as sch7.rot.\n        Create a template YAML file for the ERK2:AMP-PNP positive K∗ design.\n        \n            The OSPREY package contains a template K∗ affinity YAML file,\n            located at osprey3.3/resistor/affinity.yaml. Make a\n            copy of this file:\n            \n> cp affinity.yaml erk2-amppnp.yaml\n            Open the new file in your text editor and incorporate the files\n            you’ve created thus far into the YAML file:\n            \n                Copy the contents of 2y9q.erk2.pdb as the value for the\n                protein.coordinates key.\n              \n                Copy the contents of 2y9q.amppnp.pdb as the value for the\n                ligand.coordinates key.\n              \n                Copy the contents of amppnp.tc as the value for the\n                ligand.extra_template_coordinates key.\n              \n                Copy the contents of amppnp.prepi as the value of the\n                ligand.extra_templates key.\n              \n                Copy the contents of amppnp.rot as the value of the\n                ligand.extra_rotamers key.\n                \nOptional: You can use a\n                  YAML syntax validator, such as yamllint,26[href=https://www.wicell.org#bib27]\n                  to verify you have input syntactically valid YAML.\n                \n            To verify that you have created the YAML file correctly, run OSPREY\n            to verify the design file:\n            \n> osprey affinity --design erk2-amppnp.yaml\n                  --verify-design\n            The output of the command should look like:\n            \nWARNING: Using incubator modules: jdk.incubator.foreign\nDesign file validated.\n            See troubleshooting 2[href=https://www.wicell.org#sec5.3] if your output is\n            different, and troubleshooting 4[href=https://www.wicell.org#sec5.7] if the\n            command output says it can’t parse the YAML file.\n          \n        Create a template YAML file for the ERK2:SCH7 negative K∗ design.\n        \n            As in step 6a, copy the template K∗ affinity YAML file:\n            \n> cp affinity.yaml erk2-sch7.yaml\n            Open erk2-sch7.yaml in your text editor and incorporate the\n            following files into the negative design specification:",
    "Copy the contents of 4qta.erk2.pdb as the value for the\n                protein.coordinates key.\n              \n                Copy the contents of 4qta.sch7.pdb as the value for the\n                ligand.coordinates key.\n              \n                Copy the contents of sch7.tc as the value for the\n                ligand.extra_template_coordinates key.\n              \n                Copy the contents of sch7.prepi as the value for the\n                ligand.extra_templates key.\n              \n                Copy the contents of sch7.rot as the value for the\n                ligand.extra_rotamers key.\n              \n            To ensure that your YAML file is in the correct format for OSPREY,\n            use the affinity command’s --verify-design flag\n            to check the design file:\n            \n> osprey affinity --design erk2-sch7.yaml\n                  --verify-design\n            The output of the command should look like:\n            \nWARNING: Using incubator modules: jdk.incubator.foreign\nDesign file validated.\n            See Video S7[href=https://www.wicell.org#mmc9] for a demonstration of how to do\n            this step and see troubleshooting 2[href=https://www.wicell.org#sec5.3] if your\n            output is different.\n          \n        Choose residues to mutate and create mutational scan designs.\n        \n            Taking the files you created in steps 6 and 7, add a YAML list of\n            objects representing these mutants as the value of the\n            scan.residues key, as is shown in\n            Figure 4[href=https://www.wicell.org#fig4].\n            \nNote: For this example, we have\n              chosen to investigate residues Y36, A52, I56, R67, E71, Q105,\n              D106, L107, M108, D111, K114, L156, and C166.\n            \n            In each of the files generated in steps 6 and 7, set the ligand as\n            flexible by adding it to the\n            ligand.residue_configurations key in the YAML file.\n            Figure 5[href=https://www.wicell.org#fig5] shows how this is set in the\n            erk2-amppnp.yaml and erk2-sch7.yaml files.\n          \n            After adding these fields, again verify the syntax of the design\n            files is correct:\n            \n> osprey affinity --design erk2-sch7.yaml\n                  --verify-design\n> osprey affinity --design erk2-amppnp.yaml\n                  --verify-design\n        Generate the K∗ affinity designs for each of the point mutants.\n        \n            Using the files you modified in step 8, use OSPREY to generate the\n            positive and negative designs for each of the mutants:\n            \n> osprey affinity --design erk2-sch7.yaml --do-scan\n                  --scan-flex-distance 2.2",
    "> osprey affinity --design erk2-amppnp.yaml --do-scan\n                  --scan-flex-distance 2.2\nNote: The\n              --do-scan flag instructs OSPREY to generate a K∗\n              affinity design centered on each of the residues specified in the\n              scan.residues key. These K∗ affinity designs each\n              include a single mutable residue, which is set to mutate to all\n              the other amino acids, and a flexible shell around the mutating\n              residue. The optional --scan-flex-distance parameter\n              denotes the radius of the OSPREY-generated flexible shell centered\n              on the design's mutable residue. It defaults to 2 Å.\n            \n            Verify that a positive and negative YAML design specification is\n            created for each of the 13 residues of interest set in step 8a. The\n            naming format of these files is\n            {original-name}.{residue}.yaml, e.g.,\n            erk2-sch7.A36.yaml. There should be a total of 26 newly\n            created files.\n          \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Fig4.jpg\n          Figure 4. Specification of the scan.residues key\n        \n          The value for the key is a list of objects representing residues in\n          the structure. Each object has a chain key denoting the\n          chain identifier in the structure, a res_num key denoting\n          the residue number, and the aa_type key with the 3-letter\n          amino acid code. In the example above, we specify that Y26 and A52 in\n          chain A of the structure should be included in the scan. Below the\n          ellipsis we would also include objects for I56, R67, E71, Q105, D106,\n          L107, M108, D111, K114, L156, and C166.\n        \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Fig5.jpg\n          Figure 5. Demonstration of how to specify that the ligand should be\n          flexible in both the positive and negative designs\n        \n          Left: residue 38Z on chain B at position 411 (which is SCH7) is set to\n          be continuously flexible. Right: residue ANP on chain B at position\n          1359 (which is AMP-PNP) is set to be continuously flexible.\n        \n        Your browser does not support HTML5 video.\n      \n          Video S7. Demonstration of creating the ERK2:AMP-PNP K∗ affinity YAML",
    "design file, related to specifying the K∗ positive and negative\n          designs step 7\n        \nRunning the K∗ predictions\nTiming: 1 day to 1 week\n    \n      The purpose of this step is to run the positive and negative K∗ mutant\n      predictions with OSPREY. The range in expected time on this step is\n      dependent on how many sequences you’re predicting, the number of flexible\n      residues you’ve configured in your conformation space, and the\n      capabilities of your computer(s). For additional background information on\n      the interpretation of K∗ values and how they are used in predicting\n      resistance mutations, see the Results and\n      STAR Methods sections of Guerin et al., 2022.1[href=https://www.wicell.org#bib1]\n        Run the positive and negative K∗ designs.\n        \n            Set the amount of memory to dedicate to the OSPREY process by\n            exporting the JAVA_OPTS environment variable. Set this as high as\n            you can, given the hardware you’re running the design on. Here’s how\n            it could be set on a machine with 760GiB of RAM (while leaving some\n            RAM for the operating system and other processes):\n            \n> export JAVA_OPTS=\"-Xmx720G -Xms720G\"\n            Execute the affinity command in OSPREY on each of the\n            individual mutant design files that you generated in step 9:\n            \n> osprey affinity --design {design-file} --frcmod\n                  {frcmod-file}\n            where {design-file} is the path to one of the design files\n            you generated in step 9, and {frcmod-file} is the path to the\n            ligand-specific forcefield modification file you generated in step\n            3b, e.g.,:\n            \n> osprey affinity --design erk2-sch7.A36.yaml --frcmod\n                  sch7.frcmod\nNote: There are optional flags you\n              can pass to the affinity command that could be helpful for your\n              predictions. These flags include --save-confs,\n              --ensemble-dir, and --cuda .\n              --save-confs takes an integer argument and denotes\n              the number of low-energy conformations from the K∗ molecular\n              ensemble that OSPREY should save of each sequence. It defaults to",
    "not outputting structures; if you want structures add this\n              argument and specify a number greater than 0.\n              --ensemble-dir takes a path as an argument and\n              indicates where structures should be saved. And if you have access\n              to CUDA-enabled Nvidia GPUs, you may find that the\n              --cuda flag substantially decreases the amount of\n              time needed to run your designs.\n            \n            Execute the following command to print the per-residue type K∗\n            predictions to the terminal screen. If you also want to save the\n            output (both standard out and standard error) to files, you can use\n            Unix pipes to pipe the output to the tee program:\n            \n> osprey affinity --design erk2-sch7.A36.yaml --frcmod\n                  sch7.frcmod > >(tee -a sch7.A36.stdout) 2> >(tee\n                  -a sch7.A36.stderr >&2)\nNote: There is an optional\n              parameter, --epsilon, which takes a double value as\n              an argument and defaults to 0.683 (see the\n              supplemental information[href=https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Mmc1.zip]\n              of Ojewole et al. for justification for this default).2[href=https://www.wicell.org#bib2]\nNote: --epsilon must\n              be between 0 and 1; values closer to 0 indicate a more accurate\n              partition calculation and are thus more computationally expensive,\n              and vice-versa. We recommend initially running K∗ affinity designs\n              with an epsilon close to 1, such as 0.9999, and then gradually\n              decreasing epsilon to obtain increasingly accurate K∗ scores while\n              still completing in a reasonable amount of time.\n            \nAssign Pareto Ranks\nTiming: 1 h\n      The purpose of this step is to compile and annotate the positive and\n      negative K∗ mutant predictions with mutational signature probabilities and\n      hotspot scores. In addition, we run the resistor program to compute\n      the cutoff, c, from the K∗ predictions, and filter mutants that K∗\n      predicts not to be resistance mutants, or whose mutational probability is\n      0, and assign Pareto ranks.\n    \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Fig6.jpg\n          Figure 6. A partially completed worksheet from step 11c\n        \n          The\n          \nl o  g 10",
    "K∗ scores for the positive designs (ERK2:AMP-PNP) and negative designs\n          (ERK2:SCH7) are put in columns D-G. Put the K∗ score, for the\n          wild-type sequence, e.g., Q105, bound to the endogenous ligand in\n          column D, and the mutant sequence, e.g., Q105A, bound to the\n          endogenous ligand in column E. In columns F and G do the same for ERK2\n          bound to SCH7.\n        \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Fig7.jpg\n          Figure 7. The format of the output file resulting from running step\n          12c\n        \n          Columns H-K are now filled out. Column H contains the computed\n          signature probability, column I the corresponding codon from the cDNA\n          FASTA file, column J the hotspot count, and column K the computed\n          Pareto rank. The\n          \nl o  g 10 \n          K∗ scores for the positive designs (ERK2:AMP-PNP) and negative designs\n          (ERK2:SCH7) are included in columns D-G but are omitted above due to\n          space constraints. The full output file is included in\n          Data S1[href=https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2651-Mmc1.zip].\n        \nNote: Your positive and negative K∗\n      predictions from step 10 should be complete prior to beginning this step.\n    \n        Compile the K∗ predictions.\n        \n            Copy the template CSV file included in the OSPREY distribution\n            (osprey3.3/resistor/resistor.csv) to\n            erk2-resistor.csv.\n            Using the output files from the predictions in step 10, which\n            contain the\n            \nl o  g 10 \n            K∗ scores for each of the sequences you evaluated at a particular\n            residue location, fill out the following columns.\n            \nwild-type residue should have the 3-letter amino acid\n                code for the wild-type residue at residue number.\n              \nresidue number should have the residue number of the\n                residue.\n              \nmutant residue should have the 3-letter amino acid code\n                for the mutant residue RESISTOR is evaluating.\n              \nwild-type K∗ (positive) should have the\n                \nl\no\n g 10 \n                K∗ score computed on the ERK2:AMP-PNP structure for\n                residue number.\n              \nmutant K∗ (positive) should have the\n                \nl\no\n g 10 \n                K∗ score computed on the ERK2:AMP-PNP structure for",
    "residue number when mutant residue is substituted\n                for wild-type residue.\n              \nwild-type K∗ (negative) should have the\n                \nl\no\n g 10 \n                K∗ score computed on the ERK2:SCH7 structure for\n                residue number.\n              \nmutant K∗ (positive) should have the\n                \nl\no\n g 10 \n                K∗ score computed on the ERK2:SCH772894 structure for\n                residue number when mutant residue is substituted\n                for wild-type residue.\n              \n            Complete a new row for each mutant sequence you evaluated in step\n            10. Each positive/negative design pair from step 10 evaluated 21\n            different residue types in each location, meaning we must complete\n            21 rows for each residue. See Figure 6[href=https://www.wicell.org#fig6] for an\n            example of a partially completed worksheet.\n          \n        Run the resistor program to assign mutational signature\n        probabilities, filter predicted benign mutations, and assign Pareto\n        ranks.\n        \n            Open a terminal and change into the\n            osprey3-3/resistor directory.\n          \n            Download the required Julia dependencies:\n            \n                Start the Julia interpreter with the following command:\n                \n> julia --project=.\n                Activate Julia’s package manager by hitting the\n                ']' key.\n              \n                Type instantiate and wait while the package manager\n                downloads the dependencies.\n              \n                Exist the interpreter by entering CTRL-D or typing\n                exit() and hitting enter.\n              \n            Run the program to assign the mutational probabilities and cDNA\n            codons to each mutant sequence:\n            \n> julia --project=. main.jl --mut-prob {mut-prob-file}\n                  --fasta {fasta-file} --identifier {id} --csv-file {csv-file}\n                  --pareto-config {pareto-config}\n            where {mut-prob-file} is the path to the mutational\n            probabilities file, {fasta-file} is the path to the cDNA\n            file, {id} is the identifier of the sequence in\n            {fasta-file}, {csv-file} is the path to the CSV file you\n            created in step 11, and {pareto-config} is the path to the\n            default Pareto optimization configuration JSON, e.g.,:\n            \n> julia --project=. main.jl --mut-prob\n                  osprey3-3/resistor/mutational-signatures/melanoma.json --fasta\n                  ./mapk1-cdna.fasta --identifier MAPK1 --csv-file\n                  erk2-resistor.csv --pareto-config\n                  osprey3-3/resistor/pareto-config.json\n            This command.\n            \n                Fills out the signature probability and\n                codon columns.\n              \n                Filters rows whose mutant K∗ (positive) is less than 0,",
    "as this indicates the loss of function with the endogenous\n                ligand.3[href=https://www.wicell.org#bib3]\n                Filters rows whose signature probability is 0 (indicating\n                that the mutant can only occur with 3 base changes).\n              \n                Computes the cut-off c, as defined in Equation 4 in\n                Guerin et al.1[href=https://www.wicell.org#bib1]\n                Filters mutants whose ratio of positive to negative K∗ scores is\n                below the cut-off.\n              \n                Fills out the hotspot count column by counting how many\n                resistance mutations remain at each position after the filtering\n                in the prior steps.\n              \n                Fills out the rank column by running Pareto optimization\n                over the mutant K∗ (positive),\n                mutant K∗ (negative), signature probability, and\n                hotspot count columns.\n              \n            It outputs the completed table to standard out. You can redirect it\n            to a file using I/O redirection in Linux or by piping the output to\n            the tee command. Figure 7[href=https://www.wicell.org#fig7] provides an\n            example of the output file.\n            \nNote: The Pareto JSON\n              specification file is described in the README.md. By\n              default, RESISTOR optimizes over mutational signature probability,\n              the positive and negative K∗ scores, and the hotspot score.\n              We've provided a template Pareto JSON specification file in\n              the resistor directory, pareto-config.json,\n              which specifies to optimize by maximizing a mutant's signature\n              probability, positive design K∗ score, and hotspot score, and\n              minimizing the mutant's negative design K∗ score. If you had\n              other criteria to optimize over you could add these to this Pareto\n              JSON specification file.\n            \nNote: There are two additional\n              optional flags to the command above that may be helpful in some\n              circumstances. These flags are --debug and\n              --c0. The --debug flag prints out\n              intermediary CSV files after each filtering and computational\n              step. It also prints the computed cut-off c to standard\n              error. The --c0 flag allows you specify a different\n              value for\n              \n c 0 \n , for more information as to what this value is see Guerin\n              et al.1[href=https://www.wicell.org#bib1]"
  ],
  "subjectAreas": [
    "Bioinformatics",
    "Computer Sciences",
    "Biotechnology And Bioengineering",
    "Cancer",
    "Structural Biology",
    "Protein Biochemistry",
    "High Throughput Screening"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}