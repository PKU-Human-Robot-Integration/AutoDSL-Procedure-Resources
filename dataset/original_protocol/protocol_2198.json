{
  "id": 2314,
  "origin_website": "Cell",
  "title": "SparseSignatures: An R package using LASSO-regularized non-negative matrix factorization to identify mutational signatures from human tumor samples",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nMaking the most of the provided code\nWe will break down the signature discovery procedure as a sequence of R snippets of code. They may be run interactively in the console provided by the R environment of choice, or composed in a .r script – optionally modified according to the user’s requirements. Notice that automating the whole procedure is infeasible, since the user’s direct interaction is required for the choice of the optimal parameters (see section “determining a valid range for the sparsity parameter[href=https://www.wicell.org#sec2.6]”).\nFor illustration purposes, the protocol will make use of example datasets, derived from the breast-cancer mutation dataset analyzed in (Nik-Zainal et al., 2016[href=https://www.wicell.org#bib2]). The user is invited to test the package using these datasets, and to inspect them to understand the required formats precisely, before using real data.\nInput dataset specification\nTiming: 1 h\nThe user must prepare a dataset detailing all the identified point mutations for all the patients observed in the study.\nA typical starting point is given by one or more VCF (Variant Calling Format) files. For more information, a simple overview of the VCF file format can be found at: https://learn.gencore.bio.nyu.edu/ngs-file-formats/vcf-format[href=https://learn.gencore.bio.nyu.edu/ngs-file-formats/vcf-format].\nConvert the dataset of interest into an R data.frame or matrix object. For example, a VCF file must be cleaned and saved in either a CSV or TSV file format as follows:\nEach record corresponds to a single mutation.\nThe columns should have the following names, reporting the stated information:\nsample: the unique identifier of the patient/cancer sample from which the mutation is observed.\nchrom: the affected chromosome.\nstart: the starting nucleotide of the affected sequence, as a numeric location referred to the chromosome.\nend: the final nucleotide location (this should always be the same as the starting location for point-mutations).",
    "ref: the corresponding nucleotide in the reference genome.\nalt: the altered nucleotide measured in the sample.\nThe exact DNA location allows retrieving the context of the mutation, which may be one out of 16 types, as explained above.\nImport the constructed data file, in R using read.delim as follows:\n## If the values are comma-separated\nmutations_df <- read.delim(\"/path/to/datafile.csv\", sep = \",\")\n## OR\n## If the values are TAB or whitespace-separated\nmutations_df <- read.delim(\"/path/to/datafile.tsv\", sep = \"\\t\")\nAs an example of the features of the dataset, once loaded in memory, we load one of the example datasets from (Nik-Zainal et al., 2016[href=https://www.wicell.org#bib2]), consisting of a list of point mutations in the DNA of breast cancer samples taken from three individuals (out of the 560 of the original whole dataset). The user can load it and inspect it as follows:\ndata(ssm560_reduced)\nListing the first ten elements of the matrix, with\nhead(ssm560_reduced, n = 10)\nWe obtain an example of the general form after which the mutations_df dataset should be modeled:\nsample chrom    start        end ref  alt\n1: PD10014a    1 186484577    186484577  A  C\n2: PD10014a    7 141761948    141761948  G  A\n3: PD10014a    7 71266228      71266228  C  T\n4: PD10014a    8 82304475      82304475  A  T\n5: PD10014a    3 191275626    191275626  T  A\n6: PD10014a    4 135265376    135265376  C  T\n7: PD10014a    3 119344674    119344674  G  A\n8: PD10014a    6 19019947      19019947  G  A\n9: PD10014a    2 32318168      32318168  C  T\n10: PD10014a    13 89605097    89605097  A  T\nGenerate the patient vs mutation matrix from mutation data\nTiming: 1–5 min\nThe SparseSignatures library provides facilities to effortlessly generate mutation frequency count data from point mutation data-frames. We will exemplify the procedure using the provided example datasets. The user can proceed with the data.frame prepared in the previous step.",
    "Attach the SparseSignatures package. By doing this we will get seamless access to the functions nmfLassoCV, nmfLasso, etc., which we will employ below.\nlibrary(\"SparseSignatures\")\nInstall a reference human-genome specification from the Bioconductor repositories, within the package group BSgenome. The user must select, among the available choices, the reference genome consistent with the mutation dataset. In the case of the dataset illustrated above, the correct reference genome is hs37d5 (its information sheet can be downloaded from this FTP host). We continue with this choice, here, for the sake of illustration. We download the package BSgenome.Hsapiens.1000genomes.hs37d5, evaluating the snippet.\nif (!require(\"BSgenome.Hsapiens.1000genomes.hs37d5\", quietly = TRUE)) {\n  BiocManager::install(\"BSgenome.Hsapiens.1000genomes.hs37d5\")\n}\nDifferent reference genomes can be adopted where needed, for instance to install hg38, one can use the following code:\nif (!require(\"BSgenome.Hsapiens.UCSC.hg38\", quietly = TRUE)) {\n  BiocManager::install(\"BSgenome.Hsapiens.UCSC.hg38\")\n}\nProduce the trinucleotide-count matrix from the data-frame. This is automatically done using the function import.trinucleotides.counts:\npatients <- import.trinucleotides.counts(\n  data = ssm560_reduced,\n  reference = BSgenome.Hsapiens.1000genomes.hs37d5::hs37d5\n)\nWhen the user prints the matrix, the rows are named according to the three patient IDs in ssm560_reduced. The column names are expressed with an encoding specifying both the context and the base substitution. As an example, A[C>A]G represents a mutation C>A in the context ApG.\nThe timing information given at the beginning of the section is a rough estimate. The genome installation (7) should take little time depending on connection speeds. The main bottleneck is the import.trinucleotides.counts function. With a simulated dataset of 560 patients and 8000 mutations each, step (8) took about 80 s on our systems.\nPreparing a reference background signature\nTiming: 1 min",
    "The background signature represents the residual mutation pattern invariably observed in most datasets, and that is usually explained by spontaneous occurrences of DNA mutation. While it can be omitted from the analysis, we suggest including it explicitly. The package provides two background signatures: the SBS5 signature extrapolated from the COSMIC database (Lal et al., 2021[href=https://www.wicell.org#bib1]), and a signature derived from the human germline mutation spectrum (Rahbari et al., 2016[href=https://www.wicell.org#bib3]).\nImport one of the available background signatures:\n# To load the SBS5 signature from COSMIC\ndata(background)\n# OR, for the human germline-derived signature\ndata(background2)\nIf in doubt, the user may adopt the SBS5 signature. As the user can verify, the two backgrounds are very similar according to several similarity measures and yield very similar results in practice. Both signatures have been slightly adjusted compared to the original sources. See (Lal et al., 2021[href=https://www.wicell.org#bib1]) for details.\nDetermining the optimal signature number and sparsity to describe the data\nThis section deals with issues of technical nature relating to the sparsity parameter λβ. We remind the user that although the SparseSignatures package allows to sparsify the exposure levels α, this approach provided limited benefit while showing computational downsides. For this reason, we will set the sparsity parameter for the α values to zero in all the functions that require it. That is, only the signatures (beta) will be regularized and made sparse.\nThe package does not implement the signature parameter λβ in the same linear scale we used for simplicity in the theoretical presentation above. SparseSignatures allows for a fractional value instead, chosen between 0 and 1, with a value of 0 meaning no sparsification and a level of 1 meaning extreme sparsification.\nHere we propose a systematic approach to the choice of the λβ parameter, using model selection with cross-validation.",
    "Determining a valid range for the sparsity parameter\nTiming: 4 min\nBefore we proceed with cross-validation, we need a heuristic approach to find levels of λβ that are within the working range of the algorithm: that is, values that ensure the convergence of the iterative procedure to meaningful outputs. To give an intuitive explanation of what could go wrong, imagine trying to fit many signatures, each with a high sparsity level. In such conditions, the random fluctuations pertaining to the dataset will have comparable scale to the excessively fragmented signatures, resulting in the signatures, and the exposures, being fundamentally misleading.\nTo find the appropriate working range, the user will have to manually test large values of K (the expected maximum number of signatures) against the λβ values. The lambdaRangeBetaEvaluation function does this automatically.\nDecide on a range for K. It should be large enough to realistically accommodate the correct number of signatures characterizing the dataset (e.g., from 3 to 10). The criteria for this decision are left to the user, as they are context dependent.\nChoose a range of λβ percentage values, with roughly logarithmic spacing up to 0.2 (that is, 0.01, 0.02, 0.05, 0.1, 0.2) after which, proceed linearly (0.225, 0.25, 0.275, 0.3, …).\nApply the function lambdaRangeBetaEvaluation using the ranges for both variables. The function simply runs NMF LASSO on all combinations and lists the results (for the description of the list elements, see the return value description of nmfLasso below).\nlambda_test_values <- c(0.01, 0.02, 0.05, 0.1, 0.2,\n            0.225, 0.25, 0.275, 0.3)\nresults <- lambdaRangeBetaEvaluation(\n  x = patients,\n  K = 5,\n  lambda_values = lambda_test_values,\n  background_signature = background,\n  num_processes = 7\n)",
    "lambdaRangeBetaEvaluation applies nmfLasso with the same specified arguments, except that it uses each value in lambda_test_values in turn. The variable results, therefore, holds a list of the corresponding nmfLasso outputs.\nInspect the results manually to verify whether there is a “cutoff” λβ value. If the loglik_progression entries appear to progressively decrease in absolute value, the combination of K and the corresponding lambda-value is feasible. If the entries quickly diverge (becoming more negative) and settle to a constant value after a few iterations, it suggests that the lambda value is infeasible.\nfor (i in 1:length(lambda_test_values)) {\n  print(colnames(results)[[i]])\n  print(results[[i]]$loglik_progression)\n}\nFor instance, working on the example count matrix patients, we test how the λβ values listed in point 9 change in relation to a number of signatures fixed at K=11. Running the script in point 10, we can easily spot the breakdown threshold. Below we show the output only for values surrounding the threshold.\n[...]\n[1]      \"0.1_lambda\"\n[1]  -8065560  -7312610  -6767842  -6346069  -5975574  -5694979  -5427427  -5194391\n[9]  -4973937  -4798716  -4646921  -4507951  -4368058  -4225559  -4110451  -3981539\n[17]      -3992065  -3794053  -3748403  -3702421  -3675555  -3633509  -3480397  -3481899\n[25]      -3358015  -3345410  -3306015  -3303896  -3169428  -3128517\n[1]      \"0.2_lambda\"\n[1]  -12669715  -10718856  -8773025  -7183825  -6507950  -6022814  -5619947\n[8]    -5312232  -4999882  -4809946  -4626685  -4460192  -4360289  -4423328\n[15]        -4271314  -4036836  -3931123  -3877422  -3997542  -3863774  -3788185\n[22]        -3512490  -3475233  -3391853  -3285069  -3194724  -3239158  -3183367\n[29]        -3151490  -3008538\n[1]    \"0.225_lambda\"\n[1]    -13554255  -24479752  -58940280  -59080222  -59080222  -59080222  -59080222\n[8]    -59080222  -59080222  -59080222  -59080222  -59080222  -59080222  -59080222\n[15]        -59080222  -59080222  -59080222  -59080222  -59080222  -59080222  -59080222\n[22]        -59080222  -59080222  -59080222  -59080222  -59080222  -59080222  -59080222\n[29]        -59080222  -59080222\n[1]    \"0.25_lambda\"\n[1]    -14367716  -56298111  -56342555  -59080222  -59080222  -59080222  -59080222\n[8]    -59080222  -59080222  -59080222  -59080222  -59080222  -59080222  -59080222\n[15]        -59080222  -59080222  -59080222  -59080222  -59080222  -59080222  -59080222\n[22]        -59080222  -59080222  -59080222  -59080222  -59080222  -59080222  -59080222\n[29]        -59080222  -59080222",
    "[...]\nThe log-likelihood progressions up to a value λβ=0.2 of the sparsity parameter exemplify the expected behavior: a quick rise after the first value, and a stabilization in about 30 iterations. As soon as we hit the slightly higher choice of parameter λβ=0.225, we observe, instead, a rapid divergence towards a fixed low log-likelihood value, which is evidence of lack of convergence.\nSelect the values of K and λβ to carry over to the cross-validation process. Bi-cross-validation tests all the combinations (K, λβ) built from the chosen lists of values of the two parameters. The list of values of K is the one tested above. The values of λβ are the one used in lambdaRateBetaEvaluation, up to the highest that guarantees convergence for all K (i.e., the largest just below all observed cutoffs).\nA full description of the function lambdaRateBetaEvaluation can be found in Table 1[href=https://www.wicell.org#tbl1].\ntable:files/protocols_protocol_1806_1.csv\nDetermining the optimal signature number and sparsity by cross-validation\nTiming: 1 h per repetition\nWe are now in position to use cross-validation to determine the optimal values among user-supplied ranges for the number of signatures K and the sparsity parameter λβ.\nPerform (bi-)cross-validation across the ranges for K and for λβ (expressed in fractional scale) using the selected background signature and disabling regularization for the exposures α:\ncv_out <- nmfLassoCV(\n  x = patients,\n  K = 3:6,\n  background_signature = background,\n  lambda_values_alpha = 0,\n  lambda_values_beta = c(0.01, 0.02, 0.05, 0.1, 0.2, 0.25),\n  cross_validation_repetitions = 5,\n  num_processes = 7,\n  log_file = \"<your log text file filename>\"\n)",
    "The return value in cv_out is a list, comprising goodness-of-fit measures for each cross-validation repetition, as specified in the cross_validation_repetitions argument. We are interested in the first element of the list – a 3-index array specifying the mean squared errors (MSE) for all combinations of lambda_values_alpha, lambda_values_beta and K (in this order). The first index can be ignored: it comprises a single value for lambda_values_alpha, which we originally set to 0. Using the MSEs along the other two dimensions, we can determine their best combination by adopting a minimal MSE criterion.\nAnalyze the mean squared error results averaging over cross-validation repetitions. Within a single run, with multiple repetitions (cross_validation_repetitions > 1), obtain the mean MSEs for all combinations of K and lambda_values_beta:\ncv_mses <- cv_out$grid_search_mse[1, , ]\ncv_means_mse <- matrix(\n  sapply(cv_mses, FUN = mean),\n  nrow = dim(cv_mses)[1]\n)\ndimnames(cv_means_mse) <- dimnames(cv_mses)\nCompute the combination with the lowest MSE:\nmin_ii <- which(cv_means_mse == min(cv_means_mse), arr.ind = TRUE)\nmin_Lambda <- rownames(cv_means_mse)[min_ii[1]]\nmin_K <- colnames(cv_means_mse)[min_ii[2]]\ncat(\"Minimum MSE at:\", min_Lambda, \"and\", min_K, \"\\n\")\nThe output will look like the following:\nMinimum MSE at: 0.01_Lambda_Beta and 5_Signatures\nA full specification of nmfLassoCV, together with its arguments, is found in Table 2[href=https://www.wicell.org#tbl2] below.\ntable:files/protocols_protocol_1806_2.csv\nDiscovering the signatures within the dataset\nTiming: 5 min\nHaving determined the optimal number of signatures K and sparsity parameter λβ completes the preparatory steps for the analysis.\nThereafter, the results can be used to set up the signature discovery process, using the nmfLasso function, whose full argument specification is found in Table 3[href=https://www.wicell.org#tbl3].\ntable:files/protocols_protocol_1806_3.csv",
    "Apply the nmfLasso function on the dataset (e.g., patients), specifying the values of K and lambda_rate_beta found by cross-validation. The default number of iterations, 30, should suffice in most cases. Since this step entails only one run of nmfLasso, the number of iterations can be raised for more stable results (e.g., 50). Keep the lambda_rate_alpha parameter to 0, to disable the regularization of the exposure values.\nnmf_lasso_out <- SparseSignatures::nmfLasso(\n  x = patients,\n  K = 4,\n  background_signature = background,\n  lambda_rate_alpha = 0,\n  lambda_rate_beta = 0.1,\n  iterations = 50\n)\nAnalyze the output list nmf_lasso_out, whose information can be extracted using the named entries. These are summarized in the table below (N stands for the number of samples):\ntable:files/protocols_protocol_1806_4.csv\nSignature visualization and analysis\nTiming: 1 min\nAfter the analysis with nmfLasso has been performed, the user can read the signatures in the following ways:\nPerform direct signature evaluation by considering the returned beta matrix:\n# For an individual (non-background) signature (2 <= k <= K)\nnmf_lasso_out$beta[k,]\n# For the exposure vector (size K - 1)\n# of the n-th patient to the discovered signatures:\nnmf_lasso_out$alpha[n, -1]\n# For the exposure to the background signature:\nnmf_lasso_out$alpha[n, 1]\nRepresent a number of signatures graphically with the signatures.plot function:\nbeta <- nmf_lasso_out$beta\n# Visualize all signatures (for up to 8 signatures)\nsignatures.plot(beta)\n# Visualize a subset (for best results with more than 8 signatures)\nsignatures.plot(beta[c(2, 3, 5),])"
  ],
  "subjectAreas": [
    "Genomics",
    "Bioinformatics",
    "Cancer"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}