{
  "id": 3331,
  "origin_website": "Cell",
  "title": "Single-cell RNA sequencing and analysis of rodent blood stage Plasmodium",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nPlasmodium chabaudi chabaudi infection and disease monitoring\nTiming: 7–8 days\nIn this section we describe Pcc infection and disease monitoring in C57BL/6J mice (12–14 weeks old).\nThe virulence of Pcc infection varies according to the number of times the parasites are passaged in mice, i.e., when the parasite life cycle stages naturally occurring in the mosquito and mouse liver are bypassed and mice are infected by sequential Pcc-infected blood transfusions.15[href=https://www.wicell.org#bib25] The first blood stage infection derived from the mosquito (i.e., passage 0, P0) is established after a liver stage of infection, and is characterized by the development of low parasitemia, rapid parasite clearance and low virulence, i.e., slight deviation in health parameters. As the number of blood passages increases, parasitemia and virulence increase accordingly. The values presented below for health parameters and parasitemia refer to 7 and ∼30 passages (P30) after the initial mosquito bite and liver infection (Figure 4[href=https://www.wicell.org#fig4]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2918-Fig4.jpg\nFigure 4. Disease progression in Pcc-infected C57BL/6J mice\nMice were infected with different passages of Pcc AS parasites (P7, P33). Disease and parasite development were monitored daily for 15 days.\n(A–F) (A) Parasitemia, i.e., percentage of infected RBC (iRBC); (B) number of RBC per μL of blood (RBC/μL); (C) pathogen load, i.e., number of iRBC RBC per μL of blood (iRBC/μL); (D) weight loss, i.e., percentage of initial weight; (E) core body temperature; (F) glycemia. N = 2 mice per group. Data as mean ± SD in all plots.",
    "Note: Depending on the parasite and mouse strain used, time and severity of infection might differ. It is recommended to perform a disease progression analysis prior to the single-cell RNA sequencing experiment to identify the time point of interest. Protocol is described for adult male C57BL/6J mice maintained under specific pathogen free conditions (SPF), fed ad libitum with standard chow and maintained at 22°C room temperature with a light cycle of 12/12 h.\nDisease monitoring: Monitor mouse health parameters before the infection (Day 0) to define steady state and to calculate deviations from steady state during the course of infection.\nCore body temperature is measured using a rectal probe. Steady state values should range between 36°C and 38°C.\nBody weight is measured using a scale. Steady state values should range between 24–28 g for male C57BL/6J mice, at 12–14 weeks of age.\nGlycemia is measured in a drop of blood, collected as described for parasitemia determination using a Glucometer. Steady state values should range between 120–180 mg/dL.\nNote: Steady state core body temperature and glycemia measurements are highly dependent on the mouse’s stress status and vary accordingly. It is advisable to handle mice a few days, before starting the experiment, for acclimatization to manipulation, to prevent misleading steady-state measurements. Core body temperature and glycemia also vary in a circadian manner16[href=https://www.wicell.org#bib14],17[href=https://www.wicell.org#bib15] and as such it is advisable to monitor mice at same time of the day.\nPcc infection: Infect mice as described above in the experimental mice infection section. The day of infection is considered as day 0 (D0).\nDisease progression monitoring: Monitor mice daily, from day 3 onwards, for the parameters described above:",
    "Note: Core body temperature of Pcc-infected male C57BL/6J mice can decrease up to 29°C–32°C, at day 7 post infection (i.e., peak of infection), corresponding to a loss of ∼6°C–9°C (10%–20%), relative to steady state. This is readily reversed in the days following the peak of infection, typically by day 9 all mice should have recovered normal core body temperature. Body weight of Pcc-infected male C57BL/6J mice can decrease up to 17–20 g at the peak of infection, corresponding to a loss of 5–8 g (20%–30%) of the initial body weight. Body weight recovery can be observed upon parasite clearance, typically at days 9–10 post-infection. Glycemia of Pcc-infected wild type C57BL/6J mice usually decreases up to 60–100 mg/dL at the peak of infection, corresponding to a loss of 60–120 mg/dL (50%–70%), relative to steady state. This represents a mild hypoglycemia, which is rapidly reversed after the peak of infection. Parasitemia: as described above (including flow cytometry and microscopical analysis). Typically, Pcc infection develops slowly in the first days, gaining momentum around D4-D7, where the percentage of iRBC can reach up to ∼60%. Day 7 of infection is considered the peak of infection, after which parasites start to be cleared from circulation and parasitemia starts to decrease.\nCritical: The values presented here refer to male C57BL/6J mice infected with Pcc AS. These values are expected to vary according to the genetic background of the infected mice18[href=https://www.wicell.org#bib16] as well as in genetically-modified C57BL/6J mice. As an example of the latter, genetic loss-of-function of glucose 6 phosphatase c (G6pc1) specifically in hepatocytes is associated with the development of severe hypoglycemia (<40 mg/dL) as well as defective adaptive thermoregulation (24°C–28°C), leading to death.1[href=https://www.wicell.org#bib1]",
    "Critical: Mice should be monitored at the same time of the day, as some rodent Plasmodium strains, including Pcc, have a highly synchronous 24 h life cycle. This imparts that the parasite develops through the different life-cycle stages under circadian regulation. This in turn implies that disease severity also changes according to the hour of the day, which should be taken into consideration in the experimental design.\nSorting and preparation of iRBCs for single-cell RNA sequencing\nTiming: 3–4 h\nHere we describe how to prepare the iRBCs for single-cell RNA sequencing. This should be performed at the time-point of interest (e.g., when host or parasite present a specific phenotype) as determined by disease progression, as well as by visual observation of Plasmodium parasites in Giemsa-stained blood smears, monitored as described above.\nCritical: RBCs are very sensitive to shear stress. Accordingly, pipetting should be avoided whenever possible. If necessary, pipetting should be performed very gently to avoid damaging the RBC. Cell viability and transcriptional profiles are affected by the time of storage on ice. While parasitemia can be assessed up to 24 h after blood collection, the transcriptional profile might change significantly over time. Accordingly, it is advisable to start the single cell analysis as soon as possible after the sample preparation ideally, within 2 h after cell sorting. Low-binding plasticware is recommended for all the following steps regarding 10× genomics libraries.\nAt the peak of infection (i.e., 6–8 days after inoculation with iRBC), blood is collected by cardiac puncture, as follows:\nTo euthanize mice by CO2 exposure, place the animal in a container, connected to a CO2 source allowing for air plus CO2 gas exchange (e.g., containing a vent that can be opened and closed).",
    "Start with a slow flow rate (3 L/min) of CO2 and an open vent to anaesthetize the mouse.\nClose the vent once the mouse is anaesthetized and increase the flow rate (7 L/min) until no breathing of the mouse is observed.\nNote: Euthanasia can be induced in different ways, for example by Ketamine/Xylazine. It should, however, be consistent between experiments to avoid variability.\nConfirm death by squeezing the hind paw. If there is no reaction proceed immediately with the cardiac puncture.\nPrior to the cardiac puncture, coat a 1 mL syringe with 0.5 M EDTA (RT), by filling the syringe with EDTA (without the needle) and then placing the needle (23G) on the syringe to eject the EDTA back into the original flask. The residual EDTA in the syringe and needle is enough to avoid blood clotting.\nPerform cardiac puncture according to previously described methods.3[href=https://www.wicell.org#bib3]\nTransfer blood into a polystyrene tube (1.5 mL) and place it on ice. Sorting should be started as soon as possible but not later than 1h after blood collection.\nPrior to sorting, confirm parasitemia, as described in the preparation of Pcc infection.\nDilute blood 1/75 vol/vol in PBS (1×) supplemented with FBS (1%). Prepare the dilution in a FACS tube to avoid multiple pipetting steps.\nNote: Cut the end of the pipette tip when pipetting blood to avoid RBC lysis. When using a 70 μm nozzle for cell sorting, RBC concentration must be adjusted to ensure the threshold rate is not higher than 22,000 events per second.\nSort iRBCs according to FSC-A, SSC-A and GFP signals, as detailed above for parasitemia determination.\nCollect sorted cells into polystyrene tubes (15 mL) containing 1 mL PBS (1×) supplemented with FBS (1%) to minimize cell lysis.",
    "Adjust the sensitivity of the FSC and SSC detectors to clearly visualize RBCs in the scatter plot. Define a region that includes RBCs but excludes white blood cells and debris (Figure 1[href=https://www.wicell.org#fig1]).\nDisplay the RBCs in a new plot with FSC-A vs. FSC-H and/or FSC-A vs. FSC-W to exclude doublets, which have a higher, disproportional area, when compared with the second parameter.\nOn a third bivariate plot, visualize the GFP fluorescence of the “singlet” events previously gated out of the blue laser (using a BP530/30 optical filter), against an empty detector on the yellow region out of the violet, blue or yellow green lasers (using a BP586/15 optical filter).\nIdentify the GFP+ events and define the region of the iRBC, excluding cell autofluorescence, which can be visualized in the empty detector.\nUse the defined gate to sort iRBCs using a Purity sorting mode.\nCritical: Do not set the sorting gate in a histogram plotting GFP signal, as this may lead to contamination of the sorted sample with GFP– cells.\nTo obtain an adequate number (> 1.5 × 106) of iRBC, sort samples for at least 30 min.\nCentrifuge samples at 300 × g, 4°C, 5 min. Pellet should resemble the one illustrated in Figure 5[href=https://www.wicell.org#fig5].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2918-Fig5.jpg\nFigure 5. Illustration of the sample before counting the cells\nDiscard the supernatant into a waste bin by inverting the tube. Avoid aspirating the supernatant by a vacuum pump as this can increase RBC loss.\nWash the sample by adding cold PBS (1×, 2 mL).\nRe-suspend the RBC pellet by inverting and flicking the tube. In case pipetting is needed, use a 1000 μL pipette and cut the pipette tip so that the opening is wider.\nRepeat step 7–8 once.\nResuspend the cells in PBS (1×; 1 mL)",
    "Count RBC using a Neubauer counting chamber (Figure 6[href=https://www.wicell.org#fig6]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2918-Fig6.jpg\nFigure 6. Neubauer chamber with iRBCs under the microscope\nMagnification 20×.\nPrepare the Neubauer chamber by placing a glass cover on the chamber.\nAdd the cell suspension (10 μL) on one edge of the glass cover, so that the liquid fills the chamber through capillarity. If air bubbles occur, disassemble the Neubauer chamber, clean it with ethanol (75%) and repeat the above-described steps.\nPlace the chamber under the microscope and count the cells of the 4 large corner squares.\nThe total number of RBC is calculated as follows:\nC\ne\nl\nl\ns\n/\nm\nL\n=\nT\no\nt\na\nl\nn\nu\nm\nb\ne\nr\no\nf\nc\no\nu\nn\nt\ne\nd\nc\ne\nl\nl\ns\nx\n10.000\nN\nu\nm\nb\ne\nr\no\nf\ns\nq\nu\na\nr\ne\ns\nc\no\nu\nn\nt\ne\nd\nRepeat step 7–8 and re-suspend the sample in cold PBS (1×) to reach a final concentration of 1200 cells/μL.\n10× genomics single-cell sequencing of iRBC\nTiming: 3.5 days\nThe workflow, from cell encapsulation to library construction, is executed according to the recommended user guide (CG000204 Rev D – Single Index; https://www.10xgenomics.com/support/single-cell-gene-expression/documentation/steps/library-prep/chromium-single-cell-3-reagent-kits-user-guide-v-3-1-chemistry[href=https://www.10xgenomics.com/support/single-cell-gene-expression/documentation/steps/library-prep/chromium-single-cell-3-reagent-kits-user-guide-v-3-1-chemistry]) retrieved on January 10th 2023.\nAdd the cell suspension (13.8 μL) to the prepared master mix (according to the user guide), keep on ice, to target a recovery of >10,000 cells (13.8 μL x 1200 cells/μL).\nLoad the master mix containing the cells, the unique molecular identifier (UMI) and partition oil onto Chromium Next GEM Chip G (Chromium™ Single Cell Controller running Firmware 5.0 10× Genomics, PN-120263).\nPerform reverse transcription of RNA into cDNA.",
    "Analyze the cDNA profile on a Fragment Analyzer System (Agilent Technologies) according to the High Sensitivity NGS Fragment kit instructions (Agilent Technologies).\nNote: This step is a crucial quality control for all subsequent procedures. The number of PCR cycles for cDNA amplification are adjusted according to the input cDNA mass on 10 μL of the total reaction, avoiding overamplification and possible artifacts. Library quality profile is also verified on the same instrument for both size determination and library quantification.\nSequence with NextSeq 500 (Illumina) using the NextSeq 500/550 High Output Kit v2.5 (150 Cycles) using a final diluted pool 1.8 pM with the following sequencing run settings: Read1: 28 cycles, i7 index: 8 cycles, i5 index: 0 cycles, Read2: 130 cycles, aiming a read depth of ∼25,000 reads/cell.\nIncrease Read2 from the recommended 91 cycles to 130 due to cycle availability of the kit and to increase the mapping of the read to the reference transcriptome.\nAnalysis of scRNA-Seq data\nTiming:  > 2 weeks\nHere we describe how to analyze the single-cell RNA sequencing data obtained with the protocol described above. In this section, the protocol starts by importing the filtered feature-barcode matrices, bad-quality cells and non-expressed genes are excluded, and the processed data is clustered into transcriptionally similar populations and projected onto the low-dimensional space. The cell populations identified are confirmed by inspecting conserved markers identified through differential gene expression (DGE).",
    "Note: Sequence alignment: Feature Count Matrix is created using Cellranger V7.0.0 (10× Genomics) with STAR aligner V2.7.9a on an Ubuntu virtual machine. The reference genome of Pcc and annotation (Ensembl ftp://ftp.ensemblgenomes.org/pub/protists/release-50/protists/) is used for alignment through the \"mkref\" command from the Cellranger analysis pipeline. Raw reads from each sample and the reference genome prepared on the previous step were processed with the \"cellranger count\" pipeline resulting in the Counts Matrix for each sample. All the steps are performed following standard best practices from 10× Genomics (https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger[href=https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger]). QC, filtering and exploratory clustering, dimensional reduction and DEG: All following analyses are performed in a virtual machine with 10 cores and 64 GB of RAM running Ubuntu 18. All the R code are run in RStudio Server (v. 2022.07.1 Build 554) using R version 3.6.311[href=https://www.wicell.org#bib10] as Rmarkdown notebooks (v.2.519[href=https://www.wicell.org#bib17],20[href=https://www.wicell.org#bib18]). Code described herein to perform data analyses was deposited in the following github repository: https://github.com/inflammationlab/scRNAseq-malaria-STAR-protocol[href=https://github.com/inflammationlab/scRNAseq-malaria-STAR-protocol] in the hope of making analyses reproducible and reusable as well as to simplify the descriptions made herein which will be circumscribed to the most important steps for readability.\nSingle-cell analyses in R are performed using the Seurat package (v.4.0.08[href=https://www.wicell.org#bib7]). The Seurat package is forked and the ‘DESCRIPTION’ file modified (see: https://github.com/antonioggsousa/seurat/commit/3a9e57b499e9e417f09da3ebb0aeaa4cedfb9ef8[href=https://github.com/antonioggsousa/seurat/commit/3a9e57b499e9e417f09da3ebb0aeaa4cedfb9ef8]) to install Seurat v.4.0.0 in R v.3.6.3. The installation is performed after launching the R console as follows:\n> devtools::install_github(“antonioggsousa/seurat”)\nEach single-cell sample, hereby labeled as gt1 and gt2, are analyzed independently and the differences in parameters are highlighted be.\nImport the three files - ‘barcodes.tsv.gz’, ‘features.tsv.gz’, ‘matrix.mtx.gz’ - under the output folder ‘filtered_feature_bc_matrix’ comprising the filtered feature-barcode matrices MEX obtained in the previous step as a sparse matrix which was in turn converted into a S4 Seurat object. This step is done using two Seurat (v.4.0.08[href=https://www.wicell.org#bib7];) functions as described below:",
    ">set.seed(seed = 1024) # to keep reproducibility\n>library(\"Seurat\", quietly = TRUE) # import package\n# import 10x Gt1 sample\n>gt1_sample_dir <- \"../data/ftp01.igc.gulbenkian.pt/gt1_count_full/outs/filtered_feature_bc_matrix\"\n>gt1 <- Read10X(data.dir = gt1_sample_dir)\n>gt1_seu <- CreateSeuratObject(counts = gt1, project = \"Gt1\", min.cells = 3) # create Seurat object\n# import 10x Gt2 sample\n>gt2_sample_dir <- \"../data/ftp01.igc.gulbenkian.pt/Gt2_count_full/outs/filtered_feature_bc_matrix\"\n>gt2 <- Read10X(data.dir = gt2_sample_dir)\n>gt2_seu <- CreateSeuratObject(counts = gt2, project = \"Gt2\", min.cells = 3) # create Seurat object\nRemove genes expressed in less than three cells (‘CreateSeuratObject(..., min.cells = 3’)).\nInspected different single-cell data features in terms of the number of total UMIs (Unique Molecular Identifiers) or different number of genes expressed per cell.\nRemove Cells expressing less than 750 different genes or 1,500 UMIs.\n>params <- list(\"max_nFeature\" = 750, \"max_nCount\" = 1500) # parameters to apply the filtering\n>gt1_seu <- subset(gt1_seu, subset = nFeature_RNA < params$max_nFeature & nCount_RNA < params$max_nCount) # apply the filtering\n>gt2_seu <- subset(gt2_seu, subset = nFeature_RNA < params$max_nFeature & nCount_RNA < params$max_nCount)",
    "Note: By looking into its distribution, e.g., using the function ‘VlnPlot(gt1_seu, features = c(\"nFeature_RNA\", \"nCount_RNA\"))’, and their linear relationship, e.g., plotting ‘FeatureScatter(gt1_seu, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")’ other cell features that might indicate cell integrity are often used as well as filtering criteria such as the percentage of expression of mitochondrial and/or ribosomal genes.21[href=https://www.wicell.org#bib19] These features were not considered in this protocol as they are difficult to disentangle from the distinct life-cycle stages where the variation in gene expression of mitochondrial/ribosomal genes is likely to happen. These thresholds fit above the upper whisker (outliers) when the distribution of these features is plotted, likely representing doublets or multiples. Cells expressing low number of genes or UMIs might represent non-intact cells, dying cells or cells with broken membranes, and they should be excluded as well at this stage (e.g., ‘subset(gt1_seu, subset = nFeature_RNA > 100 & nCount_RNA > 150)’). As the number of genes detected and UMIs obtained for the different Plasmodium life-cycle stages diverges,22[href=https://www.wicell.org#bib20] and smaller cells have lower mRNA content23[href=https://www.wicell.org#bib21] thresholds may not be applied or applied with caution as they may exclude resting, less active stages. The thresholds applied always need to be adapted to each study by looking into the distribution of the different cell features.\nFiltered gene expression count tables are normalized with the function: ‘NormalizeData()’ using the ‘normalization.method = \"LogNormalize\"’ and ‘scale.factor = 10000’.\n>gt1_seu <- NormalizeData(gt1_seu, normalization.method = \"LogNormalize\", scale.factor = 10000)\n>gt2_seu <- NormalizeData(gt2_seu, normalization.method = \"LogNormalize\", scale.factor = 10000)\nSelect the top 750 highly variable features across the datasets with the function ‘FindVariableFeatures()’ using the following parameters: ‘selection.method = \"vst\"’ and ‘nfeatures = 750’.\n> gt1_seu <- FindVariableFeatures(gt1_seu, selection.method = \"vst\", nfeatures = 750) # find variable features\n>gene_names <- rownames(gt1_seu) # retrieve gene names 4554",
    ">gt1_seu <- ScaleData(object = gt1_seu, features = gene_names) # run scaling\n>gt2_seu <- FindVariableFeatures(gt2_seu, selection.method = \"vst\", nfeatures = 750) # find variable features\n>gene_names <- rownames(gt2_seu) # retrieve gene names 4554\n>gt2_seu <- ScaleData(object = gt2_seu, features = gene_names) # run\nNote: Usually, 2k features are chosen for data sets with more than 10k genes, which represents less than 20% of the genes. Therefore, 750 variable features are chosen to represent ∼16% of all variable features for Pcc samples. Then all the features are scaled with the ‘ScaleData()’ function.\nA Principal Component Analysis (PCA) is performed using the scaled top highly variable genes with the function ‘RunPCA()’. This PCA is in turn used to cluster and build the non-linear Uniform Manifold Approximation and Projection (UMAP) later.\n> gt1_seu <- RunPCA(object = gt1_seu, features = VariableFeatures(object = gt1_seu)) # run PCA\n>gt2_seu <- RunPCA(object = gt2_seu, features = VariableFeatures(object = gt2_seu)) # run PCA\nThe importance of the different principal component regarding the contribution of variance is inspected through an elbow plot and based on the result the top 10 PCs were selected for clustering and UMAP projection (Figure 7[href=https://www.wicell.org#fig7]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2918-Fig7.jpg\nFigure 7. Representative elbow plot\nShowing the relationship of the (standard) variation across the first 50 principal components.\n>library(“ggplot2”)\n>elbow_plot <- ElbowPlot(gt1_seu, ndims = 50) +\ntheme_minimal() +\ngeom_vline(xintercept = 10, linetype = \"dashed\") +\ntheme(axis.text = element_text(size = 14, color = \"black\"),\naxis.title = element_text(size = 14, color = \"black\"),\n  text = element_text(size = 14, color = \"black\")) +\nannotate(\"rect\", xmin = 0, xmax = 10, ymin = 0, ymax = 10,\nalpha = .25, fill = \"#E64B35FF\") +\nannotate(geom = \"text\", x = 5, y = 7.5, label = paste0(\"10\nPCs\"), size = 4.5, color = \"blue\")\n>print(elbow_plot) # print\n>elbow_plot <- ElbowPlot(gt2_seu, ndims = 50) +",
    "theme_minimal() +\ngeom_vline(xintercept = 10, linetype = \"dashed\") +\ntheme(axis.text = element_text(size = 14, color = \"black\"),\naxis.title = element_text(size = 14, color = \"black\"),\ntext = element_text(size = 14, color = \"black\")) +\nannotate(\"rect\", xmin = 0, xmax = 10, ymin = 0, ymax = 10,\nalpha = .25, fill = \"#E64B35FF\") +\nannotate(geom = \"text\", x = 5, y = 7.5, label = paste0(\"10\nPCs\"), size = 4.5, color = \"blue\")\n>print(elbow_plot) #\nUse the first 10 PCs for clustering with ‘FindNeighbors()’ based on the plots described in the previous section.\nUse the following values of resolution with the function ‘FindClusters()’: 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.55, 0.60.\nCreate a UMAP using the function ‘RunUMAP()’ using the first 10 PCs.\nNote: Resolution is one important parameter and crucial to determine the number of clusters obtained.\n## Gt1 sample\n>set.seed(1024)\n>gt1_seu <- FindNeighbors(gt1_seu, dims = 1:10)\n>res_2_iter <- seq(0.2,0.6, by = 0.05) # resolutions to test\n# iterate over the different resolutions and return a list of Seurat objects to work with\n>gt1_seu_list <- list()\n>for ( res in res_2_iter ) {\n  seu <- paste0(\"gt1_seu_\", res)\n  set.seed(1024)\n  gt1_seu_list[[seu]] <- FindClusters(gt1_seu, resolution = res)\n}\n# check how many clusters by resolution\n>no_clusters <- lapply(gt1_seu_list, function(x) {\nlength(levels(x$seurat_clusters))\n})\n>clust_df <- data.frame(\"Seurat_obj\" = names(gt1_seu_list),\n            \"Resolution\" = res_2_iter,\n            \"No_clusters\" = unlist(no_clusters))\n# iterate over the list\n>gt1_seu_umap <- list()\n>for ( seu in names(gt1_seu_list) ) {\nset.seed(1024)\n  gt1_seu_list[[seu]] <- RunUMAP(gt1_seu_list[[seu]], dims = 1:10)\n  gt1_seu_umap[[seu]] <- DimPlot(gt1_seu_list[[seu]], reduction = \"umap\", label = TRUE) +\nggtitle(paste0(\"Resolution: \", clust_df[clust_df$Seurat_obj == seu, \"Resolution\"]))\n}\n## Gt2 sample\n>set.seed(1024)\n>gt2_seu <- FindNeighbors(gt2_seu, dims = 1:10)\n>res_2_iter <- seq(0.2,0.6, by = 0.05) # resolutions to test\n# iterate over the different resolutions and return a list of Seurat objects to work with\n>gt2_seu_list <- list()",
    ">for ( res in res_2_iter ) {\n  seu <- paste0(\"gt2_seu_\", res)\n  set.seed(1024)\n  gt2_seu_list[[seu]] <- FindClusters(gt2_seu, resolution = res)\n}\n# check how many clusters by resolution\n>no_clusters <- lapply(gt2_seu_list, function(x) {\nlength(levels(x$seurat_clusters))\n})\n>clust_df <- data.frame(\"Seurat_obj\" = names(gt2_seu_list),\n            \"Resolution\" = res_2_iter,\n            \"No_clusters\" = unlist(no__clusters))\n># iterate over the list\n>gt2_seu_umap <- list()\n>for ( seu in names(gt2_seu_list) ) {\n  set.seed(1024)\n  gt2_seu_list[[seu]] <- RunUMAP(gt2_seu_list[[seu]], dims = 1:10)\n  gt2_seu_umap[[seu]] <- DimPlot(gt2_seu_list[[seu]], reduction = \"umap\", label = TRUE) +\nggtitle(paste0(\"Resolution: \", clust_df[clust_df$Seurat_obj == seu, \"Resolution\"]))\n}\n# retrieve the seurat object to work with\n>gt1_seu <- gt1_seu_list$gt1_seu_0.35\n>gt2_seu <- gt2_seu_list$gt2_seu_0.4\nSelect the resolution values, e.g., 0.35 and 0.4 for gt1 and gt2, respectively, and the corresponding clustering are used downstream.\nNote: At this stage, the processed samples can be submitted to a doublet identification algorithm, such as DoubletFinder,24[href=https://www.wicell.org#bib22] in order to remove potential doublets (for instructions see the documentation at: https://github.com/chris-mcginnis-ucsf/DoubletFinder[href=https://github.com/chris-mcginnis-ucsf/DoubletFinder]).24[href=https://www.wicell.org#bib22] As the identification of doublets generated from transcriptionally similar cell subtypes - homotypic doublets - is challenging, this step should be applied with caution depending on the type of data being analyzed, particularly, if it includes multicellular stages as found with Plasmodium. In this protocol, a more conservative approach is followed and, thus, doublet identification and removal is not performed at the cost of keeping some potential doublets.\nApply the function ‘FindAllMarkers()’ to find positive and negative markers for all with the following options: minimum percentage of cells that a gene needs to be expressed (‘min.pct = 0.25’) and a log2 fold change threshold of 0.25 (‘logfc.threshold = 0.25’). The same function is used for positive markers (‘only.pos = TRUE’).\n## Gt1 sample\n# retrieve all the markers\n>set.seed(1024)\n>gt1_markers_all <- FindAllMarkers(gt1_seu, min.pct = 0.25,\nlogfc.threshold = 0.25)\n# retrieve only positive markers\n>set.seed(1024)\n>gt1_markers_pos <- FindAllMarkers(gt1_seu, only.pos = TRUE,",
    "min.pct = 0.25, logfc.threshold = 0.25)\n## Gt2 sample\n# retrieve all the markers\n>set.seed(1024)\n>gt2_markers_all <- FindAllMarkers(gt2_seu, min.pct = 0.25,\nlogfc.threshold = 0.25)\n# retrieve only positive markers\n>set.seed(1024)\n>gt2_markers_pos <- FindAllMarkers(gt2_seu, only.pos = TRUE,\nmin.pct = 0.25, logfc.threshold = 0.25)\nExport the main R objects to continue the analyses below.\n## Gt1 sample\n# create dir\n>r_objs_folder <- \"../results/gt1/R_objects\"\n>if( ! dir.exists(r_objs_folder) ) dir.create(r_objs_folder)\n# save R objects\n>saveRDS(object = gt1_seu, file = paste(r_objs_folder,\n\"gt1_seu.rds\", sep = \"/\"))\n## Gt2 sample\n# create dir\n>r_objs_folder <- \"../results/gt2/R_objects\"\n>if( ! dir.exists(r_objs_folder) ) dir.create(r_objs_folder)\n# save R objects\n>saveRDS(object = cre3_seu, file = paste(r_objs_folder, \"cre3_seu.rds\", sep = \"/\"))\nNote: To integrate, cluster, perform dimensional reduction, DEG and functional enrichment the next section continues by importing the processed data to integrate the two samples in order to harmonize/align shared cell types across conditions. The result is an integrated data set which is then used to identify and visualize cell populations through unsupervised clustering and projection onto the low-dimensional space, respectively. Finally, DGE between cell populations and across conditions is performed to identify conserved cluster markers and genes affected by the condition, respectively. The functions enriched based on the list of differentially expressed genes found are explored. The integration method performed is the Seurat CCA (Canonical Correlation Analysis).\nImport the objects produced above.\n# Import packages\n>library(\"dplyr\", quietly = TRUE)\n>library(\"Seurat\", quietly = TRUE)\n>library(\"ggplot2\", quietly = TRUE)\n>library(\"tidyr\", quietly = TRUE)\n# Import Seurat objects of Gt2 and Gt1\n>gt2_seu <- readRDS(file = \"../results/gt2/R_objects/gt2_seu.rds\")\n>gt1_seu <- readRDS(file = \"../results/gt1/R_objects/gt1_seu.rds\")\n>seu_list <- list(\n  \"gt2\" = gt2_seu,\n  \"gt1\" = gt1_seu\n)\nNormalize both samples with ‘NormalizeData()’ and variable features determined with ‘FindVariableFeatures()’ using the ‘vst’ method (‘selection.method = \"vst\"’) with the top 750 most highly variable features.\nIntegrated features are selected with ‘SelectIntegrationFeatures()’.",
    "## Normalization and Feature selection independently for each data set\n>params <- list(n_var_features = 750) # list of parameters to use throughout the analysis\n>seu_list <- lapply(X = seu_list, FUN = function(x) { # apply norm & var\n  x <- NormalizeData(x)\n  x <- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = params$n_var_features)\n})\n# select features that are variable across both data sets\n>params[[\"var_features\"]] <- SelectIntegrationFeatures(object.list = seu_list)\nPerform integration with ‘IntegrateData()’ by finding shared anchors across samples with ‘FindIntegrationAnchors()’ using the integrated variable features from before.\nScale the integrated data by (‘ScaleData()’), PCA (‘RunPCA()’) and UMAP (‘RunUMAP()’) (Figure 8[href=https://www.wicell.org#fig8]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2918-Fig8.jpg\nFigure 8. Representative UMAP plot of integrated Pcc samples\nAdapted from Ramos, Ademolue et al. (2022).1[href=https://www.wicell.org#bib1]\nPerform graph-based clustering with ‘FindNeighbors()’ using the PCA method.\nDefine clusters with ‘FindClusters()’ using a resolution value that yields a similar amount of clusters as in the separate analysis.\n## Find anchors, integrate, cluster, PCA and UMAP\n# find anchors\n>params[[\"anchors\"]] <- FindIntegrationAnchors(\nobject.list = seu_list,\nanchor.features = params[[\"var_features\"]]\n)\n# integrate labels\n>seu <- IntegrateData(anchorset = params[[\"anchors\"]])\n# define default assay, assay integrated\n>DefaultAssay(seu) <- \"integrated\"\n# cluster, PCA and UMAP\n>params[[\"n_pcs\"]] <- 12; params[[\"mth\"]] <- \"pca\"; params[[\"res\"]] <- 0.39;\n>seu <- ScaleData(seu, verbose = FALSE)\n>seu <- RunPCA(seu, npcs = params$n_pcs, verbose = FALSE)\n>seu <- RunUMAP(seu, reduction = params$mth, dims = 1:params$n_pcs)\n>seu <- FindNeighbors(seu, reduction = params$mth, dims = 1:params$n_pcs)\n>seu <- FindClusters(seu, resolution = params$res)\nFind conserved markers across the two samples with the function ‘FindConservedMarkers()’ on the original RNA assay for each independent cluster as follows.\n# Find conserved markers\n# create folder to save conserved markers\n>conserved_markers_folder <- \"../results/int_28_05_21/tables/conserved_markers\"\n>if ( ! dir.exists(conserved_markers_folder) ) dir.create(conserved_markers_folder, recursive = TRUE)\n# change default assay for DGE\n>DefaultAssay(seu) <- \"RNA\"\n# Run conserved markers",
    ">conserved_markers <- list() # to save results into a list\n>clts <- seu@meta.data$seurat_clusters %>% levels(.) # all the clts to loop over\n>for ( clt in clts ) { # loop over the clts and get conserved markers\nclt_name <- paste0(\"clt_\", clt)\n  clt_no <- as.numeric(clt)\n  cell_no_gt1 <- seu@meta.data %>%\n    filter(orig.ident == \"Gt1\" & seurat_clusters == clt) %>%\n    nrow(.)\n  cell_no_gt2 <- seu@meta.data %>%\n    filter(orig.ident == \"Gt2\" & seurat_clusters == clt) %>%\n    nrow(.)\n  if ( (cell_no_gt1 >= 3) & (cell_no_gt2 >= 3) ) {\n    set.seed(1024)\nconserved_markers[[clt_name]] <- FindConservedMarkers(seu, ident.1 = clt_no, grouping.var = \"orig.ident\", verbose = FALSE)\n  write.table(x = cbind(\"Gene_id\" = rownames(conserved_markers[[clt_name]]), conserved_markers[[clt_name]]), file = paste(conserved_markers_folder, paste0(clt_name, \"_conserved_markers.tsv\"), sep = \"/\"), sep = \"∖t\", row.names = FALSE, quote = FALSE)\n}\n## Join conserved markers into one table\n>conserved_markers_tbl <- NULL\n>for ( clt in names(conserved_markers) ) { # loop over clusters\n  sub_df <- conserved_markers[[clt]]\n  col_names <- colnames(sub_df)\n  sub_df[,\"Gene_id\"] <- rownames(conserved_markers[[clt]])\n  sub_df[,\"Cluster\"] <- clt\n  col_order <- c(\"Cluster\", \"Gene_id\", col_names)\n  sub_df <- sub_df[,col_order]\n  # check if colnames match to just rbind\n  if ( is.null(conserved_markers_tbl) ) {\n    conserved_markers_tbl <- sub_df\n  } else {\n    stopifnot( all( colnames(conserved_markers_tbl) == col_order ) )\n    conserved_markers_tbl <- rbind( conserved_markers_tbl, sub_df )\n  }\n}\nUse tables of conserved markers to define clusters identity:\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2918-Fig9.jpg\nFigure 9. UMAP plots showing Pcc stage-specific gene expression\nBased on the expression pattern different clusters are assigned to specific stages of Pcc. Figure reprinted with permission from Ramos, Ademolue et al. (2022).1[href=https://www.wicell.org#bib1]",
    "Note: To understand how the transcriptomes are segregated, enquire their identity in each cluster of conserved markers in both samples. This will allow, for example, ascribing different clusters to different life cycle stages and probe for effects on Plasmodium life cycle progression and development. For this, we relied on the publicly available information on Plasmodium stage specific gene expression to enquire whether the topmost expressed genes per cluster were specifically expressed in a particular stage of the life cycle (Figure 9[href=https://www.wicell.org#fig9]).\nIdentify the top 25 genes expressed in each cluster.\nNote: We found this number to be enough to provide a defined signature of specific blood stages of Plasmodium development. Of note, some transcripts are expressed in most developmental stages, while others are specific for certain stages (e.g., gametocytes). However, the number of genes analyzed to assure a correct ascribing of specific developmental stages to each cluster will depend on each dataset. Most of the publicly available data for Plasmodium stage-specific gene expression, generated from either bulk or single cell RNAseq, refers to P. falciparum, P. vivax or P. berghei in vitro. To analyze the stage-specificity of Pcc gene sets, it is required to find the orthologues in these parasite species. Use available platforms, e.g., PlasmoDB (www.plasmodb.org[href=http://www.plasmodb.org]), to identify P. falciparum or P. berghei. orthologues of the genes of interest. Assess gene expression throughout the Plasmodium life cycle. Use publicly available data to enquire on stage-specificity of gene expression. We found that Malaria Cell Atlas (www.malariacellatlas.org[href=http://www.malariacellatlas.org]) to provide an excellent compilation of gene expression from bulk (smatseq2) or single cell (Chromium 10×) data acquired from different life cycle stages of Plasmodium spp., including P. falciparum or P. berghei.\nConfirm Plasmodium stage-specific gene expression for each cluster.",
    "Critical: Some clusters may have genes expressed typically in different Plasmodium developmental stages, indicating: i) Developmental stage transition (e.g., from rings to trophozoite where ring-stage specific genes are co-expressed with metabolic genes, typically highly expressed in trophozoites); ii) Sexual commitment (e.g., gene expression signature corresponding to asexual stages overlaps with gene signatures associated with parasite sexual commitment, suggesting a transition from merozoites, rings or trophozoites into gametocytes).\nAnalyze differential gene expression (DGE) across samples for each cluster using the function ‘FindMarkers()’.\nUse the identity of the cells belonging to each one of the two samples, Gt2 or Gt1, by cluster to compare genes differentially expressed across each cluster.\nNote: By default, this function uses the method Wilcoxon Rank Sum test on the normalized gene expression data.\n## DGE: Gt2 vs Gt1\n# Add metadata field to hold sample type and cluster id & change the identity to this\n>stopifnot(DefaultAssay(seu) == \"RNA\")\n>seu[[\"treat\"]] <- paste(seu$orig.ident, Idents(seu), sep = \"_\")\n>seu[[\"clusters\"]] <- Idents(seu)\n>Idents(seu) <- seu$treat\n# create folder directory to save files\n>dge_table_folder <- \"../results/int_28_05_21/tables/dge_tables\"\n>if ( ! dir.exists(dge_table_folder) ) dir.create(dge_table_folder)\n# loop over clusters & do DGE for each cluster among samples\n>dge <- list()\n>no_int_clts <- levels(seu$clusters)\n>for ( clt in no_int_clts ) { # loop over cluster\n  cell_no_gt1 <- seu@meta.data %>%\n    filter(orig.ident == \"Gt1\" & clusters == clt) %>%\n    nrow(.)\n  cell_no_gt2 <- seu@meta.data %>%\n    filter(orig.ident == \"Gt2\" & clusters == clt) %>%\n    nrow(.)\n  if ( (cell_no_gt2 >= 3) & (cell_no_gt1 >= 3) ) {\n    clt_name <- paste0(\"clt_\", clt) # name of the current cluster\n    ctrl_cells <- paste0(\"Gt1_\", clt) # control/reference name of the current groups of cells to compare\n    treat_cells <- paste0(\"Cre3_\", clt) # treatment name of the current groups of cells to compare\n    set.seed(1024)",
    "dge[[clt_name]] <- FindMarkers(seu, ident.1 = treat_cells, ident.2 = ctrl_cells, verbose = FALSE) # do dge\n    write.table(x = cbind(\"Geneid\" = rownames(dge[[clt_name]]), dge[[clt_name]]), file = paste(dge_table_folder, paste0(clt_name, \"_Gt2_vs_Gt1_dge_table.tsv\"), sep = \"/\"), sep = \"∖t\", quote = FALSE, row.names = FALSE\n    )\n  }\n}\n# restore Seurat identity to clusters\n>Idents(seu) <- seu$clusters\n## Merge DGE tables in order to plot them below\n>dge_all <- NULL\n>for ( clt in names(dge) ) {\n  sub_df <- dge[[clt]]\n  col_names <- colnames(sub_df)\n  sub_df[,\"Geneid\"] <- rownames(dge[[clt]])\n  sub_df[,\"Cluster\"] <- clt\n  col_order <- c(\"Cluster\", \"Geneid\", col_names)\n  sub_df <- sub_df[,col_order]\n  if ( is.null(dge_all) ) {\n    dge_all <- sub_df\n  } else {\n    stopifnot( all( colnames(sub_df) == colnames(dge_all) ) )\n    dge_all <- rbind(dge_all, sub_df)\n  }\n}\n>write.table(x = dge_all, file = paste(dge_table_folder, \"Cre3_vs_Lox2_dge_table_for_all_clusters.tsv\", sep = \"/\"), sep = \"∖t\", quote = FALSE, row.names = FALSE)\nHighlight the results in volcano plots and heatmaps.\nUse gprofiler2 R package to perform functional enrichment analysis on the differentially expressed genes (i.e., up- and down-regulated) between samples by cluster (v.0.2.07[href=https://www.wicell.org#bib6]), an interface to the g:Profiler web browser tool.\nApply the function ‘gost()’ to perform functional enrichment analysis, based on genes up- or down-regulated, between each pairwise comparison, against the annotated genes (‘domain_scope = “annotated”’) of the organism P. chabaudi (‘organism = \"pchabaudi\"’).\nOrder gene lists by increasing adjusted p-value (‘ordered_query = TRUE’) to generate a GSEA (Gene Set Enrichment Analysis) style p-values.\nNote: This allows to start the enrichment testing from the topmost biological relevant genes with subsequent tests involving larger sets of genes. In addition, only statistically significant (‘user_threshold = 0.05’) enriched functions are returned (‘significant = TRUE’) after multiple testing corrections with the default method g:SCS (‘correction_method = \"g_SCS\"’).",
    "Add evidence codes to the final result (‘evcodes = TRUE’). Functional databases available to P. chabaudi are the following: Gene Ontology (GO or by branch GO:MF, GO:BP, GO:CC), KEGG.\nSubject all the clusters to functional enrichment analysis.\nParse the DGE results for gprofiler2 as follows:\n## Get up and down gene lists and parse them\n>reg_gene_list <- list()\n>for ( clt in names(dge) ) { # select dge by cluster and retrieve name\n  sub_df <- dge[[clt]]\n  sub_df[,\"Geneid\"] <- rownames(sub_df)\n  gene_ids_up <- sub_df %>%\n    filter(p_val_adj < 0.05 & avg_log2FC > 0) %>%\n    arrange(p_val_adj) %>%\n    pull(Geneid)\n  gene_ids_down <- sub_df %>%\n    filter(p_val_adj < 0.05 & avg_log2FC < 0) %>%\n    arrange(p_val_adj) %>%\n    pull(Geneid)\n  reg_gene_list[[clt]] <- list()\n  reg_gene_list[[clt]][[\"up\"]] <- gsub(pattern = \"-\", replacement = \"_\", x = gene_ids_up)\n  reg_gene_list[[clt]][[\"down\"]] <- gsub(pattern = \"-\", replacement = \"_\", x = gene_ids_down)\n}\n# create folders\n>r_object_folder <- \"../results/int_28_05_21/R_objects\"\n>if ( ! dir.exists(r_object_folder) ) dir.create(r_object_folder)\n>func_enrich_folder <- \"../results/int_28_05_21/tables/functional_enrichment\"\n>if ( ! dir.exists(func_enrich_folder) ) dir.create(func_enrich_folder)\nSubmit the list of differentially up- and down-regulated genes by cluster to g:profiler2 as follows:\n### Functional enrichment of DEG\n# Run gprofiler2\n>func_enrich <- list()\n>set_base_url(\"https://biit.cs.ut.ee/gprofiler_archive3/e102_eg49_p15\")\n>for ( clt in names(reg_gene_list) ){ # loop over list and do functional enrichment\n  #print(get_base_url())\n  func_enrich[[clt]] <- list()\n  set.seed(1024)\n  func_enrich[[clt]][[\"up\"]] <- gost(query = reg_gene_list[[clt]][[\"up\"]], organism = \"pchabaudi\", ordered_query = TRUE, multi_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = TRUE, user_threshold = 0.05, correction_method = \"g_SCS\", domain_scope = \"annotated\", custom_bg = NULL, numeric_ns = \"\", sources = NULL)\n  if ( ! is.null(func_enrich[[clt]][[\"up\"]]$result) ) {\n    sub_df_up <- func_enrich[[clt]][[\"up\"]]$result %>%\n    apply(X = ., MARGIN = 2, FUN = function(x) as.character(x))\n    write.table(x = sub_df_up,\n          file = paste(func_enrich_folder, paste0(clt, \"_up_functional_enrichment_table.tsv\"),\n                  sep = \"/\"),\n          quote = FALSE, sep = \"∖t\", row.names = FALSE, col.names = TRUE)\nset.seed(1024)",
    "func_enrich[[clt]][[\"down\"]] <- gost(query = reg_gene_list[[clt]][[\"down\"]], organism = \"pchabaudi\", ordered_query = TRUE, multi_query = FALSE, significant = TRUE, exclude_iea = FALSE, measure_underrepresentation = FALSE, evcodes = TRUE, user_threshold = 0.05, correction_method = \"g_SCS\", domain_scope = \"annotated\", custom_bg = NULL, numeric_ns = \"\", sources = NULL)\n  if ( ! is.null(func_enrich[[clt]][[\"down\"]]$result) ) {\n    sub_df_down <- func_enrich[[clt]][[\"down\"]]$result %>%\n    apply(X = ., MARGIN = 2, FUN = function(x) as.character(x))\n    write.table(x = sub_df_down,\nfile = paste(func_enrich_folder, paste0(clt, \"_down_functional_enrichment_table.tsv\"),\n              sep = \"/\"),\n          quote = FALSE, sep = \"∖t\", row.names = FALSE, col.names = TRUE)\n    }\n}\n# Create R object\n>saveRDS(object = func_enrich, file = paste(r_object_folder, \"func_enrich.rds\", sep = \"/\"))\nThe results were explored through tables and plots.\nThe main integrated object was exported.\n>saveRDS(object = seu, file = paste(r_object_folder, \"seu.rds\", sep = \"/\"))\nExplore the results through tables and plots.\nExport the main integrated object.\nNote: To perform RNA velocity analysis, which uses the ratio of spliced/unspliced transcripts to derive cell state transitions and infers pseudotime and cell trajectory the required inputs need to be obtained. The two input requirements are: spliced/unspliced matrices from the alignment sample files and the UMAP embedding. The result is the inference of cell state transitions projected onto UMAP space that allows to explore the cell development trajectory.\nPerform RNA velocity analysis of scRNA-seq samples of Pcc with RNA by projecting the integrated UMAP obtained with Seurat analysis described above.\nPerforme RNA velocity analysis in two steps, following the guidelines from https://github.com/basilkhuder/Seurat-to-RNA-Velocity[href=https://github.com/basilkhuder/Seurat-to-RNA-Velocity]:\nGenerate the ‘.loom’ file with the spliced and unspliced count matrices\nEstimate the RNA velocity from the spliced and unspliced matrices by using the velocyto (v.0.17.178) CLI (Command-Line Interface) tool and running the bash script:\n> ./velocyto_script.sh &> velocyto_log.log\nThe content of the ‘velocyto_script.sh’ bash script is summarized below:\n## Variables\n# PATH\n>AFS_PATH=/afs/igc.gulbenkian.pt/folders/UBI/PROJECTS/UBI-2021/ongoing/2012_miguel_elisa",
    "# GTF and bam files for Gt2 and Gt1 samples\n>SAMPLES='Gt2 Gt1'\n>bam_gt2=${AFS_PATH}/data/ftp01.igc.gulbenkian.pt/Gt2_count_full/outs/possorted_genome_bam.bam\n>bam_gt1=${AFS_PATH}/data/ftp01.igc.gulbenkian.pt/Gt1_count_full/outs/possorted_genome_bam.bam\n>GTF=${AFS_PATH}/data/ftp01.igc.gulbenkian.pt/Pchabaudi2/genes/genes.gtf\n# activate conda first\n>source /home/agsousa/miniconda3/etc/profile.d/conda.sh\n>conda activate velocyto\n>parallel -v ∖\n  velocyto run10x -@ 8 --samtools-memory 5000 ∖\n  ${AFS_PATH}/data/ftp01.igc.gulbenkian.pt/{}_count_full ∖\n  $GTF ::: $SAMPLES >> velocyto_script.log 2>&1\n>conda deactivate\nProcess both samples in parallel with GNU parallel (v.2016122225[href=https://www.wicell.org#bib23]).\nNote: Sample folders generated with the cellranger pipeline are provided as input, which contain the folder ‘outs’ with the ‘.bam’ alignment file and the filtered barcodes. In addition, the GTF file of Pcc is needed.\nBefore estimating velocities, export the identity of the cells, clusters as well as the UMAP embeddings from the integrated single-cell data to project the velocities. This data is exported in R as follows:\n## Import packages\n>library(\"Seurat\", quietly = TRUE)## Import integrated Seurat object: Gt2 and Gt1\n# import obj integrated\n>seu <- readRDS(file = \"../results/int/R_objects/seu.rds\")\n# Seurat: split objects by sample\n>sobjList <- SplitObject(seu, split.by = \"orig.ident\")\n# dir to save\n>seurat_data <- \"../results/velocyto/seurat_data\"\n>if ( ! dir.exists(seurat_data) ) dir.create(seurat_data, recursive = TRUE)\n# save cell_ids for both samples\n>write.csv(Cells(sobjList$Gt2), file = paste(seurat_data, \"gt2_samp_cellID_obs.csv\", sep = \"/\"), row.names = FALSE)\n>write.csv(Cells(sobjList$Gt1), file = paste(seurat_data, \"gt1_samp_cellID_obs.csv\", sep = \"/\"), row.names = FALSE)\n# save UMAP embeddings for both samples\n>write.csv(Embeddings(sobjList$Gt2, reduction = \"umap\"), file = paste(seurat_data,\"gt2_UMAP_cell_embeddings.csv\", sep = \"/\"))\nwrite.csv(Embeddings(sobjList$Gt1, reduction = \"umap\"), file = paste(seurat_data,\"lox2_UMAP_cell_embeddings.csv\", sep = \"/\"))\nEstimate RNA velocity with the stochastic model option from the spliced and unspliced matrices using the python package scvelo (v.0.2.29) through jupyter notebook.\nProject velocities onto the integrated UMAP embeddings as described below.\n# save cluster information\n>write.csv(sobjList$Gt2@meta.data[,\"seurat_clusters\", drop = FALSE],\n      file = paste(seurat_data,\"gt2_clusters.csv\", sep = \"/\"))\n>write.csv(sobjList$Gt1@meta.data[,\"seurat_clusters\", drop = FALSE],\n      file = paste(seurat_data,\"gt1_clusters.csv\", sep = \"/\"))\n# export the colors used in Seurat UMAP clusters\n# Gt2\n>gt2_umap_colors <- DimPlot(sobjList$Gt2)",
    ">gt2_umap_colors <- ggplot2::ggplot_build(gt2_umap_colors)\n>gt2_umap_colors <- gt2_umap_colors$data[[1]]\n>gt2_umap_colors <- gt2_umap_colors[,\"colour\", drop = FALSE]\n>gt2_umap_colors[,\"cluster\"] <- row.names(sobjList$Gt2@meta.data)\n>write.csv(gt2_umap_colors, file = paste(seurat_data,\"gt2_umap_colors.csv\", sep = \"/\"), row.names = FALSE)\n# Gt1\n>gt1_umap_colors <- DimPlot(sobjList$Gt1)\n>gt1_umap_colors <- ggplot2::ggplot_build(gt1_umap_colors)\n>gt1_umap_colors <- gt1_umap_colors$data[[1]]\n>gt1_umap_colors <- gt1_umap_colors[,\"colour\", drop = FALSE]\n>gt1_umap_colors[,\"cluster\"] <- row.names(sobjList$Gt1@meta.data)\n>write.csv(gt1_umap_colors, file = paste(seurat_data,\"gt1_umap_colors.csv\", sep = \"/\"), row.names = FALSE)\n# Import packages\n>import os\n>import random\n>import anndata\n>import scvelo as scv\n>import pandas as pd\n>import numpy as np\n>import matplotlib as plt\n#%load_ext rpy2.ipython\n# Keep reproducibility\n>random.seed(1024)\n## import loom files\n# path to the loom files\n>gt2_loom_file = \"../data/ftp01.igc.gulbenkian.pt/Gt2_count_full/velocyto/Gt2_count_full.loom\"\n>gt1_loom_file = \"../data/ftp01.igc.gulbenkian.pt/Gt1_count_full/velocyto/Gt1_count_full.loom\"\n>sample_gt2 = anndata.read_loom(gt2_loom_file)\n>sample_gt1 = anndata.read_loom(gt1_loom_file)\n## parse cell ids from loom files to match the Seurat cell ids\n# gt2\n>cell_ids_gt2 = sample_gt2.obs_names.to_list()\n# remove the prefix 'Gt2_count_full:' and sufix 'x' from the cell ids of the loom file\n# add the sufix \"-1_1\"\n>cell_ids_gt2_parsed = [ cell[16:32] + \"-1_1\" for cell in cell_ids_gt2 ]\n>sample_gt2.obs_names = cell_ids_gt2_parsed\n# gt1\n>cell_ids_gt1 = sample_gt1.obs_names.to_list()\n# remove the prefix 'Gt1_count_full:' and sufix 'x' from the cell ids of the loom file\n# add the sufix \"-1_2\"\n>cell_ids_gt1_parsed = [ cell[16:32] + \"-1_2\" for cell in cell_ids_gt1 ]\n>sample_gt1.obs_names = cell_ids_gt1_parsed\n## import seurat metadata\n# cell ids\n>seurat_data = \"../results/velocyto/seurat_data\"\n>sample_gt2_obs = pd.read_csv(seurat_data + \"/\" + \"gt2_samp_cellID_obs.csv\")\n>sample_gt1_obs = pd.read_csv(seurat_data + \"/\" + \"gt1_samp_cellID_obs.csv\")\n## import umap embeddings\n>umap_cord_gt2 = pd.read_csv(seurat_data + \"/\" + \"gt2_UMAP_cell_embeddings.csv\")\n>umap_cord_gt1 = pd.read_csv(seurat_data + \"/\" + \"gt1_UMAP_cell_embeddings.csv\")\n## import cell_clusters\n>cell_clusters_gt2 = pd.read_csv(seurat_data + \"/\" + \"gt2_clusters.csv\")\n>cell_clusters_gt1 = pd.read_csv(seurat_data + \"/\" + \"gt1_clusters.csv\")\n## filter loom files based on Seurat cell ids (filtered)\n>sample_gt2 = sample_gt2[np.isin(sample_gt2.obs.index, sample_gt2_obs[\"x\"])] # 15543 cells to 15537\n>sample_gt1 = sample_gt1[np.isin(sample_gt1.obs.index, sample_gt1_obs[\"x\"])] # 5204 cells to 5176\n### Parse data\n## rename column\n# Gt2\n>sample_gt2_index = pd.DataFrame(sample_gt2.obs.index)",
    ">sample_gt2_index = sample_gt2_index.rename(columns = {0:'Cell ID'})\n# Gt1\n>sample_gt1_index = pd.DataFrame(sample_gt1.obs.index)\n>sample_gt1_index = sample_gt1_index.rename(columns = {0:'Cell ID'})\n# rename column from UMAP df\n>umap_cord_gt2 = umap_cord_gt2.rename(columns = {'Unnamed: 0':'Cell ID'})\n>umap_cord_gt1 = umap_cord_gt1.rename(columns = {'Unnamed: 0':'Cell ID'})\n# merge UMAP and index data\n>umap_ordered_gt2 = sample_gt2_index.merge(umap_cord_gt2, on = \"Cell ID\")\n>umap_ordered_gt1 = sample_gt1_index.merge(umap_cord_gt1, on = \"Cell ID\")\n# remove 1st 'Cell ID' column and add UMAP coordinates\n# Gt2\n>umap_ordered_gt2 = umap_ordered_gt2.iloc[:,1:]\n>sample_gt2.obsm['X_umap'] = umap_ordered_gt2.values\n# Gt1\n>umap_ordered_gt1 = umap_ordered_gt1.iloc[:,1:]\n>sample_gt1.obsm['X_umap'] = umap_ordered_gt1.values\n## add cluster colors\n# Gt2\n>cell_clusters_gt2 = cell_clusters_gt2.rename(columns = {'Unnamed: 0':'Cell ID'})\n>cluster_ordered_gt2 = sample_gt2_index.merge(cell_clusters_gt2, on = \"Cell ID\")\n>cluster_ordered_gt2 = pd.Series(cluster_ordered_gt2['seurat_clusters'].apply(str).values, index = cluster_ordered_gt2['Cell ID'])\n#cluster_ordered_gt2 = cluster_ordered_gt2.iloc[:,1:]\n>sample_gt2.obs['clusters'] = cluster_ordered_gt2\n>sample_gt2.obs['clusters'] = sample_gt2.obs['clusters'].astype('category')\n>sample_gt2.uns['Cluster_colors'] = cluster_ordered_gt2.values\n# Gt1\n>cell_clusters_gt1 = cell_clusters_gt1.rename(columns = {'Unnamed: 0':'Cell ID'})\n>cluster_ordered_gt1 = sample_gt1_index.merge(cell_clusters_gt1, on = \"Cell ID\")\n>cluster_ordered_gt1 = pd.Series(cluster_ordered_gt1['seurat_clusters'].apply(str).values, index = cluster_ordered_gt1['Cell ID'])\n#cluster_ordered_gt1 = cluster_ordered_gt1.iloc[:,1:]\n>sample_gt1.obs['clusters'] = cluster_ordered_gt1\n>sample_gt1.obs['clusters'] = sample_gt1.obs['clusters'].astype('category')\n>sample_gt1.uns['Cluster_colors'] = cluster_ordered_gt1.values\n## RNA velocity\n# define colors for both\n>color = [\"#F8766D\", \"#D39200\", \"#93AA00\", \"#00BA38\", \"#00C19F\", \"#00B9E3\", \"#619CFF\", \"#DB72FB\", \"#FF61C3\"]\n# Gt2\n>scv.set_figure_params(facecolor=\"white\", figsize=(8, 8))\n>random.seed(1024)\n>scv.pp.filter_and_normalize(sample_gt2)\n>scv.pp.moments(sample_gt2)\n>scv.tl.velocity(sample_gt2, mode = \"stochastic\")\n>scv.tl.velocity_graph(sample_gt2)\n>scv.set_figure_params(facecolor=\"white\", figsize=(8, 8), fontsize = 10, dpi = 100, dpi_save = 300)\n>scv.pl.velocity_embedding(sample_gt2, basis = 'umap', arrow_size = 30, arrow_length = 3, save = \"gt2_RNA_velocity_cells_UMAP.svg\")\n>scv.pl.velocity_embedding_stream(sample_gt2, layer=['velocity'], palette = color, size = 30, save = 'gt2_RNA_velocity_stream_UMAP.svg')\n# Gt1\n>scv.set_figure_params(facecolor=\"white\", figsize=(8, 8))\n>random.seed(1024)\n>scv.pp.filter_and_normalize(sample_gt1)\n>scv.pp.moments(sample_gt1)\n>scv.tl.velocity(sample_gt1, mode = \"stochastic\")\n>scv.tl.velocity_graph(sample_gt1)\n>scv.set_figure_params(facecolor=\"white\", figsize=(8, 8), fontsize = 10, dpi = 100, dpi_save = 300)\n>scv.pl.velocity_embedding(sample_gt1, basis = 'umap', arrow_size = 30, arrow_length = 3, save = \"gt1_RNA_velocity_cells_UMAP.svg\")\n>scv.pl.velocity_embedding_stream(sample_gt1, layer=['velocity'], size = 30, palette = color,save = 'lox2_RNA_velocity_stream_UMAP.svg')"
  ],
  "subjectAreas": [
    "Rnaseq",
    "Sequence Analysis",
    "Bioinformatics",
    "Health Sciences",
    "Microscopy",
    "Flow Cytometry",
    "Microbiology",
    "Sequencing",
    "Single Cell"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology",
    "Bioengineering & Technology"
  ]
}