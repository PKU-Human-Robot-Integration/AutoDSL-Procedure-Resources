{
  "id": 2047,
  "origin_website": "Cell",
  "title": "Processing single-cell RNA-seq datasets using SingCellaR",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nSingCellaR installation\nTiming: 10–20 min\nBefore we begin, the user has to install SingCellaR and other dependency packages. R packages are hosted across multiple repositories, namely Comprehensive R Archive Network (CRAN), Bioconductor, and Github. For a brief introduction, CRAN is the R central software repository for the latest and previous versions of the R distribution and packages. Bioconductor is the R repository to facilitate R packages developed for biological data analysis. GitHub is a commercial repository that hosts services for individuals and teams for software version control and collaboration. The R functions ‘install.packages’, ‘BiocManager::install’, and ‘devtools::install_github’ will be used to install packages from CRAN, Bioconductor, and Github, respectively. Prior to installation, the function ‘if(!require(\"package_name\"))’ will be used to check if the package has already been installed on a computer, and installation will proceed for packages not yet installed on the computer.\nInstall SingCellaR from GitHub by running the following R code:\n> if(!require(devtools)) {\n>    install.packages(\"devtools\")\n> }\n> if(!require(BiocManager)) {\n>    install.packages(\"BiocManager\")\n> }\n> devtools::install_github('supatt-lab/SingCellaR',ref='master',\nrepos=BiocManager::repositories())\nCritical: We tested SingCellaR installation on macOS Mojave and Catalina, and Windows 10.",
    "R version 4 or higher is required with other R packages, as shown in the key resources table[href=https://www.wicell.org#key-resources-table]. SingCellaR incorporates functions from Python (version 3.8) modules that have to be installed as described below. The timing of this step depends on the installation of devtools and Bioconductor packages. Devtools package is an R package to support the installation for other packages that are not yet in a standard package repository, such as CRAN or Bioconductor. R packages, including SingCellaR, usually depend on other R packages (dependencies) to support their full range of functionalities. Therefore, the time to complete the installation depends on the number of dependencies that have to be installed on the computer.\nInstall required python modules by running the following R code:\nModules required for the force-directed graph analysis.\n> library(reticulate)\n> conda_create(\"r-reticulate\", python_version=\"3.8\")\n> py_install(\"fa2\", envname=\"r-reticulate\")\n> py_install(\"networkx\", envname=\"r-reticulate\")\nModule required for doublet removal using Scrublet.\n> py_install(\"Scrublet\",envname=\"r-reticulate\")\nCritical: We tested the fa2 python module for the force-directed graph analysis using Python versions 2.7, 3.6 and 3.8. Using Conda environment is recommended in conjunction with reticulate package. Conda (https://docs.conda.io/en/latest/[href=https://docs.conda.io/en/latest/]) is a virtual environment management system for Python. With Conda, the user can create, remove, and update environments that have different versions of Python packages installed in them. This flexibility is especially helpful on devices in which the user does not have administrative privileges to install Python packages on the device and compile version control for specific packages.\nInstall required R packages by running the following R code:\nharmony – required for data integration using Harmony method (Korsunsky et al., 2019[href=https://www.wicell.org#bib14]).\n> if(!require(harmony)) {\n>    install.packages(\"harmony\")\n> }\nAUCell – required for computing AUCell scores with specified gene signatures (Aibar et al., 2017[href=https://www.wicell.org#bib1]).\n> if(!require(AUCell)) {\n>    BiocManager::install(\"AUCell\")\n> }",
    "doParallel and doRNG – required for parallel processing in AUCell analysis.\n> if(!require(doParallel)) {\n>    install.packages(\"doParallel\")\n> }\n> if(!require(doRNG)) {\n>    install.packages(\"doRNG\")\n> }\nDAseq – required for the analysis of differential abundance (Zhao et al., 2021[href=https://www.wicell.org#bib34]).\n> if(!require(DAseq)) {\n>    devtools::install_github(\"KlugerLab/DAseq\")\n> }\ndestiny – required for the trajectory analysis using diffusion map (Haghverdi et al., 2015[href=https://www.wicell.org#bib8]).\n> if(!require(destiny)) {\n>    BiocManager::install(\"destiny\")}\nmonocle3 – required for the trajectory analysis (Trapnell et al., 2014[href=https://www.wicell.org#bib29]).\n> devtools::install_github('cole-trapnell-lab/monocle3',\nref=\"develop\")\nNote: The destiny package is not available for Bioconductor version 3.13. The user can install this package from GitHub.\n> install_github(\"https://github.com/theislab/destiny\",\nbuild_vignettes=FALSE, dependencies=TRUE)\nOptional: SingCellaR supports multiple dataset integration and batch correction methods including Scanorama (Hie et al., 2019[href=https://www.wicell.org#bib10]), Seurat Canonical Correlation Analysis (CCA) and Reciprocal PCA (RPCA) (Hao et al., 2021[href=https://www.wicell.org#bib9]), Liger with online integrative non-negative matrix factorization (iNMF) (Gao et al., 2021[href=https://www.wicell.org#bib5]), ComBat (Johnson et al., 2007[href=https://www.wicell.org#bib12]) and Limma (Ritchie et al., 2015[href=https://www.wicell.org#bib21]).\nscanorama – required for the data integration. The user can install scanorama using pip command line:\n> pip install scanorama\nSeurat CCA/RPCA – required for the data integration.\n> install.packages(\"Seurat\")\nrliger – required for the data integration.\n> install.packages(\"rliger\")\nComBat – required for the batch removal.\n> if (!requireNamespace(\"BiocManager\", quietly = TRUE))\n                install.packages(\"BiocManager\")\n> BiocManager::install(\"sva\")\nLimma – required for the batch removal.\n> if (!requireNamespace(\"BiocManager\", quietly = TRUE))\n                install.packages(\"BiocManager\")\n> BiocManager::install(\"limma\")\nProcessing scRNA-seq for an individual sample\nTiming: 10–15 min for each sample, depending on the number of cells being analyzed",
    "This step creates a SingCellaR object for each sample and performs quality control (QC) to identify cells that qualify for further downstream analyses. We demonstrate the selection process of high-quality cells using multiple QC plots, data normalization, and identifying highly variable genes. The process starts from reading in the input files for each sample generated directly from the cellranger pipeline. Here, we show an early fetal liver (eFL_1) dataset as an example.\nLoad SingCellaR package into R environment:\n> library(SingCellaR)\n> setwd(\"./SingCellaR_objects\")\nNote: ‘./SingCellaR_objects’ is a local folder for this analysis. The user can change the folder name to a suitable file path in a local computer or server.\nCreate SingCellaR object. SingCellaR object is an extension of the SingleCellExperiment (Amezquita et al., 2020[href=https://www.wicell.org#bib2]) object for storing data generated from single-cell experiments. The R code below shows how to read in the input files for generating the SingCellaR object using the function ‘load_matrices_from_cellranger’. The input files are from the output of the cellranger pipeline version 3.0.1. The folder eFL1 contains input files consisting of cell barcodes (barcodes.tsv.gz), gene features (features.tsv.gz), and matrix (matrix.mtx.gz) containing unique molecular identifier (UMI) counts for gene expression. The user can assign a unique identifier to the sample in this step.\n> data_matrices_dir<-\"./cellranger_output/eFL1/\"\n> eFL_1<-new(\"SingCellaR\")\n> eFL_1@dir_path_10x_matrix<-data_matrices_dir\n> eFL_1@sample_uniq_id<-\"eFL_1\"\n> load_matrices_from_cellranger(eFL_1,cellranger.version = 3)\n> eFL_1\nNow the SingCellaR object – eFL_1 is created.\nCritical: The ‘cellranger.version’ parameter is required to be compatible with the cellranger pipeline output file. The cellranger output file ‘features.tsv.gz’ for gene features is generated from Cell Ranger version 3 and above, whereas version 2 of Cell Ranger creates the file ‘genes.tsv.gz’.",
    "Create cell metadata. Cell metadata will be created. Rows represent cells and columns represent variables. Variables computed in this step include the number of UMIs and detected genes per cell, and percentage of mitochondrial gene expression for each cell.\n> process_cells_annotation(eFL_1, mito_genes_start_with=\"MT-\")\nThe following parameter is required:\nmito_genes_start_with: Gene names starting with ‘MT-’ are used as a set of mitochondrial genes for human and ‘mt-’ for mouse samples.\nNote: The cell metadata can be accessed using the function ‘get_cells_annotation(eFL_1)’ or eFL_1@meta.data[href=https://www.wicell.orgmailto:efl_1@meta.data]. The user can manually add additional information to the columns of the cell metadata.\nVisualize QC matrices. QC matrices computed in step 6 can be explored using the plotting functions:\nHistogram (Figure 1[href=https://www.wicell.org#fig1]A).\n> plot_cells_annotation(eFL_1,type=\"histogram\")\nBoxplot (Figure 1[href=https://www.wicell.org#fig1]B).\n> plot_cells_annotation(eFL_1,type=\"boxplot\")\nPlot of the number of UMIs versus the number of detected genes per cell (Figure 1[href=https://www.wicell.org#fig1]C).\n> plot_UMIs_vs_Detected_genes(eFL_1)\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig1.jpg\nFigure 1. SingCellaR visualization of QC matrices for a single sample\n(A) Histograms show the cell frequency based on the number of UMI counts per cell, the number of detected genes per cell, and the percentage of mitochondrial gene expression per cell. Dashed lines represent the mean.\n(B) The same QC matrices as in (A) but represented using boxplots that show the distribution of cells (dots).\n(C) Scatterplot showing the number of UMI counts per cell (x-axis) and the number of detected genes per cell (y-axis); These panels can be used to determine the cell filtering criteria for selecting high-quality cells. Dashed lines represent the mean of detected genes and UMI counts per cell.",
    "Annotate cell quality, identify expressed genes, and assign cell and gene status into metadata. After visualizing QC matrices in step 7, the user can specify filtering parameters using the observed number of UMIs and detected genes per cell, and percentage of mitochondrial gene expression. The function ‘filter_cells_and_genes’ assigns a new column named IsPassed that will be added into the cell metadata. Cells that pass QC will be annotated as TRUE. Expressed genes will be identified in this step and the column named IsExpress will be added into the gene metadata. Genes expressed above and below the user-defined threshold will be annotated as TRUE or FALSE. Although all original cells and genes are retained in the metadata and gene expression matrix in this step, these annotations will be used to subset cells and expressed genes for further downstream analyses. The number of cells passing QC thresholds will be shown on the R console after running the following code:\n> filter_cells_and_genes(eFL_1,\n                                min_UMIs=1000,\n                                max_UMIs=50000,\n                                min_detected_genes=500,\n                                max_detected_genes=6000,\n                                max_percent_mito=10,\n                                genes_with_expressing_cells = 10,\n                                isRemovedDoublets = FALSE)\nThe following parameters are described:\nmin_UMIs: The lower threshold for UMI counts, above which cells are annotated as high-quality. To be used in conjunction with max_UMIs argument. Default value is 1,000.\nmax_UMIs: The upper threshold for UMI counts, below which cells are annotated as high-quality. To be used in conjunction with min_UMIs argument. Default value is 30,000.\nmin_detected_genes: The lower threshold for the number of expressed genes, above which cells are annotated as high-quality. To be used in conjunction with max_detected_genes argument. Default value is 1,000.\nmax_detected_genes: The upper threshold for the number of expressed genes, below which cells are annotated as high-quality. To be used in conjunction with min_detected_genes argument. Default value is 8,000.",
    "genes_with_expressing_cells: The lower threshold for the number of cells in which a gene is expressed (UMI >=1), above which, the gene will be annotated as expressed. Default value is 10.\nisRemovedDoublets: If set to TRUE (default), doublets will be removed prior to downstream analyses.\nNote: Parameters used for filtering out cells with low quality can be varied across tissues and organs from different datasets. For example, the percentage threshold for mitochondrial gene expression, ‘max_percent_mito’ can be set higher for liver tissues (MacParland et al., 2018[href=https://www.wicell.org#bib15]). The user can use the plotting functions as described above to explore different cut-offs for all samples.\nOptional: In addition, we have incorporated the Scrublet package (Wolock et al., 2019[href=https://www.wicell.org#bib31]) for doublet removal into the latest version of SingCellaR. The user can add the optional step below to detect and exclude doublets:\n> DoubletDetection_with_scrublet(eFL_1)\nNormalize UMI counts. SingCellaR scales UMI counts by normalizing each library size to 10,000 or mean library size.\n> normalize_UMIs(eFL_1, use.scaled.factor = T)\nThe following parameter is required:\nuse.scaled.factor: When set to TRUE, the gene expression values will be multiplied by 10,000 (by default) and normalized against the library size (total UMI counts) of each cell. The user can change the scale factor value using the scale.factor parameter. If set to FALSE, the function will use the mean of library size across all cells as the scale factor.",
    "Critical: Using use.scaled.factor=TRUE is recommended for 10× genomics data. The user should consider specifying use.scaled.factor=FALSE for scRNA-seq data generated from plate-based protocols, e.g., Smart-seq2 (Picelli et al., 2014[href=https://www.wicell.org#bib18]) and TARGET-Seq (Rodriguez-Meira et al., 2019[href=https://www.wicell.org#bib22]). This is because the sequencing depth of scRNA-seq data generated from the plate-based protocols is in the higher ranges compared to 10× genomics data (e.g., from a hundred thousand to millions of reads per cell). Thus, using a scale factor of 10,000 is insufficient and leads to small gene expression values. The user should set use.scaled.factor=FALSE in order to use the mean library size from all single cells as the scale factor.\nIdentify highly variable genes. SingCellaR uses a gamma generalized linear model (GLM) as the fitting method for gene expression and coefficient of variation to identify highly variable genes. The GLM is suitable for modeling log-normal data from a sparse normalized gene expression matrix. A column named IsVarGenes is added to the gene metadata and genes identified as highly variable are annotated as TRUE, while all other genes are annotated as FALSE. The number of genes used to fit in the model and the number of identified variable genes will be shown after running the following code:\n> get_variable_genes_by_fitting_GLM_model(eFL_1,\n                                mean_expr_cutoff = 0.05,\n                                disp_zscore_cutoff = 0.05)\nThe following parameters are required:\nmean_expr_cutoff: The mean normalized expression value, above which, the genes are identified as highly variable. Default value is 0.1.\ndisp_zscore_cutoff: The dispersion of z-score, above which, the genes are identified as highly variable. Default value is 0.1.\nNote: In this step, we used lower cut-off values to increase the number of detected highly variable genes per sample for the downstream analyses.\nSave the R object for further analyses.\n> save(eFL_1, file=\"./eFL_1.SingCellaR.rdata\")",
    "Repeat the analyses for the rest of samples. R codes are available at Zenodo: https://doi.org/10.5281/zenodo.5879071[href=https://doi.org/10.5281/zenodo.5879071].\nPause point: The user can pause the analysis after pre-processing each sample.\nIntegrating biological replicates\nTiming: 15–30 min for each group, 1–2 h for all stages\nThis step integrates the individual R objects from pre-processed biological or technical replicates generated from step 12. Here, we illustrate the integration of two early fetal liver samples collected from two donors (Roy et al., 2021[href=https://www.wicell.org#bib23]).\nLoad SingCellaR package.\n> library(SingCellaR)\nIntegrate pre-processed biological replicates. The user will initialize the integrated SingCellaR class object ‘SingCellaR_Int’ and assign a unique identifier prior to merging two datasets using the ‘preprocess_integration’ function.\n> eFL <- new(\"SingCellaR_Int\")\n> eFL@dir_path_SingCellR_object_files<-\"./\"\n> eFL@SingCellR_object_files=c(\"eFL_1.SingCellaR.rdata\",\n                                    \"eFL_2.SingCellaR.rdata\")\n> preprocess_integration(eFL)\n> eFL\nAnnotate cell quality and expressed genes. Filtering process has been already performed separately for each sample (see step 8), therefore the filtering parameters for this step will be set to include all cells. From the filtering output below, all cells will be retained, after running the following code:\n> filter_cells_and_genes(eFL,\n                                min_UMIs=1000,\n                                max_UMIs=50000,\n                                min_detected_genes=500,\n                                max_detected_genes=6000,\n                                max_percent_mito=10,\n                                isRemovedDoublets = FALSE)\nNormalize and scale UMI counts.\n> normalize_UMIs(eFL, use.scaled.factor = T)\nNote: See step 9 for details of required parameters.\nRegress out confounding factors. The normalized and scaled gene expression values from step 16 will be adjusted by regressing out cell-to-cell variation in gene expression values due to confounding factors (e.g., batch and donor effect). To this end, SingCellaR implements the ‘lmFit’ function from the R package limma (Ritchie et al., 2015[href=https://www.wicell.org#bib21]), SingCellaR provides the ‘remove_unwanted_confounders’ wrapper function to regress out the unwanted source of variation. Here, we will regress out the effects of UMI counts, percentage of mitochondrial gene expression, and donor. Adjusted gene expression will be used for further analyses.\n> remove_unwanted_confounders(eFL,\n    residualModelFormulaStr=\"∼UMI_count+percent_mito+sampleID\")\nThe following parameter is required:",
    "residualModelFormulaStr: The formula format used to regress out confounding factors. The names of variables defined have to be the same as the column names of the cell metadata.\nNote: The user can change the residualModelFormulaStr parameter and perform the following steps down to step 23 (UMAP analysis) to explore the effect on cell clustering by specifying different sets of confounding factors. For example, the user can set residualModelFormulaStr = \"∼UMI_count+percent_mito\" to compare with residualModelFormulaStr = \"∼UMI_count+percent_mito+sampleID\" to explore the effect of sample.\nIdentify highly variable genes. The number of genes used for fitting the GLM model and the number of highly variable genes will be identified after running the following code:\n> get_variable_genes_by_fitting_GLM_model(eFL,\n                                                  mean_expr_cutoff = 0.05,\n                                                  disp_zscore_cutoff = 0.05)\nNote: See step 10 for details of required parameters.\nRemove selected genes. Here, we remove mitochondrial and ribosomal genes from highly variable genes identified from step 18 to avoid the skewed effect of ribosomal and mitochondrial gene expression in downstream analyses. The number of genes that are excluded will be shown after running the following code:\n> remove_unwanted_genes_from_variable_gene_set(eFL,\n        gmt.file = \"./Human_genesets/human.ribosomal-mitochondrial.genes.gmt\",\n        removed_gene_sets=c(\"Ribosomal_gene\",\"Mitochondrial_gene\"))\nNote: The human.ribosomal-mitochondrial.genes.gmt file can be downloaded from Zenodo: https://doi.org/10.5281/zenodo.5879071[href=https://doi.org/10.5281/zenodo.5879071] under the folder Human_genesets.\nVisualize highly variable genes (Figure 2[href=https://www.wicell.org#fig2]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig2.jpg\nFigure 2. Visualization of highly variable genes and UMAP analysis results\n(A) Highly variable genes are identified and shown on the fitted gamma generalized linear model (GLM) plot. Gray dots represent all genes that are used to fit in GLM model. Light blue dots represent genes identified as highly variable genes that pass the gene expression cutoff and are fitted above the general fitted lines (red dashed-line).",
    "(B) The elbow plot represents the proportion of variance (y-axis) captured by the principal component analysis (PCA) and are ranked from PC1 to PC50 (x-axis). This plot can be used to determine the number of PCs to include in the downstream analyses; The first 30 PCs are used in this case.\n(C) The UMAP plot shows the expression of lineage gene sets. Yellow – lymphoid cells; Cyan – myeloid cells; Red – erythroid cells; Purple – megakaryocytic cells; Gray – HSPCs that do not (or lowly) express lineage signature genes.\n(D) The UMAP plot shows identified Louvain clusters.\n> plot_variable_genes(eFL)\nPerform principal component analysis (PCA). To interpret the relationship across single cells, dimensionality reduction methods are required to reduce high dimensionality data to the visualizable two- or three-dimensional space. In PCA, the reduced dimensional space is represented by principal components. The top PCs will capture most of the variance of the dataset. Here, we perform linear dimensionality reduction using PCA and then bring forward the most informative PCs for further nonlinear dimensionality reduction to visualize cells in a two-dimensional space. To this end, highly variable genes identified from steps 18–19 and visualized in step 20 will be used for PCA using the ‘runPCA’ function, a wrapper function for the ‘irlba’ function from the irlba package (http://bwlewis.github.io/irlba/[href=http://bwlewis.github.io/irlba/]).\n> SingCellaR::runPCA(eFL, use.components=50, use.regressout.data = T)\nThe following parameters are required:\nuse.components: The number of principal components (PCs) to estimate. Default value is 50.\nuse.regressout.data: If set to TRUE (default), the adjusted gene expression values from step 17 will be used.",
    "Visualize principal components. The elbow plot is used to determine the number of PCs to be included for further dimensionality reduction analyses (Figure 2[href=https://www.wicell.org#fig2]B). The number of PCs to specify downstream should correspond to the elbow point, used as a cut-off to include PCs that capture most of the biological variations found in the data.\n> plot_PCA_Elbowplot(eFL)\nPerform nonlinear dimensionality reduction analyses. Running nonlinear dimension reduction on all highly variable genes requires high computational resources and processing time. Hence, using identified PCs from step 22 for nonlinear dimension reduction analysis is a standard technique for scRNA-seq analysis. Nonlinear dimension reduction analysis is suitable for capturing cellular heterogeneity (Xiang et al., 2021[href=https://www.wicell.org#bib32]). Here, we use Uniform Manifold Approximation and Projection (UMAP) (McInnes et al., 2018[href=https://www.wicell.org#bib16]) by running the ‘runUMAP’ wrapper function that implements the ‘umap’ function from the uwot package (https://cran.r-project.org/web/packages/uwot/[href=https://cran.r-project.org/web/packages/uwot/]). Based on the elbow plot shown in step 22, we select the first 30 PCs for UMAP analysis.\n> SingCellaR::runUMAP(eFL,\n                            dim_reduction_method = \"pca\",\n                            n.dims.use = 30,\n                            n.neighbors = 30,\n                            uwot.metric = \"euclidean\")\nThe following parameters are required:\ndim_reduction_method: The method name for the linear dimension reduction.\nn.dims.use: The number of selected PCs as determined in step 22.\nn.neighbors: The number of neighboring cells (the size of the local neighborhood) used for manifold approximation. Default value is 30.\nuwot.metric: The distance metric name. Default is ‘cosine’.\nNote: The user can also apply the t-Distributed Stochastic Neighbor Embedding (tSNE) approach using the ‘runTSNE’ function. The reduced dimension coordinates for UMAP and tSNE can be accessed using functions ‘get_umap.result’ and ‘get_tsne.result’ respectively.",
    "Visualize cell lineages on low dimensional space. To explore whether the cells in each lineage are clustered in close proximity, we will visualize the UMAP result with the expression of multi-lineage gene sets using the ‘plot_umap_label_by_multiple_gene_sets’ function (Figure 2[href=https://www.wicell.org#fig2]C). Here, we observe that cells are clustered together according to major cell types.\n> plot_umap_label_by_multiple_gene_sets(eFL,\n    gmt.file = \"./Human_genesets/human.signature.genes.v1.gmt\",\n    show_gene_sets = c(\"Erythroid\",\"Myeloid\",\"Lymphoid\",\"Megakaryocyte\"),\n    custom_color = c(\"red\",\"cyan\",\"orange\",\"purple\"),\n    isNormalizedByHouseKeeping = F,\n    point.size = 1)\nThe following parameters are required:\ngmt.file: Path to the file containing the gene signatures in GMT format.\nshow_gene_sets: The names of the gene signatures to plot on UMAP.\ncustom_color: The color assignment to each signature specified in ‘show_gene_sets’.\nisNormalisedByHouseKeeping: When set to TRUE (default), the gene expression values of the individual genes of each gene signature specified will be normalized by the housekeeping genes. The housekeeping genes are defined as the top 100 genes with the highest total gene expression values across all cells.\npoint.size: Size of the data points on UMAP plot. Default value is 2.\nNote: Lineage gene sets (human.signature.genes.v1.gmt) are available at Zenodo: https://doi.org/10.5281/zenodo.5879071[href=https://doi.org/10.5281/zenodo.5879071] under Human_genesets folder and from original publication (Roy et al., 2021[href=https://www.wicell.org#bib23]).\nDetect and assign clusters. To detect and assign cell clusters, the ‘identifyClusters’ function is used. By default, the Louvain community-detection method implemented in the igraph package (https://igraph.org/r[href=https://igraph.org/r]) is used for cell clustering.\n> identifyClusters(eFL,n.dims.use = 30,\n                            dim_reduction_method = \"pca\",\n                            n.neighbors = 30,\n                            knn.metric = \"euclidean\")\nThe following parameters are required:\nn.dims.use: The number of PCs to use. Default number is 30.\ndim_reduction_method: The dimensionality reduction analysis name.\nn.neighbors: The number of neighboring cells. This number may be the same as specified in step 23 if UMAP is used. Default number is 30.\nknn.metric: The distance metric, ‘euclidean’ is used by default. Another option is ‘cosine’.",
    "Note: The cluster metadata for each cell can be accessed using the ‘get_cluster’ function.\nVisualize clusters on low dimensional space. Louvain clusters can be shown on UMAP using the ‘plot_umap_label_by_clusters’ function (Figure 2[href=https://www.wicell.org#fig2]D).\n> plot_umap_label_by_clusters(eFL,show_method = \"louvain\",mark.clusters = F)\nThe following parameters are required:\nshow_method: The clustering detection name used as in step 25.\nmark.clusters: If set to TRUE (default) , cluster identifiers will be shown on the plot.\nIdentify cluster-specific genes. The user can identify marker genes, which are particularly expressed in each cluster using the ‘findMarkerGenes’ function. Differentially expressed gene analysis between one cluster against all other clusters is performed using the nonparametric Wilcoxon test on normalized expression values for the comparison of expression level and Fisher’s exact test for the comparison of expressing cell frequency (Giustacchini et al., 2017[href=https://www.wicell.org#bib6]). P-values generated from both tests are then combined using Fisher’s method and are adjusted using Benjamini–Hochberg (BH). This process is iterated for each cluster against all other clusters, therefore the processing time in this step is dependent on the number of cells and clusters. By default, the minimum log2 fold change ‘min.log2FC’ parameter is set to 0.5 and the minimum fraction of expressing cells in each cluster ‘min.expFraction’ parameter is set to 0.3.\n> findMarkerGenes(eFL,cluster.type = \"louvain\")\nThe following parameter is required:\ncluster.type: The clustering detection method used in step 25.\nSave R object for further analyses.\n> save(eFL,file, “./eFL_All.SingCellaR.rdata\")\nRepeat the integration process for all biological replicates of FL, FBM, and PBM samples. There is only one sample for ABM. Therefore, data integration is not required for this sample at this step. All R codes provided for each integration are available at Zenodo: https://doi.org/10.5281/zenodo.5879071[href=https://doi.org/10.5281/zenodo.5879071].",
    "Pause point: The user can pause the analysis after integrating the biological replicates for each developmental stage and save the results in multiple SingCellaR objects.\nIntegrating samples from all tissue types\nTiming: 2–3 h\nThe aim of integrating all samples is to assess the existence of batch or donor-specific effects that are confounding factors contributing to differences in gene expression profile across samples. Examples of batch effect include differences in library preparation methods, sequencing batch, and donor or sample ID (Tran et al., 2020[href=https://www.wicell.org#bib28]). If the batch effect is observed, it can be adjusted by a variety of existing batch correction and integration methods incorporated in SingCellaR, including a novel technique, namely Supervised Harmony that we have developed and described in (Roy et al., 2021[href=https://www.wicell.org#bib23]). SingCellaR also implements the wrapper functions for other integration methods including Harmony (Korsunsky et al., 2019[href=https://www.wicell.org#bib14]), Seurat (Hao et al., 2021[href=https://www.wicell.org#bib9]), Liger (Gao et al., 2021[href=https://www.wicell.org#bib5]), Scanorama (Hie et al., 2019[href=https://www.wicell.org#bib10]), Combat (Johnson et al., 2007[href=https://www.wicell.org#bib12]), and Limma (Ritchie et al., 2015[href=https://www.wicell.org#bib21]). In this step, we demonstrate examples of how to use these methods for data integration using the wrapper functions. A strategy to benchmark how well single cells are clustered across covariate variables (e.g., batch and donor) is illustrated.\nGeneral examples of data integration include integrating samples from healthy donors and patients (Granja et al., 2019[href=https://www.wicell.org#bib7]; Psaila et al., 2020[href=https://www.wicell.org#bib20]) and from patients at different disease stages such as in cancer at diagnosis, remission, and relapse. Here, we illustrate the integration of HSPCs from five tissues spanning four different stages of human development that also happened to be processed and sequenced in two different batches (Roy et al., 2021[href=https://www.wicell.org#bib23]).\nLoad SingCellaR package.\n> library(SingCellaR)\nInitialize the SingCellaR_Int object and merge datasets generated from step 29.\n> Human_HSPC <- new(\"SingCellaR_Int\")\n> Human_HSPC@dir_path_SingCellR_object_files<-\"./\"\n> Human_HSPC@SingCellR_object_files=c(\"eFL_All.SingCellaR.rdata\",\n                                                \"FL_All.SingCellaR.rdata\",",
    "\"FBM_All.SingCellaR.rdata\",\n                                                \"PBM_All.SingCellaR.rdata\",\n                                                \"ABM_1.SingCellaR.rdata\")\n> preprocess_integration(Human_HSPC)\n> Human_HSPC\nAnnotate cell quality. Input parameters for integrated samples have been set to include all cells. The user should observe that there are no cells being filtered out after running the following code:\n> filter_cells_and_genes(Human_HSPC,\n                                min_UMIs=1000,\n                                max_UMIs=60000,\n                                min_detected_genes=500,\n                                max_detected_genes=6000,\n                                max_percent_mito=20,\n                                isRemovedDoublets = F)\nIncorporate donor and sequencing batch information into cell metadata. This information is required to perform the batch correction.\n> meta.data <- read.delim(file = \"./meta.data.txt\", header = T, sep = \"∖t\")\n> Human_HSPC@meta.data<- meta.data\nUpdated meta.data can be checked by running:\n> head(Human_HSPC@meta.data)\nNormalize and scale UMI counts.\n> normalize_UMIs(Human_HSPC, use.scaled.factor = T)\nIdentify highly variable genes.\n> get_variable_genes_by_fitting_GLM_model(Human_HSPC,\n                                                mean_expr_cutoff = 0.05,\n                                                disp_zscore_cutoff = 0.05)\nRemove ribosomal and mitochondrial genes.\n> remove_unwanted_genes_from_variable_gene_set(Human_HSPC,\n    gmt.file = \"./Human_genesets/human.ribosomal-mitochondrial.genes.gmt\",\n    removed_gene_sets=c(\"Ribosomal_gene\",\"Mitochondrial_gene\"))\nVisualize highly variable genes.\n> plot_variable_genes(Human_HSPC)\nRun PCA.\n> SingCellaR::runPCA(Human_HSPC,\n                            use.components = 100,\n                            use.regressout.data = FALSE\n                            )\nVisualize principal components. Based on the elbow plot, the first 40 PCs will be used for data integration.\n> plot_PCA_Elbowplot(Human_HSPC)\nIntegrate data using Supervised Harmony. We introduce Supervised Harmony, a method for data integration implemented in SingCellaR. Supervised Harmony can be performed using the ‘runSupervised_Harmony’ function. This method is an adaptation of Harmony method (Korsunsky et al., 2019[href=https://www.wicell.org#bib14]). More details of this method were described (Roy et al., 2021[href=https://www.wicell.org#bib23]). Here, sequencing batch and donor IDs as defined in step 33 are specified as covariates.\n> SingCellaR::runSupervised_Harmony(Human_HSPC,\n                                          covariates = c(\"batch\",\"donor\"),\n                                          n.dims.use = 40,\n                                          hcl.height.cutoff = 0.3,\n                                          harmony.max.iter = 20,\n                                          n.seed = 6)\nThe following parameters are required:\ncovariates: The name(s) of the covariate(s) specified as batch effect to be adjusted. The names should be the same as the column names of the cell metadata.\nn.dims.use: The number of PCs as determined from step 39 to be used in this step.",
    "hcl.height.cutoff: The cutree cut-off value for hierarchical clustering. Default value is 0.25.\nharmony.max.iter: The maximum number of rounds to run harmony. Default value is 10.\nn.seed: The random seed number generator. Default value is 1.\nCritical: Before running Supervised Harmony method, the ‘findMarkerGenes’ function must be performed for each developmental stage analysis (see step 27). The seed number (random number generator) and software version can vary across different devices. Hence, the user may notice variations in the rotation of the plots and clusters, which can be verified and visualized using lineage genes (see step 24).\nNonlinear dimension reduction analysis.\n> SingCellaR::runUMAP(Human_HSPC,\n                            useIntegrativeEmbeddings = T,\n                            integrative_method = \"supervised_harmony\",\n                            umap_method = \"uwot\",\n                            n.dims.use = 40,\n                            uwot.metric = \"euclidean\",\n                            n.seed = 1)\nThe UMAP analysis result from Supervised Harmony integration will be saved. This UMAP object will be used to compare with the results from other integrative methods (see steps below).\n> supervised_harmony.UMAP<-get_umap.result(Human_HSPC)\n> saveRDS(supervised_harmony.UMAP,file=\"supervised_harmony.UMAP.rds\")\nIntegrate data using Harmony. SingCellaR also implements a wrapper function for Harmony integration method (Korsunsky et al., 2019[href=https://www.wicell.org#bib14]). Harmony can be performed using the ‘runHarmony’ function. Here, sequencing batch and donor IDs as defined are specified as covariates. UMAP analysis will be performed to obtain the embedding.\n> library(harmony)\n> SingCellaR::runHarmony(Human_HSPC,\n                                          covariates = c(\"batch\",\"donor\"),\n                                          n.dims.use = 40,\n                                          harmony.max.iter = 20,\n                                          n.seed = 6)\nThe following parameters are required:\ncovariates: The name(s) of the covariate(s) specified as batch effect to be adjusted. The names should be the same as the column names of the cell metadata.\nn.dims.use: The number of PCs as determined from step 39 to be used in this step.\nharmony.max.iter: The maximum number of rounds to run harmony. Default value is 10.\nn.seed: The random seed number generator. Default value is 1.\n> SingCellaR::runUMAP(Human_HSPC,\n                            useIntegrativeEmbeddings = T,\n                            integrative_method = \"harmony\",\n                            umap_method = \"uwot\",\n                            n.dims.use = 40,",
    "uwot.metric = \"euclidean\",\n                            n.seed = 1)\nThe UMAP analysis result from Harmony integration will be saved. This UMAP object contains cell metadata and UMAP coordinates that will be used to compare with the results from other integrative methods.\n> harmony.UMAP<-get_umap.result(Human_HSPC)\n> saveRDS(harmony.UMAP,file=\"harmony.UMAP.rds\")\nIntegrate data using Seurat. SingCellaR implements two wrapper functions for Seurat integration (Hao et al., 2021[href=https://www.wicell.org#bib9]). First, the function ‘runSeuratIntegration’ is for the standard Seurat integration with Canonical Correlation Analysis (CCA). Second, the function ‘runSeuratIntegration_with_rpca’ is for the fast integration using Reciprocal PCA (RPCA). More details about Seurat integration are described on Seurat’s website (https://satijalab.org/seurat/[href=https://satijalab.org/seurat/]). Due to the fast integration of using RPCA, in this protocol, we will demonstrate the function ‘runSeuratIntegration_with_rpca’ as an example. However, the user should try Seurat CCA to make a comparison of the integrative results. The user can find how to use the function ‘runSeuratIntegration’ from SingCellaR’s vignette. After the integration, the UMAP analysis from Seurat RPCA integration will be performed to obtain the embedding.\n> library(Seurat)\n> meta.data<-get_cells_annotation(Human_HSPC)\n> rownames(meta.data)<-meta.data$Cell\n> SingCellaR::runSeuratIntegration_with_rpca(Human_HSPC,\n    Seurat.metadata=meta.data,\n    n.dims.use = 40,\n    Seurat.split.by = \"data_set\",\n    use.SingCellaR.varGenes = T)\nThe following parameters are required:\nSeurat.metadata: The cell metadata.\nn.dims.use: The number of PCs as determined from step 39 to be used in this step.\nSeurat.split.by: The indicated feature name found in the cell metadata for splitting samples for integration.\nUse.SingCellaR.varGenes: If set to TRUE, the highly variable genes identified by SingCellaR will be used. If set to FALSE, the highly variable genes will be identified using Seurat. Default value is FALSE. Next, the UMAP analysis from Seurat RPCA integration will be performed and saved. This UMAP object will be used to compare with the results from other integrative methods.\n> SingCellaR::runUMAP(Human_HSPC,\n                            useIntegrativeEmbeddings = T,\n                            integrative_method = \"seurat\",\n                            umap_method = \"uwot\",\n                            n.dims.use = 40,\n                            uwot.metric = \"euclidean\",\n                            n.seed = 1)",
    "> Seurat_rpca.UMAP<-get_umap.result(Human_HSPC)\n> saveRDS(Seurat_rpca.UMAP,file=\"Seurat_rpca.UMAP.rds\")\nIntegrate data using Scanorama. SingCellaR implements a wrapper function for Scanorama integration (Hie et al., 2019[href=https://www.wicell.org#bib10]). Scanorama can be performed using the ‘runScanorama’ function. After the integration, the standard PCA and UMAP analyses from Scanorama integration will be performed to obtain the embedding.\n> runScanorama(Human_HSPC)\n> runPCA(Human_HSPC,use.scanorama.integrative.matrix = T,use.components = 40)\n> SingCellaR::runUMAP(Human_HSPC,\n                            dim_reduction_method = \"pca\",\n                            umap_method = \"uwot\",\n                            n.dims.use = 40,\n                            uwot.metric = \"euclidean\",\n                            n.seed = 1)\n> Scanorama.UMAP<-get_umap.result(Human_HSPC)\n> saveRDS(Scanorama.UMAP,file=\"Scanorama.UMAP.rds\")\nIntegrate data using Limma batch correction method. To perform Limma analysis (Ritchie et al., 2015[href=https://www.wicell.org#bib21]), SingCellaR provides the ‘remove_unwanted_confounders’ wrapper function to regress out the unwanted source of variation. We illustrate below for regressing out the effect from the library size, donor, and batch.\n> remove_unwanted_confounders(Human_HSPC,\n    residualModelFormulaStr=\"∼UMI_count+donor+batch\")\n> runPCA(Human_HSPC,use.regressout.data = T)\n> SingCellaR::runUMAP(Human_HSPC,\n                          dim_reduction_method = \"pca”,\n                          umap_method = \"uwot\",\n                          n.dims.use = 40,\n                          uwot.metric = \"euclidean\",\n                          n.seed = 1)\n> Limma.UMAP<-get_umap.result(Human_HSPC)\n> saveRDS(Limma.UMAP,file=\"Limma.UMAP.rds\")\nAssign a cell type to single cells using the AUCell analysis. In this step, we will perform AUCell analysis (Aibar et al., 2017[href=https://www.wicell.org#bib1]) with seven lineage signature genes including HSC/MPP, myeloid, lymphoid, erythroid, megakaryocytic, eosinophil/basophil/mast, and endothelial progenitor cells. This step will identify the cell types that can be used for benchmarking distinct integrative methods. We assume that cells with high AUCell scores, high expression of signature genes, indicate strong ground truth of the assigned cell type. Therefore, we would expect that the same cell type should be aggregated well together when applying integrative methods.\n> library(AUCell)\n> exprMatrix <- get_umi_count(Human_HSPC)\n> human_HSPCs_cells_rankings <- AUCell_buildRankings(exprMatrix,\n                                                                    nCores=4,\n                                                                    plotStats=TRUE)\nThe following parameters are required:\nexprMat: The raw expression count matrix. This can be retrieved from the SingCellaR object using the ‘get_umi_count’ function.",
    "nCores: The number of cores to use for parallel processing. The maximum number of cores is dependent on the user’s device. Default value is 1.\nplotStats: If set to TRUE (default), the expression statistics will be summarized and plotted in the histogram and boxplots.\nNote: This step may be time-consuming. The user is advised to save the output of this step using the following code:\n> save(human_HSPCs_cells_rankings,\n      file=\"./Human_HSPC_rankings.AUCells.rdata\")\nNext, the AUCell analysis will be performed using the ‘Run_AUCell’ function.\n> human_HSPCs.AUCells.score <- Run_AUCell(Human_HSPC,\n        AUCell_buildRankings.file = \"Human_HSPC_rankings.AUCells.rdata\",\n        geneSets.gmt.file = \"./Human_genesets/human.signature.genes.v1.gmt\")\nThe following parameters are required:\nAUCell_buildRankings.file: The input file name from the AUCell rankings.\ngeneSets.gmt.file: The GMT file name that contains gene sets. To explore the AUCell scores on UMAP plots, the user can run UMAP analysis using different types of integrative methods. This step is to identify the AUCell cut-off score for a particular cell type. The example below shows the ‘plot_umap_label_by_AUCell_score’ function that will be used to plot the myeloid AUCell scores (Figure 3[href=https://www.wicell.org#fig3]A).\n> SingCellaR::runUMAP(Human_HSPC,\n                          useIntegrativeEmbeddings = T,\n                          integrative_method = \"supervised_harmony\",\n                          umap_method = \"uwot\",\n                          n.dims.use = 40,\n                          uwot.metric = \"euclidean\",\n                          n.seed = 1)\n>plot_umap_label_by_AUCell_score(Human_HSPC,\nAUCell_gene_set_name=c(\"Myeloid\"),Human_HSPC.AUCells.Score,AUCell_cutoff=0.1\n5,point.size = 0.5)\nNext, cells with high AUCell scores (e.g., > 0.2 or > 0.15) for each cell type will be assigned.\n> Human_HSPC.CellType<-Human_HSPC.AUCells.Score\n> Human_HSPC.CellType$CellType<-\"\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$HSPC_MPP >0.2]<-\"HSC_MPP\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$Erythroid >0.15]<-\"Erythroid\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$Myeloid >0.15]<-\"Myeloid\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$Lymphoid >0.15]<-\"Lymphoid\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$Megakaryocyte >0.15]<-\n\"Megakaryocyte\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$Eosinophil_Basophil_Mast >\n0.15]<-\"Eo_Ba_Mast\"\n> Human_HSPC.CellType$CellType[Human_HSPC.CellType$Endothelial_cells > 0.15]<-\n\"Endothelial_cell\"\nThe user can explore the number of cells with high AUCell scores for each cell type using the function below and the Human_HSPC.CellType data frame object will be saved for use as the reference to perform benchmarking explained in the next step.\n> table(Human_HSPC.CellType$CellType)\n> saveRDS(Human_HSPC.CellType,file=\"Human_HSPC.CellType_from_AUC_High.rds\")\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig3.jpg\nFigure 3. Benchmarking the integration methods",
    "(A) The UMAP plot shows AUCell scores of the cells calculated using myeloid signature genes.\n(B) LISI analysis on different integrative methods. X-axis represents the cLISI score and y-axis represents the iLISI score. The more accurate integration should result in a higher iLISI score and cLISI score close to 1.\n(C) Boxplot of kBET average acceptance rate score for each integrative method.\nBenchmark distinct integrative methods using LISI and kBET methods. Next, we assess whether single cells with identified cell types derived from the AUCell analysis are clustered well across covariate variables (e.g., batch and donor). SingCellaR provides the wrapper functions for a Local Inverse Simpson’s Index (LISI) (Korsunsky et al., 2019[href=https://www.wicell.org#bib14]) and k-nearest-neighbor batch-effect test (kBET) (Buttner et al., 2019[href=https://www.wicell.org#bib4]) to measure LISI and kBET scores across different integrative methods. First, the ‘runLISI’ function is performed as shown below. This function will plot LISI scores across different integrative methods (Figure 3[href=https://www.wicell.org#fig3]B).\n> library(lisi)\n> reference.celltypes<-\"Human_HSPC.CellType_from_AUC_High.rds\"\n> integrative.umaps<-c(\"supervised_harmony.UMAP.rds\",\n                            \"harmony.UMAP.rds\",\n                            \"Seurat_rpca.UMAP.rds\",\n                            \"Scanorama.UMAP.rds\",\n                            \"Limma.UMAP.rds\")\n> method.names<-c(\"Supervised Harmony\",\"Harmony\",\"Seurat_rpca\",\"Scanorama\",\n                      \"Limma\")\n> runLISI(lisi_label1=\"donor\",lisi_label2=\"CellType\",\n            reference.celltypes.rds.file=reference.celltypes,\n            integrative.umap.rds.files=integrative.umaps,\n            integrative.method.names=method.names,IsShowPlot = T)\nThe following parameters are required:\nlisi_label1: The covariate variable name of interest such as batch or donor. Default value is donor.\nlisi_label2: The variable name that represents ground truth or high AUC score cell type. Default value is CellType.\nreference.celltype.rds.file: The RDS file name that contains cell type information.\nintegrative.umap.rds.files: The RDS file names that contain UMAP coordinate information generated by different integrative methods.\nintegrative.method.names: The integrative method names that represent in the same order as in integrative.umap.rds.files.\nIsShowPlot: If set to TRUE (default), the iLISI and cLISI scores will be plotted. Second, the ‘runKBET’ function is performed as shown below. This function will calculate kBET scores across different integrative methods and return a data frame that can be used for plotting.\n> library(kBET)\n> reference.celltypes<-\"Human_HSPC.CellType_from_AUC_High.rds\"",
    "> integrative.umaps<-c(\"supervised_harmony.UMAP.rds\",\n                            \"harmony.UMAP.rds\",\n                            \"Seurat_rpca.UMAP.rds\",\n                            \"Scanorama.UMAP.rds\",\n                            \"Limma.UMAP.rds\")\n> method.names<-c(\"Supervised Harmony\",\n                      \"Harmony\",\n                      \"Seurat_rpca\",\n                      \"Scanorama\",\n                      \"Limma\")\n>kBET_result<-runKBET(covariate_variable_name=\"donor\",\n              reference.celltypes.rds.file=reference.celltypes,\n              integrative.umap.rds.files=integrative.umaps,\n              integrative.method.names=method.names,\n              n.sample=1000)\nThe following parameters are required:\nCovariate_variable_name: The covariate variable name of interest such as batch or donor. Default value is donor.\nreference.celltype.rds.file: The RDS file name that contains cell type information.\nintegrative.umap.rds.files: The RDS file names that contain UMAP coordinate information generated by different integrative methods.\nintegrative.method.names: The integrative method names that represent in the same order as in integrative.umap.rds.files.\nn.sample: The downsample size of data points used in kBET analysis. Default value is 1,000.\nNote: This step may be time-consuming, depending on the number of cells downsampled for kBET analysis.\nNext, kBET scores across integrative methods will be plotted using the ‘ggplot’ function (Figure 3[href=https://www.wicell.org#fig3]C).\n> level_order <- factor(kBET_result$Method, level = c('Supervised Harmony',\n'Harmony', 'Seurat_rpca','Scanorama','Limma'))\n> ggplot(kBET_result, aes(x=level_order, y=AcceptanceRate, color=Method)) +\n        + geom_boxplot()+theme_classic()+theme(axis.title.x=element_blank())\nIn this step, we illustrate how to benchmark integrative results generated from different methods using the wrapper functions for LISI and kBET analyses implemented in SingCellaR. We show the objective measurement of integration for each method using iLISI and cLISI scores (Figure 3[href=https://www.wicell.org#fig3]B) and kBET average acceptance rate score (Figure 3[href=https://www.wicell.org#fig3]C). The user can observe from the plots that Supervised Harmony shows higher kBET and iLISI scores, and cLISI score is close to 1, indicating better data integration for this HSPC dataset compared to other methods described in (Roy et al., 2021[href=https://www.wicell.org#bib23]). Therefore, the integration result from Supervised Harmony will be used for further downstream analyses.",
    "Visualize selected features and cell lineages on low dimensional space. Here, we will assess whether the data integration was performed successfully. To this end, we annotate the UMAP by sample ID, donor type, sequencing batch, and lineage signature genes. After running the following codes, we observe that cells are clustered by cell lineage, while sample ID, donor type and sequencing batch effects are successfully corrected. These indicate that data integration and batch correction was effective in eliminating batch effect, while enabling functionally related cell to be clustered in close proximity.\nAnnotate UMAP plot by sample ID (Figure 4[href=https://www.wicell.org#fig4]A).\n> plot_umap_label_by_a_feature_of_interest(Human_HSPC,\n                                              feature = \"sampleID\",\n                                              point.size = 0.5,\n                                              mark.feature = F)\nAnnotate UMAP plot by donor (Figure 4[href=https://www.wicell.org#fig4]B).\n> plot_umap_label_by_a_feature_of_interest(Human_HSPC,\n                                                      feature = \"donor\",\n                                                      point.size = 0.5,\n                                                      mark.feature = F)\nAnnotate UMAP plot by sequencing batch (Figure 4[href=https://www.wicell.org#fig4]C).\n> plot_umap_label_by_a_feature_of_interest(Human_HSPC,\n                                              feature = \"batch\",\n                                              point.size = 0.5,\n                                              mark.feature = F)\nThe following parameters are required:\nfeature: The feature to annotate on UMAP plot. The feature name should match the column name of the cell metadata.\npoint.size: Size of the data points on UMAP. Default value is 1.\nmark.feature: If set to TRUE (default), the feature name will be shown on the plot.\nAnnotate UMAP plot by lineages genes (Figure 4[href=https://www.wicell.org#fig4]D).\n> plot_umap_label_by_multiple_gene_sets(Human_HSPC,\n        gmt.file = \"./Human_genesets/human.signature.genes.v1.gmt\",\n        show_gene_sets = c(\"Erythroid\",\n        \"Myeloid\",\"Lymphoid\",\"Megakaryocyte\"),\n        custom_color = c(\"red\",\"cyan\",\"orange\",\"purple\"),\n        isNormalizedByHouseKeeping = F,\n        point.size = 1)\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig4.jpg\nFigure 4. Visualization of UMAP generated from the integration of whole datasets\n(A–D) UMAP plots showing superimposition of (A) sample IDs; (B) donors; (C) sequencing batches; and (D) the expression of lineage gene sets. Yellow – lymphoid cells; Cyan – myeloid cells; Red – erythroid cells; Purple – megakaryocytic cells; Gray – HSPCs that do not (or lowly) express lineage signature genes.\nDetect and assign clusters.\n> identifyClusters(Human_HSPC,\n                        useIntegrativeEmbeddings = T,\n                        integrative_method = \"supervised_harmony\",",
    "n.dims.use = 40,\n                        knn.metric = \"euclidean\",\n                        n.neighbors = 30)\nNote: Information in this step and the required parameters have been detailed in step 25 with the additional ‘integrative_method’ parameter specified to indicate the data integration and batch correction method used in step 40.\nVisualize clusters on low dimensional space. (Figure 5[href=https://www.wicell.org#fig5]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig5.jpg\nFigure 5. Cell clustering and annotation\n(A) The UMAP plot of 57,489 cells labeled with distinct 21 clusters, identified using the Louvain community-detection clustering method.\n(B) The heatmap showing positive gene set enrichment scores from GSEA analysis comparison of each cluster against the rest of clusters. The heatmap is generated using the function ‘plot_heatmap_for_fGSEA_all_clusters’. The x-axis represents the identified clusters depicted in (A). The y-axis represents the list of curated hematopoietic gene signatures.\n> plot_umap_label_by_clusters(Human_HSPC,\n                                    show_method = \"louvain\",\n                                    mark.clusters = T)\nIdentify cluster-specific genes. This step will perform differential gene expression analysis to identify marker genes per each cluster.\n> findMarkerGenes(Human_HSPC,cluster.type = \"louvain\")\nNote: See details in step 27. This step will take time to run on the fully integrated datasets depending on the number of cells and identified clusters.\nSave the integrated R object for further analyses.\n> save(Human_HSPC,\n            file=\"./Human_HSPC_All.SingCellaR.rdata\")\nPause point: The user can save the integrative SingCellaR_Int object for further downstream analyses.\nCell type annotation\nTiming: 1.5–2 h",
    "The aim of cell type annotation is to assign a cell type identity to each cluster. The expression of selected marker genes can be visualized and explored across the different clusters, either using UMAP, dotplot, heatmap, or violin plots (Satija et al., 2015[href=https://www.wicell.org#bib24]). Nevertheless, it is only feasible to explore a small number of gene markers using these approaches. Moreover, closely related cell populations with overlapping or subtle differences in transcriptomic profiles can be better resolved using gene sets, rather than individual genes. To more systematically and objectively annotate the clusters, SingCellaR implements a GSEA-based cell type annotation approach whereby cluster-specific ranked genes are subjected to GSEA analysis using a comprehensive list of curated gene sets. Using this approach, for each cluster, the list of genes previously included for differential expression analysis using findMarkerGenes is ranked from the most up-regulated to most down-regulated. Next, the individual genes in each curated gene set are assessed for enrichment in this ranked list of genes. Gene sets that are found higher up in the ranked list of genes are considered to be more enriched in a given cluster (Subramanian et al., 2005[href=https://www.wicell.org#bib27]). This assessment of gene set enrichment is implemented by the fgsea (Korotkevich et al., 2021[href=https://www.wicell.org#bib13]) package. These curated gene sets encompass 75 hematopoietic cell types and are available at Zenodo: https://doi.org/10.5281/zenodo.5879071[href=https://doi.org/10.5281/zenodo.5879071] in GMT file format and are also available in Table S3 from the original publication (Roy et al., 2021[href=https://www.wicell.org#bib23]).\nLoad the SingCellaR package.\n> library(SingCellaR)\nLoad the integrated R object generated from step 52.\n> load(file = \"./Human_HSPC_All.SingCellaR.rdata\")",
    "Generate the pre-ranked genes. For each cluster, differential gene expression analysis is performed (Giustacchini et al., 2017[href=https://www.wicell.org#bib6]) against all other clusters and the resulting genes are ranked based on their log2 fold change multiplied by -log10 of the adjusted P-value. This is to yield a more robust ranking compared to using the log2 fold change alone for the genes for GSEA. Here, the ‘identifyGSEAPrerankedGenes_for_all_clusters’ function is performed to provide a suitable format for GSEA analysis and includes all possible expressed genes above the lower cut-off parameters defined using the min.expFraction and min.log2FC arguments.\n> pre_rankedGenes_for_GSEA <-\n    identifyGSEAPrerankedGenes_for_all_clusters(Human_HSPC,\n                                                          cluster.type = \"louvain\")\nThe following parameter is required:\ncluster.type: The clustering method name.\nfishers_exact_test: The cut-off p-value. Default value is 0.1.\nmin.expFraction: The fraction of expressing cells, above which, the gene will be included for GSEA. Default value is 0.01.\nmin.log2FC: The log2 fold change, above which, the gene will be included for GSEA. Default value is 0.1.\nNote: The processing time of this step depends on the number of cells and clusters. The user is advised to save the output of this step using the following code:\n> save(pre_rankedGenes_for_GSEA,\n    file=\"./Human_HSPCs_preRankedGenes_for_GSEA.rdata\")\nPerform GSEA. For each cluster, the ranked genes are subjected to GSEA to assess the enrichment for all curated hematopoietic gene sets.\n> fgsea_Results <- Run_fGSEA_for_multiple_comparisons(\n        GSEAPrerankedGenes_list = pre_rankedGenes_for_GSEA,\n        gmt.file = \"./Human_genesets/human.hematopoiesis.signature.genes.gmt\")\nThe following parameters are required:\nGSEAPrerankedGenes_list: The object containing the ranked genes for each cluster generated from step 55.\ngmt.file: Curated gene sets in GMT file format.",
    "Note: Here, we curated gene sets encompassing 75 hematopoietic signatures, but the user can also generate other customized gene sets in GMT file format as the input for GSEA. Each line of the GMT file represents one gene set. Specifically, the first column represents the name of the gene set, the second column represents the description of the gene set, and the third column onwards represents the genes that constitute the gene set, whereby each column represents one gene. The GMT file should be saved in tab-delimited format.\nVisualize GSEA results. A heatmap is used to observe and compare enrichment scores of each gene set (rows) across all clusters (columns). This visualization allows the user to annotate a cell type identity and cell states to each cluster based on the degree of enrichment of the curated gene sets. (Figure 5[href=https://www.wicell.org#fig5]B).\n> plot_heatmap_for_fGSEA_all_clusters(fgsea_Results,\n                              isApplyCutoff = TRUE,\n                              use_pvalues_for_clustering=T,\n                              show_NES_score = T,\n                              fontsize_row = 5,\n                              adjusted_pval = 0.10,\n                              show_only_NES_positive_score = T,\n                              format.digits = 3,\n                              clustering_method = \"ward.D\",\n                              clustering_distance_rows = \"euclidean\",\n                              clustering_distance_cols = \"euclidean\",\n                              show_text_for_ns = F)\nThe following parameters are required:\nisApplyCutoff: If set to TRUE, only the normalized enrichment scores (NES) of gene sets with adjusted P-values below the user-defined values in ‘adjusted_pval’ argument will be displayed on the heatmap. Default is FALSE.\nuse_pvalues_for_clustering: If set to TRUE (default), the -log10(P-values) will be used instead of NES to cluster rows and/or columns.\nshow_NES_score: If set to TRUE (default), NES will be displayed on the heatmap.\nfontsize_row: The font size of the gene set names along the rows of the heatmap. Default value is 5.\nadjusted_pval: The value, below which, NES will be displayed on the heatmap. The default value is 0.25.\nshow_only_NES_positive_score: If set to TRUE, only NES > 0 will be displayed on the heatmap. Default is FALSE.",
    "format.digits: The number of significant digits to be used for numeric display on the heatmap. Default value is 2.\nclustering_method: The clustering method for clustering the rows and/or columns. Default is \"complete\".\nclustering_distance_rows: The distance metric to use when clustering the rows. Default is \"euclidean\".\nclustering_distance_cols: The distance metric to use when clustering the columns. Default is \"euclidean\".\nshow_text_for_ns: If set to TRUE (default), non-significant (ns) NES will be displayed on the heatmap.\nVisualize selected canonical marker genes using UMAP. One or more individual genes can be plotted on UMAP using the ‘plot_umap_label_by_genes’ function (Figure 6[href=https://www.wicell.org#fig6]A).\n# HSC/MPP\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"AVP\",\"HLF\",\"CLEC9A\"))\n# Myeloid progenitor\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"ELANE\",\"MPO\",\"AZU1\"))\n# Erythroid progenitor\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"KLF1\",\"CNRIP1\",\"APOE\"))\n# Megakaryocytic progenitor\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"PF4\",\"GP9\",\"SELP\"))\n# B lymphoid progenitor\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"DNTT\",\"CD79A\",\"VPREB1\"))\n# Dendritic precursor\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"SPIB\",\"IRF8\",\"MPEG1\"))\n# Eosinophil/Basophil/Mast progenitor\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"CLC\",\"HDC\",\"IL5RA\"))\n# Endothelial cells\n> plot_umap_label_by_genes(Human_HSPC,gene_list = c(\"OIT3\",\"MMRN2\",\"LYVE1\"))\nThe following parameter is required:\ngene_list: A vector of one or more gene names to plot.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig6.jpg\nFigure 6. Gene expression of canonical lineage signatures and marker gene identification for each cluster\n(A) UMAP plots of known lineage marker genes for HSC/MPP. Red – highly expressed and blue – lowly expressed.\n(B) Bubble plots of known lineage marker gene expression for each cluster. The size of the dots represents the percentage of expressing cells as indicated within the dot. The x-axis represents the identified clusters.\nVisualize selected canonical marker genes using bubble plot (Figure 6[href=https://www.wicell.org#fig6]B). One or more individual genes can be plotted using the ‘plot_bubble_for_genes_per_cluster’ function. Each gene will be represented on each row of the output.\n> marker.genes <- c(\"AVP\",\"HLF\",\"CLEC9A\",\n                          \"PF4\",\"GP9\",\"SELP\",\n                          \"KLF1\",\"CNRIP1\",\"APOE\",\n                          \"ELANE\",\"MPO\",\"AZU1\",\n                          \"DNTT\",\"CD79A\",\"VPREB1\",\n                          \"SPIB\",\"IRF8\",\"MPEG1\",\n                          \"CLC\",\"HDC\",\"IL5RA\",\n                          \"OIT3\",\"MMRN2\",\"LYVE1\")\n> plot_bubble_for_genes_per_cluster(Human_HSPC,\n                                              cluster.type = \"louvain\",\n                                              gene_list = marker.genes,\n                                              show.percent = TRUE)\nThe following parameters are required:",
    "cluster.type: The clustering method name used to identify and assign the cell clusters.\ngene_list: A vector of one or more gene names to plot.\nshow.percent: If set to TRUE, the percentage of expressing cells for respective genes in each cluster are displayed on the dotplot. Default is FALSE.\nVisualize identified marker genes for each cluster using heatmap. One or more individual genes can be plotted using a heatmap with the ‘plot_heatmap_for_marker_genes’ function. Each gene is represented on each row of the output.\n> plot_heatmap_for_marker_genes(Human_HSPC,\n                                          cluster.type = \"louvain\",\n                                          n.TopGenes = 8)\nThe following parameters are required:\ncluster.type: The name of the clustering method used to identify and assign the cell clusters.\nn.TopGenes: The number of top genes for each cluster to plot. Default value is 5.\nExport top marker genes for each cluster. The top marker genes with statistical analysis results can be exported to the text file format.\n> export_marker_genes_to_table(Human_HSPC,\n                                        cluster.type = \"louvain\",\n                                        n.TopGenes = 100,\n                                        min.log2FC = 0.5,\n                                        min.expFraction = 0.3,\n                                        write.to.file =\n    \"./Human_HSPC_marke_genes_per_cluster.txt\")\nThe following parameters are required:\ncluster.type: The clustering method name used to identify and assign the cell clusters.\nn.TopGenes: The number of top genes for each cluster. Default value is 5.\nmin.log2FC: The log2FC value, above which, genes will be included. Default value is 0.5.\nmin.expFraction: The fraction of expressing cells, above which, genes will be included. Default value is 0.3.\nwrite.to.file: The file path to be exported.\nAUCell analysis\nTiming: 2–3 h",
    "The user can calculate the enrichment of specific gene sets (e.g., lineage signature and cell cycle genes) assigned for an individual cell. We incorporated AUCell score analysis (Aibar et al., 2017[href=https://www.wicell.org#bib1]) into SingCellaR to assign and define high-confident lineage-specific cells. This cell-level enrichment analysis enables us to validate our cell type annotation and check for the presence of heterogeneous cell populations within a given cluster. This can be further used to compare differential abundance of different cell lineages across developmental stages.\nLoad SingCellaR and required R packages. Here, the user can load the integrated R object saved from step 52.\n> library(SingCellaR)\n> library(AUCell)\n> library(ggplot2)\n> library(DAseq)\n> source('./utilis.R')\nLoad the integrated R object generated from step 52.\n> load(file = \"./Human_HSPC_All.SingCellaR.rdata\")\nBuild AUCell gene rankings. The user will have to create the ranked gene list using the function ‘AUCell_buildRankings’ implemented in AUCell package.\n> set.seed(2021)\n> exprMatrix <- get_umi_count(Human_HSPC)\n> human_HSPCs_cells_rankings <- AUCell_buildRankings(exprMatrix,\n                                                                    nCores=4,\n                                                          plotStats=TRUE)\nThe following parameters are required:\nexprMat: The raw expression count matrix. This can be retrieved from the SingCellaR object using the ‘get_umi_count’ function.\nnCores: The number of cores to use for parallel processing. The maximum number of cores is dependent on the user’s device. Default value is 1.\nplotStats: If set to TRUE (default), the expression statistics will be summarized and plotted in the histogram and boxplots.\nNote: This step may be time-consuming. The user is advised to save the output of this step using the following code:\n> save(human_HSPCs_cells_rankings,\n  +file=\"./Human_HSPC_rankings.AUCells.rdata\")\nCalculate AUCell scores. AUCell scores for each cell will be computed using the ranked genes from the previous step for the provided hematopoietic gene sets.\n> set.seed(2021)\n> human_HSPCs.AUCells.score <- Run_AUCell(Human_HSPC,\n        AUCell_buildRankings.file = \"Human_HSPC_rankings.AUCells.rdata\",\n        geneSets.gmt.file = \"./Human_genesets/human.signature.genes.v1.gmt\")\nOptional: The user is advised to save the AUCell scores for further analysis.\n> save(human_HSPCs.AUCells.score,",
    "file=\"./human_HSPCs.AUCells.score.rdata\")\nVisualize AUCell scores. The user can visualize AUCell scores for a given gene signature on specific clusters on the UMAP embedding. Here, we will use HSC/MPP gene signature on cluster 1 as an example (Figure 7[href=https://www.wicell.org#fig7]A). We observe HSC/MPP gene signature to be uniformly enriched across majority of cells from this cluster. This is consistent with our cluster-level GSEA results that indicate cluster 1 is enriched for several HSC and MPP gene sets.\n> plot_umap_label_by_AUCell_score(Human_HSPC,\n                                          AUCell_gene_set_name = \"HSPC_MPP\",\n                                          AUCell_score = human_HSPCs.AUCells.score,\n                                          selected.limited.clusters = \"cl1\",\n                                          IsLimitedAUCscoreByClusters = T,\n                                          AUCell_cutoff = 0.15)\nThe following parameters are required:\nAUCell_gene_set_name: The name of the gene signature to plot. The signature name specified here must be the same as the gene signature name in the GMT file provided in step 65.\nAUCell_score: The R object created from computing AUCell scores in step 65.\nselected.limited.clusters: Cells in selected cluster IDs will be displayed with the AUCell scores.\nIsLimitedAUCscoreByClusters: If set to TRUE, the AUCell scores will only be displayed for selected clusters as specified using the ‘selected.limited.clusters’ argument. Default is FALSE.\nAUCell_cutoff: The AUCell score threshold, above which, the scores will be displayed. The higher the score threshold, the more stringent the threshold. Default is 0.\nNote: AUCell cutoff score is arbitrary. To explore the AUCell cutoff score for each gene signature, the user can plot the score distribution using ggplot2 and manually explore the suitable threshold.",
    "Differential abundance testing. We use DAseq (Zhao et al., 2021[href=https://www.wicell.org#bib34]) to perform pairwise comparisons for cellular abundance in different tissues across developmental stages. We have incorporated the DAseq analysis into the ‘run_DAseq_comparison’ function. Here, we will show the differential abundance of cell populations between eFL and FL (Figure 7[href=https://www.wicell.org#fig7]B) as an example. Erythroid progenitors are enriched in FL, whereas lymphoid and myeloid progenitors are predominantly derived from BM samples. Marked differences are also observed for megakaryocytic progenitors whereby these cells are mainly from eFL.\n> run_DAseq_comparison(Human_HSPC,\n                              groupA = \"eFL\",\n                              groupB = \"FL\",\n                              labels.1 = c(\"eFL_1\",\"eFL_2\"),\n                              labels.2 = c(\"FL_1\",\"FL_2\"),\n                              path = \"./\",\n                              outputname = \"eFL_vs_FL.pdf\")\nThe following parameters are required:\ngroupA and groupB: The group names for integrated samples (e.g., eFL, FL, FBM, and PBM) or an individual sample name.\nlabels.1 and labels.2: The sample IDs of groupA and groupB, respectively.\npath: The folder path to save the output file.\noutputname: The output file name.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig7.jpg\nFigure 7. UMAP plots overlaid with computed scores from AUCell and differential abundance analyses\n(A) The UMAP plot shows AUCell scores of the cells calculated using the HSC/MPP signature genes. Cells with the AUCcell score greater than 0.15 within cluster 1 are highlighted with gradient colors from low (black) to high (red) scores.\n(B) The UMAP plot shows the differential abundance scores from the logistic classifier prediction calculated from DAseq analysis of pairwise comparison between eFL vs. FL. Cells in red are predicted to be more abundant in eFL, whereas cells in blue indicate higher abundance in FL. Cells in gray do not have substantially different abundance score.\nTrajectory analysis\nTiming: 1–1.5 h",
    "From the annotation of cell types assigned in the cell type annotation steps, the user can further investigate the direction of cellular differentiation trajectories. The user can trace immature to more differentiated cell populations and understand the functional relationship between different cell populations in terms of cellular maturity. It is noteworthy that current trajectory analysis requires the user to identify the starting point (immature cell state), in this case, HSC/MPP. Hence, the cell annotations inferred from previous steps will be helpful to infer the primitive cell clusters. SingCellaR supports two approaches of trajectory analysis, namely force-directed graph (FDG) (Jacomy et al., 2014[href=https://www.wicell.org#bib11]) and diffusion map (Haghverdi et al., 2015[href=https://www.wicell.org#bib8]). We will also perform Monocle3 analysis (Trapnell et al., 2014[href=https://www.wicell.org#bib29]), a pseudotime-based method (Haghverdi et al., 2015[href=https://www.wicell.org#bib8]) to infer cellular trajectories.\nMethod 1: Force-directed graph analysis\nLoad SingCellaR package.\n> library(SingCellaR)\nLoad the integrated R object generated from step 52.\n> load(file = \"./Human_HSPC_All.SingCellaR.rdata\")\nRun force-directed graph analysis. The user can use the ‘runFA2_ForceDirectedGraph’ function to build the force-directed graph layout (embeddings). The layout can be annotated using various features, including cell lineage signature genes. Here, we use the Supervised harmony embeddings to generate force-directed graph layout.\n> runFA2_ForceDirectedGraph(Human_HSPC,\n                                    useIntegrativeEmbeddings = T,\n                                    integrative_method = \"supervised_harmony\",\n                                    knn.metric = \"euclidean\",\n                                    n.dims.use = 40,\n                                    n.neighbors = 5,\n                                    n.seed = 35,\n                                    fa2_n_iter = 1000)\nThe following parameters are required:\nuseIntegrativeEmbeddings: If set to TRUE, the data integration or batch correction embeddings will be used in conjunction with ‘integrative_method’ argument. Default is FALSE.\nintegrative_method: The data integration or batch correction method name.\nknn.metric: The distance metric.\nn.dims.use: The number of PCs from ‘integrative_method’. If ‘useIntegrativeEmbedding’ is set to FALSE, the PCA analysis result is used. Default value is 30.\nn.neighbors: The number of neighboring cells.\nn.seed: The random number generator. Default value is 1.",
    "fa2_n_iter: The number of iterations for analyzing the ‘networkx’ graph. Default value is 1,000.\nVisualize trajectories by Louvain clustering (Figure 8[href=https://www.wicell.org#fig8]A).\n> plot_forceDirectedGraph_label_by_clusters(Human_HSPC, show_method =\n\"louvain\")\nThe following parameter is required:\nshow_method: The clustering method name.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1530-Fig8.jpg\nFigure 8. Differentiation trajectory analysis using the combination of SingCellaR and Monocle3\n(A and B) The force-directed graph displays 21 of Louvain clusters and (B) with superimposition of lineage gene scores for four lineage gene sets. Yellow – lymphoid cells; Cyan – myeloid cells; Red – erythroid cells; Purple – megakaryocytic cells; Gray – HSPCs that do not (or lowly) express lineage signature genes.\n(C and D) Diffusion maps of 21 Louvain clusters and with lineage gene scores in (D).\n(E and F) UMAP plots with identified clusters and trajectory paths using Monocle3 (E) and overlaid with pseudotime analysis scores (F).\n(G) Force-directed graph (FDG) with superimposition of pseudotime analysis scores.\n(H) Gene expression of selected lineage marker genes along pseudotime from HSC to erythroid trajectory representing across tissues.\n(I) The gene expression of chosen erythroid lineage genes, GATA1 and KLF1, along the pseudotime of HSC to erythroid trajectory.\nVisualize trajectories by using multiple lineages gene sets (Figure 8[href=https://www.wicell.org#fig8]B).\n> plot_forceDirectedGraph_label_by_multiple_gene_sets(Human_HSPC,\n        gmt.file = \"./Human_genesets/human.signature.genes.v1.gmt\",\n        show_gene_sets = c(\"Erythroid\",\"Myeloid\",\"Lymphoid\",\n                            \"Megakaryocyte\"),\n        custom_color = c(\"red\",\"cyan\",\"orange\",\"purple\"),\n      isNormalizedByHouseKeeping = F,\n      edge.size=0,\n      edge.color = \"#FFFFFF\",\n      vertex.size = 0.2,\n      showEdge = F,\n      showLegend = T)\nThe following parameters are required:\ngmt.file: Path to the file containing the gene signatures in GMT format.\nshow_gene_sets: The vector of gene signature names to show on the plot. The names must be the same names as found in the ‘gmt.file’.\ncustom_color: The assigned colors for gene signatures in ‘show_gene_set’.",
    "isNormalizedByHouseKeeping: When set to TRUE (default), the gene expression values of each gene signature specified will be normalized by the housekeeping genes. The housekeeping genes are defined as the top 100 genes with the highest total gene expression values across all cells.\nedge.size: The size of the edges connecting the nodes. Default value is 0.2.\nedge.color: The color of the edges. Default color is gray.\nvertex.size: The size of the nodes. Default value is 1.5.\nshowEdge: When set to TRUE (default), the edges will be displayed.\nshowLegend: When set to TRUE (default), the legend will be displayed.\nMethod 2: Diffusion map analysis\nLoad SingCellaR and destiny R packages.\n> library(SingCellaR)\n> library(destiny)\nLoad the integrated R object generated from step 52.\n> load(file = \"./Human_HSPC_All.SingCellaR.rdata\")\nRun diffusion map analysis. The user can use the ‘runDiffusionMap’ function to generate the diffusion map layout (embeddings). The layout can be annotated using various features, including cell lineage signature genes. We will use the Supervised harmony embeddings to generate the diffusion map layout.\n> runDiffusionMap(Human_HSPC,\n                        useIntegrativeEmbeddings = T,\n                        integrative_method = \"supervised_harmony\",\n                        n.dims.use = 40,\n                        n.seed = 10)\nThe following parameters are required:\nuseIntegrativeEmbeddings: If set to TRUE, the data integration or batch correction embeddings will be used in conjunction with ‘integrative_method’ argument. Default is FALSE.\nintegrative_method: The data integration or batch correction method name.\nn.dims.use: The number of PCs from ‘integrative_method’. If ‘useIntegrativeEmbedding’ is set to FALSE, the PCA result will be used. Default value is 30.\nn.seed: The random number generator. Default value is 1.\nVisualize trajectories by Louvain clustering (Figure 8[href=https://www.wicell.org#fig8]C).\n> plot_diffusionmap_label_by_clusters(Human_HSPC, show_method = \"louvain\")\nThe following parameter is required:\nshow_method: The clustering method name.\nVisualize trajectories by multiple lineages genes (Figure 8[href=https://www.wicell.org#fig8]D).\n> plot_diffusionmap_label_by_multiple_gene_sets(Human_HSPC,\n        gmt.file = \"./Human_genesets/human.signature.genes.v1.gmt\",\n        show_gene_sets = c(\"Erythroid\",\"Myeloid\",\"Lymphoid\",\"Megakaryocyte\",\n                            \"Endothelial_cells\"),\n        custom_color = c(\"red\",\"cyan\",\"orange\",\"purple\",\"green\"),\n        isNormalizedByHouseKeeping = F)",
    "The following parameters are required:\ngmt.file: Path to the file containing the gene signatures in GMT format.\nshow_gene_sets: The vector names of gene signatures to show in the plot. The names must be the same names as found in the gmt.file.\ncustom_color: The assigned colors for gene signatures in ‘show_gene_set’.\nisNormalizedByHouseKeeping: When set to TRUE (default), the gene expression values of the individual genes of each gene signature specified will be normalized by the housekeeping genes. The housekeeping genes are defined as the top 100 genes with the highest total gene expression values across all cells.\nMethod 3: Monocle3 analysis\nLoad SingCellaR and required R packages.\n> library(SingCellaR)\n> library(monocle3)\n> library(ggplot2)\n> library(ComplexHeatmap)\n> library(circlize)\n> library(RColorBrewer)\n> source('./utilis.R')\nLoad the integrated R object generated from step 52.\n> load(file = \"./Human_HSPC_All.SingCellaR.rdata\")\nPrepare input files for Monocle3. The required objects include the expression matrix of raw counts, cell cluster metadata, and gene metadata.\n# Expression matrix\n> cells.used <- Human_HSPC@sc.clusters$Cell\n> umi <- get_umi_count(Human_HSPC)\n> used.umi <- umi[,cells.used]\n> expression_matrix <- used.umi\n> dim(expression_matrix) # check the dimension of object\n# Cell cluster metadata\n> cell_metadata <- Human_HSPC@sc.clusters\n> rownames(cell_metadata) <- cell_metadata$Cell\n# Gene metadata\n> gene_annotation <- as.data.frame(rownames(used.umi))\n> colnames(gene_annotation) <- \"gene_short_name\"\n> rownames(gene_annotation) <- gene_annotation$gene_short_name\nCreate Monocle3 object.\n> cds <- new_cell_data_set(expression_data = expression_matrix,\n                                  cell_metadata = cell_metadata,\n                                  gene_metadata = gene_annotation)\nIntegrate Monocle3 and SingCellaR results. Monocle3 normalizes the raw gene counts, and then performs PCA. The user can run the default workflow as suggested by Monocle3 tutorial. In this step, we will replace Monocle3’s UMAP embeddings and add cluster information derived from the SingCellaR object.\n# Pre-process Monocle3 object\n> cds <- preprocess_cds(cds,num_dim = 100,method = \"PCA\")\n> cds <- align_cds(cds)\n# Substitute Monocle3's embeddings with SingCellaR's embeddings\n> embeddings <- >Human_HSPC@SupervisedHarmony.embeddings\n> cds@int_colData@listData$reducedDims$Aligned <- embeddings",
    "# Nonlinear dimension reduction\n> cds <- reduce_dimension(cds,\n                                reduction_method = \"UMAP\",\n                                  umap.min_dist = 0.3,\n                                  preprocess_method = \"Aligned\")\n# Identify and assign clusters\n> cds <- cluster_cells(cds,\n                            reduction_method = \"UMAP\",\n                              k = 30,\n                              cluster_method = \"louvain\")\n# Substitute Monocle3's UMAP embeddings with SingCellaR's embedding\n> newcds<- cds # change monocle3 objects name\n> SingCellaR.umap <-,c(\"Cell\",\"UMAP1\",\"UMAP2\")]\n> Human_HSPC@umap.result[monocle3.umap <- newcds@int_colData$reducedDims$UMAP\n> umap <- SingCellaR.umap[match(rownames(monocle3.umap),SingCellaR.umap$Cell),]\n> rownames(umap) <- umap$Cell\n> umap$Cell <- NULL\n> newcds@int_colData$reducedDims$UMAP <- umap\n# Substitute Monocle3's cluster identity with SingCellaR's cluster identity\n> anno.clusters <- Human_HSPC@sc.clusters$louvain_cluster\n> names(anno.clusters) <- Human_HSPC@sc.clusters$Cell\n> newcds@clusters$UMAP$clusters <- anno.clusters\nGenerate trajectory graph and order cells by pseudotime. To learn the cell differentiation trajectories, the user will use the ‘learn_graph’ function provided by Monocle3. By default, Monocle3 uses a 'self-defined' node to perform the pseudotime analysis. Thus, the user will need to define the root node, i.e., the most immature cluster. To identify the root node, the user can use the ‘get_earliest_principal_node’ function. Based on the previous analyses, the user can select ‘cl1’, the HSC/MPP cluster, as the starting point of the trajectory.\n> newcds <- learn_graph(newcds)\n# Apply function to retrieve root node\n> root.nodes <- get_earliest_principal_node(newcds,cluster = \"cl1\")\n# Order cells by pseudotime relative to root node\n> newcds <- order_cells(newcds, root_pr_nodes = root.nodes)\n# Save R object\n> save(newcds,file = \"./Human_HSPC_monocle3.rdata\")\nVisualize trajectory paths on UMAP (Figure 8[href=https://www.wicell.org#fig8]E).\n> plot_cells(newcds,\n                  group_label_size = 5,\n                  color_cells_by = \"louvain_cluster\",\n                  show_trajectory_graph = T,\n                  label_roots = T,\n                  label_cell_groups = T,\n                  label_groups_by_cluster = T,\n                  label_leaves = F,\n                  label_branch_points = F)\nVisualize pseudotime on UMAP (Figure 8[href=https://www.wicell.org#fig8]F).\n> plot_cells(newcds,\n                  color_cells_by = \"pseudotime\",\n                  show_trajectory_graph = F,\n                  label_roots = T,\n                  label_cell_groups=F,\n                  label_leaves=F,\n                  label_branch_points=F,\n                  graph_label_size=1.5,\n                  group_label_size=4,\n                  cell_size=1.5)\nVisualize pseudotime on SingCellaR FDG (Figure 8[href=https://www.wicell.org#fig8]G). Before plotting FDG, the user can remove the endothelial cells (cl17).\n# Remove endothelial cell cluster",
    "> sc.clusters <- Human_HSPC@sc.clusters[!(Human_HSPC@sc.clusters$louvain_cluster == \"cl17\"),]\n> fa2 <- Human_HSPC@fa2_graph.layout\n> fa2.used <- fa2[rownames(fa2) %in% sc.clusters$Cell,]\n# Extract the pseudotime information\n> new_data <- data.frame(pseudotime = pseudotime(newcds,reduction_method = \"UMAP\"))\n> new_data$Cell <- rownames(new_data)\n> new_data <- new_data[new_data$Cell %in% rownames(fa2.used),]\n# Integrate pseudotime with FDG embeddings\n> fa2.used <- fa2.used[match(new_data$Cell,rownames(fa2.used)),]\n> colnames(fa2.used) <- c(\"FDG1\",\"FDG2\")\n> fa2.dat <- cbind(fa2.used,new_data)\n# Plot FDG\n> ggplot(data = fa2.dat,aes(x = FDG1,y = FDG2)) +\n      geom_point(size = 0.05,aes(color = pseudotime)) +\n      scale_color_viridis_c(name = 'Pseudotime',option = \"C\")+\n      theme_classic() +\n      xlab(\"FDG1\") +\n      ylab(\"FDG2\")\nVisualize the expression of selected genes along the paths. We plot erythroid lineage genes as the example.\nAdd developmental stages information to the metadata.\n# Retrieve UMAP coordinates and annotate with cluster information\n> sc.clusters <-Human_HSPC@sc.clusters\n> umap.results <- Human_HSPC@umap.result\n> umap.results <- merge(umap.results,sc.clusters, by = \"Cell\")\n### Add developmental stage information\n> umap.results$stage[umap.results$sampleID %in% c(\"1_eFL_1\",\"1_eFL_2\")]<- \"eFL\"\n> umap.results$stage[umap.results$sampleID %in% c(\"1_ABM_1\")]<- \"ABM\"\n> umap.results$stage[umap.results$sampleID %in% c(\"1_FL_1\",\"1_FL_2\")]<- \"FL\"\n> umap.results$stage[umap.results$sampleID %in% c(\"1_FBM_1\",\"1_FBM_2\")]<- \"FBM\"\n> umap.results$stage[umap.results$sampleID %in% c(\"1_PBM_1\",\"1_PBM_2\")]<- \"PBM\"\nDefine the path for the erythroid lineage based on the FDG, diffusion map, and Monocle3. We selected the path ‘cl1-cl7-cl12-cl3’ for the erythroid lineage.\n> Ery.path <- c(\"cl1\",\"cl7\",\"cl12\",\"cl3\")\nExtract cells from the erythroid trajectory for all stages.\n> umap.results.Ery <- umap.results[umap.results$louvain_cluster %in% Ery.path,]\n> cells.eFL <- umap.results.Ery$Cell[umap.results.Ery$stage == \"eFL\"]\n> cells.FL <- umap.results.Ery$Cell[umap.results.Ery$stage == \"FL\"]\n> cells.FBM <- umap.results.Ery$Cell[umap.results.Ery$stage == \"FBM\"]\n> cells.PBM <- umap.results.Ery$Cell[umap.results.Ery$stage == \"PBM\"]\n> cells.ABM <- umap.results.Ery$Cell[umap.results.Ery$stage == \"ABM\"]\nExtract genes known to be involved in the erythroid trajectory based on the pseudotime.\n> genes.E <- c(\"FAM178B\",\"TRIB2\",\"BLVRB\",\"RHAG\",\"PNMT\",\n                  \"APOE\",\"APOC1\",\"S100A6\",\"KLF1\",\"PVT1\",\n                  \"KCNH2\",\"EPOR\",\"MYH10\",\"S100A4\",\n                  \"MYL4\",\"EMP3\",\"CYTOR\",\"CNRIP1\",\"GATA1\",\"SMIM1\")\n> matrix <- newcds@assays@data$counts\n> pt.matrix<-\n      matrix[match(genes.E,rowData(newcds)[,1]),order(pseudotime(newcds))]\nExtract gene expression matrix for each group of cells.\n> pt.matrix.eFL <- ExtractMatrix(pt.matrix = pt.matrix,genes = genes.E,path =\n      Ery.path,selected.cells = cells.eFL)\n> pt.matrix.FL <- ExtractMatrix(pt.matrix = pt.matrix,genes = genes.E,path =\n      Ery.path,selected.cells = cells.FL)",
    "> pt.matrix.FBM <- ExtractMatrix(pt.matrix = pt.matrix,genes = genes.E,path =\n      Ery.path,selected.cells = cells.FBM)\n> pt.matrix.PBM <- ExtractMatrix(pt.matrix = pt.matrix,genes = genes.E,path =\n      Ery.path,selected.cells = cells.PBM)\n> pt.matrix.ABM <- ExtractMatrix(pt.matrix = pt.matrix,genes = genes.E,path =\n      Ery.path,selected.cells = cells.ABM)\nPlot gene expression heatmap along the path of the different developmental stages (Figure 8[href=https://www.wicell.org#fig8]H).\n> ht1 <- plot_development_heatmap(pt.matrix.eFL,subtitle = \"eFL\")\n> ht2 <- plot_development_heatmap(pt.matrix.FL,subtitle = \"FL\")\n> ht3 <- plot_development_heatmap(pt.matrix.FBM,subtitle = \"FBM\")\n> ht4 <- plot_development_heatmap(pt.matrix.PBM,subtitle = \"PBM\")\n> ht5 <- plot_development_heatmap(pt.matrix.ABM,subtitle = \"ABM\")\n> ht.full <- ht1+ht2+ht3+ht4+ht5\n> ht.full\nExtract gene expression from downsampled cells along the path from different developmental stages and pseudotime from ‘newcds’ object from step 83.\n> Ery.eFL <- ExtractCells(selected.cells = cells.eFL)\n> Ery.FL <- ExtractCells(selected.cells = cells.FL)\n> Ery.FBM <- ExtractCells(selected.cells = cells.FBM)\n> Ery.PBM <- ExtractCells(selected.cells = cells.PBM)\n> Ery.ABM <- ExtractCells(selected.cells = cells.ABM)\n> matrix <- newcds@assays@data$counts\n> matrix.total <-Matrix::colSums(matrix)\n> norm.matrix <-(t(t(matrix)/matrix.total))∗10000\n> expr.eFL <- norm.matrix[genes.E,Ery.eFL]\n> expr.eFL <- reshape2::melt(as.matrix(expr.eFL))\n> colnames(expr.eFL) <- c(\"Gene\",\"Cell\",\"NormUMI\")\n> expr.eFL$Stage <- \"eFL\"\n> expr.FL <- norm.matrix[genes.E,Ery.FL]\n> expr.FL <- reshape2::melt(as.matrix(expr.FL))\n> colnames(expr.FL) <- c(\"Gene\",\"Cell\",\"NormUMI\")\n> expr.FL$Stage <- \"FL\"\n> expr.FBM <- norm.matrix[genes.E,Ery.FBM]\n> expr.FBM <- reshape2::melt(as.matrix(expr.FBM))\n> colnames(expr.FBM) <- c(\"Gene\",\"Cell\",\"NormUMI\")\n> expr.FBM$Stage <- \"FBM\"\n> expr.PaedBM <- norm.matrix[genes.E,Ery.PBM]\n> expr.PaedBM <- reshape2::melt(as.matrix(expr.PaedBM))\n> colnames(expr.PaedBM) <- c(\"Gene\",\"Cell\",\"NormUMI\")\n> expr.PaedBM$Stage <- \"PBM\"\n> expr.AdultBM <- norm.matrix[genes.E,Ery.ABM]\n> expr.AdultBM <- reshape2::melt(as.matrix(expr.AdultBM))\n> colnames(expr.AdultBM) <- c(\"Gene\",\"Cell\",\"NormUMI\")\n> expr.AdultBM$Stage <- \"ABM\"\n> expr.Ery <- rbind(expr.eFL,expr.FL,expr.FBM,expr.PaedBM,expr.AdultBM)\nExtract the pseudotime information from Monocle3 results.\n> pseudotime <- as.data.frame(pseudotime(newcds))\n> colnames(pseudotime) <- \"pseudotime\"\n> pseudotime$Cell <- rownames(pseudotime)\n> pseudotime$pseudotime[pseudotime$pseudotime %in% \"Inf\"] <- 0\n> pseudotime <- pseudotime[order(pseudotime$pseudotime,decreasing = F),]\nMerge gene expression data with pseudotime analysis results.\n> expr.Ery <- merge(expr.Ery,pseudotime,by = \"Cell\",)\nVisualize selected erythroid gene expression along the path (Figure 8[href=https://www.wicell.org#fig8]I).\n> plot_genes(data = expr.Ery,genes = \"GATA1\")\n> plot_genes(data = expr.Ery,genes = \"KLF1\")"
  ],
  "subjectAreas": [
    "Rnaseq",
    "Stem Cells",
    "Bioinformatics",
    "Systems Biology",
    "Single Cell"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}