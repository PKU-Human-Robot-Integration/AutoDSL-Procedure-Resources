{
  "id": 19706,
  "origin_website": "Wiley",
  "title": "Population Genetic Inference With MIGRATE",
  "procedures": [
    "This protocol assumes that the user has installed the program using the Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0004].\nThe steps below represent the first encounter of a novice user with MIGRATE. They show the basic operations needed to open and run MIGRATE on a dataset. The protocol does not discuss how to modify population models. It uses default values for all parameters and options for a very first run; however, further refinement will help to improve the results. Population model options and run-time options will be discussed in Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002].\nNecessary Files\nThe datafile\nThe input data are specified in a file named infile by default. Before running MIGRATE, make sure that the infile is in the same directory as the executable migrate-n, or that the path to the executable is known.\nThe infile can contain different types of genetic data, such as DNA sequences, linked or unlinked single nucleotide polymorphisms, microsatellite repeat data, or allozyme data. The MIGRATE manual contains examples of each of these datatypes and format specifications. It is absolutely necessary to study the data section in the manual before proceeding to run the program with your own data. Several converters take data in different formats and convert them to the MIGRATE-specific format. For example, PGD-Spider (Lischer & Excoffier, 2012[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0011]) allows changing to MIGRATE data format from a large selection of other formats. Building the datafiles from scratch or using a scripting language is usually simple.\nDescription of the tutorial data set",
    "The dataset used for this protocol was simulated using a software application called ms, developed by Hudson (2002[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0009]). This software generates a sample from a structured population. We simulated data for a sample of 30 individuals taken from three populations (see Fig. 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0001]): two populations, named Arbon (A) and Berg (B), exchange a sizeable number of migrants (two migrants per generation); the third population split off from B and established a population in Chur (C). The populations A and B are equal in size and each is about one-third of the population C. Sequence data were simulated for 10 independent loci of 1000 base pairs for each individual. We would expect that the data will make it difficult to establish that A and B are independent populations because they exchange more than one migrant per generation, but make it easy to recognize the divergence time between B and C. We set the population genetic parameters so that the data have sufficient variability to allow differentiation among some population genetic models.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/89c04334-5d57-407b-93ff-69fb8efa8c95/cpbi87-fig-0001-m.jpg</p>\nFigure 1\nDefault population model for three populations; all populations receive migrants from all others. Three different ways to represent the same population model are shown. The graph on the left represents each population in time, assuming gene flow (arrows) is recurrent among all of them; the middle graph represents only the interaction among populations without a time component; the matrix on the right is an adjacency matrix where the diagonal represents the population sizes and off-diagonal represents immigration connections (more detail on this adjacency matrix in the Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002]).\nParmfile\nThe parmfile is a text file that handles the program's runtime and model settings; it can replace the menu completely. It consists of six main sections:\nGeneral Options",
    "Allows some MIGRATE-specific options (these options should rarely be changed by users, but are described in the reference manual).\nData Options\nFour main settings manage the different data types; Infinite Allele, Stepwise Mutation, and Finite Sites Mutation (this includes DNA/RNA sequences or single nucleotide polymorphisms), which are explained briefly in the parmfile.\nInput Options\nOther modifications of the input file, such as the file location, random number seed specification, and the title of the run can be set.\nOutput Options\nThis section defines the intermediate and final representation of results. The user can change the verbosity of the progress report, setting the filenames for the output, which will be written into a text file and a PDF file. The options also allow printing into a file of all visited genealogies during the run. There are several advanced options, such as recording the times of coalescent and migration events that will allow generation of skyline plots (see Drummond, Rambaut, Shapiro, & Pybus, 2005[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0007]). The Program output contains detailed documentation about the individual parts of the output file.\nParameter start settings\nMIGRATE uses a Markov chain Monte Carlo (MCMC) to generate the output. MCMC is a very general method to search a large, complex parameter space and record visited parameter values that are used to generate the posterior probability density distribution of all parameters of interest. To do this, we need to have start values for the parameters. These parameters can be drawn at random or can be set specifically.\nSearch strategies",
    "MCMC methods run for arbitrarily long times; the runtime parameters define the length of the run and are important for the quality of the results. Runs that are too short will not explore the parameter space sufficiently; extremely long runs will deliver good results, but these results might also be achieved with much shorter runs. The defaults set for this section will lead to relatively short runs and almost always need improvement. This section defines the prior distributions needed for the Bayesian inference as well as the proposal distribution, and specifies the number of samples taken along the MCMC chain.\nThe resources for this basic protocol contain a datafile (infile), and three different parmfiles (parmfile_tooshort, parmfile_short, and parmfile_default). The run will take a few hours with the parmfile_default but only minutes with parmfile_tooshort. The runtime differences lead to different outcomes: the very short runs will not have converged, but this allows us to show how to improve the program run. These steps can then be used on the real data in similar ways.\nInstalling the program\nFollow the instructions in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0004].\nExploring the Menu of MIGRATE\nIn this protocol, we do not intend to get results from MIGRATE but to familiarize users with starting the executable and examine the menu options.\nTo run MIGRATE, you will need a specially formatted dataset which, by default, is named infile. The manual contains detailed instructions on the data format; also see the “Necessary Files” section. MIGRATE does not specifically recognize or ignore file extensions such as .txt; if you use these, they become part of the filename and cannot be omitted.",
    "For most users, it may be easiest if the executable migrate-n is located in the same directory as the datafile (see Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0004]). On some systems that hide the file extensions, they should be made visible. We suggest that users on Macs check the box for “Show all filename extensions” or on Windows uncheck the box “Hide extensions for known file types.”\n1. Start the program. The program can be run using one of the following commands in the command/terminal window:\n         \ntable:\n﻿0\n#if the system knows the path to executable\nmigrate-n\n#if the executable is in the same directory\n./migrate-n\n#user specified location of executable\n/pathtoexecutable/migrate-n\nOnce executed, MIGRATE displays a menu (Fig. 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0002]). The header of the menu displays the type of the executable and its version number, and the current time and date. The main menu contains four different sub-menus providing access to major sections of the program and two options. The first sub-menu (D) permits manipulating data-related parameters; with the sub-menu (I), input and output-related filenames can be changed; and (P) is a sub-menu to manage the population models (see Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002]). In this basic protocol, we discuss the crucial sub-menu (S), Search Strategy; several options in this sub-menu need to be changed to generate good results with the program. The (W) option saves all options into a file, by default named parmfile. This file is a text file and can be edited either with a text editor or through the menu. If you do not use this option, all changes will be lost once the program is closed.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/1c445457-dc52-49fc-87a1-78a1823a65c6/cpbi87-fig-0002-m.jpg</p>\nFigure 2\nMIGRATE main menu.",
    "2. Explore the submenus. Modify the search strategy by selecting (S), the Search Strategy menu, and then press 9 (see “9 Sampling increment?” in the menu) to change the sample recording increment. Use 3 for the increment. This change modifies the option long-inc in the parmfile.\nMIGRATE does not record all the updates along the MCMC chain because that would lead to substantial intermediate storage requirements. The options long-sample and long-inc, under Bayesian MCMC Strategy method, are the number of sampled updates and the number of updates that are skipped, respectively. For example, with long-inc=3 and long-sample=6, MIGRATE will record parameter values for the steps 0, 4, 8, 12, 16, and 20.\n3. Press Y to step out of the sub-menu and go back to the main menu. Press W to save your changes into the file parmfile. Once you have done that, Press Q to quit the program.\nNote that we have not run any analysis yet, but have modified the parmfile.\n4. Open the parmfile with a text editor (on the command line, use emacs or vi; graphical editors such a Textedit.app for Mac or Notepad for Windows will also work). Have a glance at the structure of the parmfile, compare with the description of the parmfile in Necessary Files, “Parmfile,” above. Search for long-inc and verify that you changed that to 3 with the menu. Then, quit the file without saving.\nOptions that start in the first column will be used; lines that start with # are comments and give explanations about the options.\nOnce you have a parmfile written, you can rename the parmfile and use it. For example, you could rename the parmfile and run MIGRATE using the following commands:\n         \ntable:\n﻿0\ncp parmfile newparmfile\ntable:\n﻿0\nmigrate-n newparmfile",
    "Then, MIGRATE will use the options from the newparmfile and not the defaults. We will see the use of custom parmfiles in the next section where we start with the actual tutorial.\nRunning the program\nThis protocol aims to provide guidelines for novice users of MIGRATE. The first run applies a basic population genetic model to estimate mutation-scaled population sizes and mutation-scaled immigration rates from a dataset with three populations; therefore, there will be three population sizes and six immigration rates between all populations.\nPreparation: Install the MIGRATE program using the instructions in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0004]. Then, download the file currentprotocols.tar.gz from https://peterbeerli.com/migrate/tutorials/[href=https://peterbeerli.com/migrate/tutorials/] and unpack using these commands:\n         \ntable:\n﻿0\ncurl -O https://peterbeerli.com/tutorials/currentprotocols.tar.gz tar zxvf currentprotocols.tar.gz cd currentprotocols/basic_protocol1\nThere is also a version of the tutorial deposited on github: https://github.com/pbeerli/currentprotocols[href=https://github.com/pbeerli/currentprotocols].\nOnce the preparation step is completed, the user will have a directory basic_protocols1 containing the following files:\n         \nREADME\nbasic_protocol1.sh\nbasic_protocol1_mpi.sh\nexample_results\ninfile\nparmfile_default\nparmfile_short\nparmfile_tooshort\nThe small dataset called infile will be used in this protocol; the other files will be discussed shortly. The infile dataset consists of 10 loci and three locations, named Arbon or A, Berg or B, and Chur or C. This dataset was simulated with a known population model and will be used for all protocols. Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001] treats all locations as populations with migration, and therefore does not need an adjustment of the custom migration model (which is explained thoroughly in Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002]). Mastering the runtime specification (this protocol) and mastering model specification is important in order to achieve results with MIGRATE.\n5. Create a directory and copy the infile and parmfile_tooshort into this directory; for example, in UNIX/Mac on the command line:\n         \ntable:\n﻿0",
    "\"# we assume that you are in the directory basic_protocol1 # this step creates a new directory, changes into it # and copies files to use mkdir temp_protocol1 cd temp_protocol1 cp ../infile cp ../parmfile_tooshort\"\n6. Start the program. For instructional purposes, we use parmfile_tooshort. Now, run the command:\n         \ntable:\n﻿0\nmigrate-n parmfile_tooshort\nIf you run your own data, start migrate-n without options or parmfile, then use the menu to change options and use the main menu option “(W) write a parmfile” to create a parmfile. The parmfile can be modified by hand or through the menu. Some options, in particular complex population models, are easier to edit using a text editor than using the menu. To use a hand-modified parmfile, we suggest renaming the file, e.g., to parmfile_modified, and then calling MIGRATE-n parmfile_modified. However, editing by hand has no fail-safe mechanism and may lead to overwriting or even using the wrong options. Changes using the menu and then using the (W) option to rewrite the parmfile will always provide the correct option syntax.\n7. For a first run, we use the options set by parmfile_tooshort without any additional changes. Once the menu is displayed, type Y or Yes to run the program. If the program cannot find your infile, it will show a warning, and you may be able to tell MIGRATE where your infile is. After three unsuccessful tries, it will quit. As soon as the program runs, it will create an output file called outfile in your directory.",
    "Usually, MIGRATE runs will take a considerable amount of time. The program defaults (parmfile_defaults) are set so that the example dataset runs for about 2 hr, but we are using parmfile_tooshort in this protocol first, and this will finish the run in a few minutes. For large datasets, even the default will lead to insufficient runtimes. The following steps will discuss how one can spot problems and improve the inference. During the run, the program provides information about the progress (Fig. 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0003]).\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/bbaa6d21-a4a5-43e1-8d3f-ba94a9fa4d81/cpbi87-fig-0003-m.jpg</p>\nFigure 3\nExample of an output during the run of the program: the information block contains a time stamp; the prognosed time of completion; parameter acceptance ratios; and current parameter value. The Propwindow column describes the size of the proposal window in the Markov chain Monte Carlo (MCMC) run, AutoCorr is the autocorrelation among parameter values, and ESS is the effective sample size of the MCMC.\n8. Once the program has finished, check the content of outfile_tooshort and outfile_tooshort.pdf. outfile_tooshort will be created at the beginning of the run, and options will be copied into it for the first few seconds of the run. When the process finishes, outfile_tooshort will be filled with the results, and another file named outfile_tooshort.pdf will be created (the outfile_tooshort name is specified in the parmfile_tooshort that was used for this run).\nBoth files contain the executed options and a table reporting the values of the posterior distribution of all parameters. The PDF file also includes histograms of these posterior distributions. If migrate-n “finished” and did not create the PDF file, then it crashed! See Troubleshooting.\n9. As a first step in the analysis of these files, you will need to figure out whether the run was appropriate:\n         \nInvestigate outfile_tooshort.pdf",
    "This file contains a table with the mode, median, mean, and credibility sets of the posterior distribution of the parameters, and histograms depicting the posterior distribution for every estimated parameter. The parameters shown in the tables or histograms depend on the population model. If the values are all blank or zero, or very large, then most likely the run failed (see discussion of the Bayesian posterior probability table in Guidelines for Understanding Results; also see Fig. 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0004]).\nInspect the histograms. If the histograms are jagged or show multiple peaks, this suggests that the run was not long enough, Figure 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0004] (leftmost) shows an example of a problematic posterior distribution. One can fix such problems by increasing the runtime, either by increasing the number of sampled steps (long-sample) or by increasing the increment between the samples (long-inc); the second option is less memory intensive and leads to results similar to the increase of the long-sample option.\nAdditionally, you should inspect the Effective Sample Size (ESS) in the output file; if these numbers per parameter are not in the thousands, then there will likely be problems with the run. The ESS measures the number of independent samples taken throughout the program run; each step is dependent on (correlated with) the step before. The option long-inc defines how many steps are not recorded to reduce this correlation. ESS should always be large; any number below 200 indicates that the runs need to improve.\nThere are programs, such as the program tracer (Rambaut, Drummond, Xie, Baele, & Suchard, 2018[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0013]), to evaluate the output (see in the Troubleshooting section for details on that), but often we do not need additional software to judge. The outfile.pdf is usually the best place for looking at the results.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/a72c37e3-8d75-4a44-925a-c9325932aaa1/cpbi87-fig-0004-m.jpg</p>\nFigure 4",
    "Example of histograms of the same mutation-scaled immigration rates of three runs with different run length; the left run had set options that led to a runtime that is 100× shorter than the rightmost run. The leftmost histogram shows signs of problems.\n10. Re-run the analysis with more long-sample or increased long-inc: for example, use parmfile_short or parmfile_default and compare with the outputs from step 9. These parmfiles have increased long-inc, but you can do this through the menu using “(S) Search Strategy” and then “9 Sampling increment.” MIGRATE will then show “How many steps (tree changes, parameter changes) to skip?”. Then, enter 10; this value of 10 is equivalent to the value in the parmfile_short. Then, type Y to step out of the menu to the master menu. Once at the master menu, press Y to run the program or use the command below:\n         \ntable:\n﻿0\n# we assume you are in directory temp_protocol1 cp ../parmfile_short parmfile_short migrate-n parmfile_short -nomenu\nor for using long-inc=100 use:\n         \ntable:\n﻿0\n\"# we assume you are in directory temp_protocol1 cp ../parmfile_default parmfile_default # for long runs on macs and unix, # we suggest to use the nohup facility nohup migrate-n parmfile_default -nomenu > parm_default.log 2> parm_default.err\"\n-nomenu will start the program without directly going to the main menu. The nohup system command allows the continuation of the run even when the terminal window quits or the user logs out of the system; the output of the standard log to the screen will be captured in the file parm_default.log and errors will be captured in parm_default.err.",
    "Increase the runtime when the histograms do not look unimodal. In cases with low immigration rates, the histogram can peak at zero, or very close to zero, suggesting that the immigration parameter is close to zero. If the distribution peaks at the upper bound of the prior distribution, you will need to increase the prior distribution bound. For these changes, see Troubleshooting.\nWith some datasets, it is very difficult to improve all the model parameters. With DNA sequence data, the population sizes are usually easy to estimate while immigration rates and divergence times are much more difficult. For microsatellite data, it is difficult to estimate population sizes reliably, but the immigration rates are less problematic. If the histograms of most of the parameters are unimodal, with a few that are not, and the model is complicated (see Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002]), then one may need to stop and accept that some parameters cannot be well estimated with the data.\nIn the tutorial package, there is also a file called basic_protocol1.sh that runs the complete sequence of Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001]. It will take several hours:\n         \ntable:\n﻿0\n# we assume you are in directory basic_protocol1 . basic_protocol1.sh",
    "This protocol will help the user to create and change different population genetic models. MIGRATE can handle a variety of models that are specified through two options in the parmfile: an option that allows manipulating the connection among populations with an adjacency matrix (custom-migration) and an option that manipulates the mapping of locations to populations (population-relabel). The two options are explained in more detail below.\nThree different models are used in this tutorial. These models were chosen to demonstrate particular changes in the parmfile. More complex models are possible; the web page https://peterbeerli.com/migrate/tutorials.html[href=https://peterbeerli.com/migrate/tutorials.html] will eventually contain more exotic examples. We will use the same dataset as in Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001], but will now adjust the population model specification in the parmfile. These specifications can be adjusted through the menu, but often it is easier to simply edit the parmfile with a text editor (make certain that your text editor is not tacking on invisible .txt file endings, because MIGRATE will need to know the complete filenames). The models are as follows; compare with Figure 5:[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/694b19ce-719d-4179-a905-d4adffbf037b/cpbi87-fig-0005-m.jpg</p>\nFigure 5\nExample models. 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-disp-0001] Three models: recurrent immigration, recurrent immigration after divergence, and divergence (from left to right). 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-disp-0002] to (5) Suggested steps to build up the adjacency matrix. The populations used for the data and these models are named Arbon (A), Berg (B), and Chur (C). In the rightmost column, A and B were pooled and considered a single population AB.\nModel 1: Migrants from the population Arbon (A) arrive in Berg (B) and migrants from Berg arrive in Chur (C) (Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], column 1).\nModel 2: Chur splits off Berg, and Berg splits of Arbon; after the splits, there is still a stream of migrants as in Model 1 (Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], column 2).",
    "Model 3: Arbon and Berg are pooled into a combined population labeled “AB”; Chur splits off of “AB” with no migration after the split (Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], column 3).\nNote that the population-relabel option defines how the locations in the infile are used during the run. By default, every location is its own panmictic population. population-relabel allows locations to be combined into populations by changing their labeling; the discussion of Model 3 in this protocol will describe this in detail.\nThe custom-migration option is specified as a linearized adjacency matrix. Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005] introduces three different models and shows how the model graph can then be transformed into an option statement. The entries in the adjacency matrix define whether a population receives migrants from another population, if it is a population that split off from another ancestral population, or if it does not have contact with another population. Adjacency matrices must be connected graphs. An adjacency matrix with two disconnected sub-graphs will lead to failure while running the program because two disconnected population groups can never coalesce when we reconstruct the relationships among individuals of the two groups.\nNecessary Files\nNecessary files are the same as in Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001].\nProtocol Steps\nWe suggest reusing the parmfile that was used in Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001]. Perhaps copy it from parmfile_default to parmfile_model1 for the first model and parmfile_model2 for the second, etc. Using parmfile_default will take considerable time; for a quick pass through this tutorial we suggest using parmfile_short, but that may lead to runs that are not consistent, and these will then lead to different model probabilities in the following Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0005]. You also may want to change the output file names before you proceed; this makes sure that you do not overwrite your earlier output files.\nPreparation",
    "Prepare the parmfile for changing the population model. For a quick run through the tutorial use:\n         \ntable:\n﻿0\n# we assume you are in the directory currentprotocols cd basic_protocol2 mkdir temp_protocol2 cd temp_protocol2 cp ../../basic_protocol1/infile infile cp ../../basic_protocol1/parmfile_short parmfile_model1 cp ../../basic_protocol1/parmfile_short parmfile_model2 cp ../../basic_protocol1/parmfile_short parmfile_model3\nfor better results use:\n         \ntable:\n﻿0\n# we assume you are in the directory currentprotocols cd basic_protocol2 mkdir temp_protocol2 cd temp_protocol2 cp ../../basic_protocol1/infile infile cp ../../basic_protocol1/parmfile_default parmfile_model1 cp ../../basic_protocol1/parmfile_default parmfile_model2 cp ../../basic_protocol1/parmfile_default parmfile_model3\nThe next steps discuss the modification of the population model. This can be done in two ways—either through the menu or using a text editor. Designing new population models can be challenging. One approach is to (a) sketch the connection graph (examples are in Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], step 1) on a piece of paper; then (b) write out the adjacency matrix (or connection matrix) (Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], steps 2 to 5) among all populations; and then (c) fill in the options. We suggest using a text-editor method because that simplifies building more complicated models from simpler models using copy/paste.\nModel 1\n1a. Draw the graphical model, label the populations, and copy the first model in Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005] (the first column from the left). Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005] contains all the information for the model, but it is important to learn to do this without guidance from the figure; for example, we can express the relationship among the three populations as a graph through time or at a particular time.",
    "2a. Draw the adjacency matrix—this is a square matrix where the diagonal elements mark the population sizes. If you label them with an ‘x’ or ‘*’, then this means that these population sizes will be estimated. Several other options are possible; you may want to explore them in the reference manual. All diagonal elements must contain a symbol other than 0 (see Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], row 2).\n3a. Fill in the adjacency matrix (steps 3 to 5 in Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]). In your graph sketch, there is an arrow from A to B; this translates into a x or * in the first column and second row of the adjacency matrix. In general, we would say the FROM population are the column labels and the TO populations are the row labels.\nIn your graph there is an arrow from B to C, draw an x in the column with the B and the row with the C; this has now filled the second column, third row.\nAfter the above changes, your sketch does not contain more information; fill all remaining elements of the matrix that you did not touch with 0.\nNow use your adjacency matrix and linearize it so that you concatenate the first row and the second row and the third row, for Model 1 this looks like: {x00 xx0 0×x}.\nNext, find in parmfile_model1 the line that starts with custom-migration and then edit that line using your prepared linearized adjacency matrix to read:\n         \ntable:\n﻿0\ncustom-migration={x00 xx0 0×x}",
    "The {x00 xx0 0×x} indicates that the first population has no immigration, while the second population gets migrants from the first population, and the third population gets migrants from the second population. Thus, the three rows in step 5 of Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005], Model 1, have been converted to one row in the custom-migration specification.\nThe default for the custom-migration option is custom-migration={**}. For our Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001] example with three populations, this will be extended to custom-migration={*********} (9 positions); remember * and x are equivalent, and spaces are inconsequential. MIGRATE will extend an incomplete option using the last character in the custom-migration option.\nNext find in the parmfile_model1 the lines that start with outfile and pdf-outfile, then edit these to the following and save your edits:\n         \ntable:\n﻿0\noutfile=outfile_model1 pdf-outfile=outfile_model1.pdf\n4a. Run the program:\n         \ntable:\n﻿0\nmigrate-n parmfile_model1 -nomenu\nYou can also use the nohup facility to run the models (see last example in the Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001]).\nLook at the results and compare them to the Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001]; there are fewer parameters in the tables and histograms. The same approach should be used with Model 2 and Model 3.\nModel 2\n1b. Draw the graphical model and label the populations, using Model 2 in Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005] as a guide.\n2b. Draw the square adjacency matrix. Mark the diagonal elements with x, indicating that that value will be estimated (see Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]).",
    "3b. Fill in the adjacency matrix (steps 3 to 5 in Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]). In the graph for Model 2, there is a divergence with recurrent immigration from the ancestral population ‘A’ to ‘B’; this translates into a D in the first column and second row of the adjacency matrix. We use the column label, here A, as the ancestor, and the row label, here B, as the descendent (for details refer to Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005] and also refer to the reference manual).\nIn the graph, there is a divergence with recurrent immigration from the ancestral column population B to column C. This has now filled the second column, the third row of Model 2 with D.\nYour sketch does not contain any more information; fill all elements of the matrix that you did not touch with 0.\nNow use your adjacency matrix for Model 2 and concatenate the first row, the second row, and the third row. This looks like {x00 Dx0 0Dx}.\nThe parmfile model2 needs to have this custom-migration setting. Find the line that starts with custom-migration, the edit the line so that it looks like:\n         \ntable:\n﻿0\ncustom-migration={x00 Dx0 0Dx}\nThen, find in the parmfile_model2 the lines that start with outfile and pdf-outfile, then edit these to the following:\n         \ntable:\n﻿0\noutfile=outfile_model2 pdf-outfile=outfile_model2.pdf\n4b. Run the program:\n         \ntable:\n﻿0\nmigrate-n parmfile_model2 -nomenu\nFor details on the nomenclature for all the possible characters in the adjacency matrix, consult the manual. In Model 2, we used ‘D’, which specifies a divergence with consecutive immigration, whereas in the following Model 3, we will use ‘d’, which specifies a divergence without consecutive immigration.\nModel 3\n1c. Draw the graphical model and label the populations using Figure 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005] (rightmost column) as a guide.",
    "2c. Draw the square adjacency matrix. Here, the adjacency matrix has changed from 3 × 3 into 2 × 2 because we pooled the first two populations as a combined population. Mark the diagonal elements with x, indicating they are to be estimated (see Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]).\n3c. Fill in the adjacency matrix (steps 3 to 5 in Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]). For Model 3, in the graph there is just a divergence from the ancestral column population ‘A, B’ to column ‘C’; this translates into a ‘d’ in the first column and second row of the adjacency matrix.\nYour sketch does not contain any more information; fill all elements of the matrix that you did not touch with 0.\nUse now your adjacency matrix for Model 3 and concatenate the first row and the second row. This looks like {x0 dx}.\nAdapt the custom-migration setting in parmfile_model3 to:\n         \ntable:\n﻿0\ncustom-migration={x0 dx}\nWe pooled the first two populations A and B; the parmfile_model3 needs thus a change of the population-relabel option. Find the option in parmfile_model3 and then edit it so that looks like:\n         \ntable:\n﻿0\npopulation-relabel={1 1 2}\nThis option takes the ‘populations’ from the infile and pools them so that the first and second population are relabeled as population 1 and the third is relabeled as population 2.\nThen, edit in the parmfile_model3 lines that start with outfile and pdf-outfile to read:\n         \ntable:\n﻿0\noutfile=outfile_model3 pdf-outfile=outfile_model3.pdf\n4c. Run the program:\n         \ntable:\n﻿0\nmigrate-n parmfile_model3 -nomenu\nThe example parmfiles and a script for Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002] can be found in the basic_protocol2 directory; Executing basic_protocol2.sh will execute all examples in a directory called temp_protocol2.",
    "This protocol will help the user to specify the prior distributions.\nNote that MIGRATE is a Bayesian inference program. In this framework, users will need to decide the probability distribution of the parameters that are used for the population model. This specification is usually done taking the data into account. For example, if we estimate the average height of humans and we know that no adult is smaller than 50 cm or larger than 300 cm, we could then use a prior that has bounds at these numbers and otherwise assume that the distribution is flat (a uniform distribution). The choice of distribution is arbitrary, and the defaults in MIGRATE are uniform distributions. For most parameters, the specification of the boundaries is not as simple as this.\nNecessary Files\nWe need two files: the infile, which was used in Basic Protocols 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001] and 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002], and parmfile_model3; also, for comparison, outfile_model3.pdf; these files were created in Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002] in the directory temp_protocol2.\n1. Make a copy of the Model 3 parmfile:\n         \ntable:\n﻿0\n# we assume to be in the directory currentprotocols cd basic_protocol3 mkdir temp_protocol3 cp ../../basic_protocol1/infile. cp ../../basic_protocol2/temp_protocol2/parmfile_model3 parmfile_prior\n2. We change the prior distribution for the population sizes using the menu in MIGRATE:\n         \ntable:\n﻿0\nmigrate-n parmfile_prior",
    "In the main menu, select (S) Search Strategy. Then, select and follow the 7 Prior distribution submenu. Pick 1 Set Theta prior distribution?, then choose 1 (the N option will be automatically filled from the datafile, but can be set here to 2 if you wish). To change to a different prior distribution, pick a number, e.g., pick 1; this will now set the exponential distribution. The next menu specifies bounds and mean for this distribution; set it to: 0.0, 0.06, and 0.1. Then, use “Y” to go back to the main menu, and press “W” to save the changes.\n3. Changing the prior directly using a text editor. Open parmfile_prior using a text editor. Search for the section where the lines start with bayes-priors; the lines should look like this after step 2:\n         \ntable:\n﻿0\nbayes-priors= THETA * * EXPPRIOR: 0.00 0.06 0.1 bayes-priors= MIG * * UNIFORMPRIOR: 0.00 5000.00 500.00 bayes-priors= SPLIT * * UNIFORMPRIOR: 0.00 0.1 0.01 bayes-priors= SPLITSTD * * UNIFORMPRIOR: 0.00 0.1 0.01\nThe line with THETA shows the changes we did using the menu; for this protocol, we will only change the lines that contain SPLIT and SPLITSTD. These two lines change the prior distribution for the divergence parameters. After the changes the block should read:\n         \ntable:\n﻿0\nbayes-priors= THETA * * EXPPRIOR: 0.00 0.06 0.1 bayes-priors= MIG * * UNIFORMPRIOR: 0.00 5000.00 500.00 bayes-priors= SPLIT * * EXPPRIOR: 0.00 0.08 0.1 bayes-priors= SPLITSTD * * EXPPRIOR: 0.00 0.08 0.1\nThe * * in the option specification stands for any parameter of the specific type. In principle, one can specify a prior for every parameter, but this option is not well tested and should not be used in current MIGRATE version.",
    "4. Change all occurrences of outfile_model3 in the parmfile_prior to outfile_prior (there are two occurrences).\n5. Now, run the program and compare the results with outfile_model3.pdf. The results will be similar but usually are shifted more to the left with exponential priors than with uniform priors.\nFor the tutorial example, the results and the credibility intervals are similar; therefore, the prior influence is negligible. If the prior has a strong influence, then the data are probably not informative.",
    "MIGRATE is capable of helping you select an appropriate population model. Model selection is an important part of a population genetics analysis because using an inappropriate model will lead to inaccurate estimates of parameters. It is important to stress that there is no one right model. Rather, there is a spectrum of varying useful models. A user will be able to compare models to each other and compare the relative merit of each.\nNecessary Files\nFor this protocol, users will need to have completed Basic Protocols 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001] and 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002], and will need outfile_short or outfile_default and outfile_model1, outfile_model2, and outfile_model3.\n1. In our example, we ran a total of four models (Basic Protocols 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002] and 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002]). Our first run consisted of three separate populations with recurrent migration among all three populations. For Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002], we ran three additional models (Fig. 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0005]). Copy the output files into a new directory:\n         \ntable:\n﻿0\n# we assume you are in the directory currentprotocols cd advanced_protocol mkdir temp_advanced cd temp_advanced cp ../../basic_protocol2/temp_protocol2/outfile_*. ls outfile*\nThe command sequence should deliver the following files:\n         \noutfile_model1\noutfile_model1.pdf\noutfile_model2\noutfile_model2.pdf\noutfile_model3\noutfile_model3.pdf\noutfile_short\noutfile_short.pdf",
    "2. After MIGRATE completes a run, the results of the run are printed into an outfile. Inside the outfile, toward the end, locate the Log-marginal-likelihood table as shown in Figure 6[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-fig-0006] (we use ‘log’ as a shortcut for the natural logarithm [ln or loge]). There are three log marginal likelihood scores:. Raw Thermodynamic, Bezier Approximated, and Harmonic Mean. If the run was long enough (see Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001]), then the Raw Thermodynamic score should be close to the Bezier Approximated score. The Harmonic Mean score is retained for historical reasons and should not be used. Use the Bezier Approximated score, because Beerli and Palczewski (2010[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0005]) and Palczewski and Beerli (2014[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0012]) showed that this approach delivers better approximations of the log-marginal likelihood.\nExamine the outfiles: The run with the parmfile_short of the Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001] led to the Bézier log marginal likelihood score in the “All” row of –23751.68. Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0002] generated three more models: in our example run, they produce the marginal log-likelihood scores of –23387.34, –23052.66, and –22170.83, respectively. We are interested in the model with the highest marginal likelihood; therefore, from these four models, we would choose Model 3 (–22170.83), as it produces the highest marginal likelihood of seeing the observed data.\nYour values will be not identical to those reported here; for comparison, we have included the output files used for this text in the directory advanced_protocol/comparison.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/a486e044-c0e6-4307-a2fe-03bf76d852ee/cpbi87-fig-0006-m.jpg</p>\nFigure 6\nCopy of the Log marginal likelihood table as displayed in the outfile_short.pdf of the run that was carried out according to the instructions in Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0001] using parmfile_short. A re-run of the same data will lead to slightly different values.",
    "3. We can quantify this result using a model probability approach (Burnham & Anderson, 2002[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-bib-0006]). In this approach, we calculate the relative weight of a specific model compared to all analyzed models; we sum the marginal likelihoods of all models; and then calculate the model probability for each model scaled with this sum (Equation 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-disp-0001]):\n         \nwhere mL is the marginal likelihood.\nHowever, MIGRATE reports the loge mL! The above calculation is complicated by the fact that the reported log marginal likelihood values are often large negative numbers, and a standard calculator will return zero. For example, exp(ln mL) = exp(–22170.83) will lead to 0.0 on most computer systems, and the sum cannot be calculated accurately. We can use a trick with a scalar a, where a is the same as the largest value among the log marginal likelihoods of all models, then use Equation 2:\n         \nIn our example, we use the highest log marginal likelihood, set , and then calculate  for all models. This model probability makes it possible to discuss superiority of a particular model—here, Model 3 over the others. We can also calculate the log Bayes factor, which is the difference between the log marginal likelihoods of two models, for example, Model 2 compared with Model 1 is ; Bayes factors that are more than 10 units different are considered to be decisive. This suggests that the two models are different and that the model with more support (Model 3) wins over the other model (Model 2).",
    "Models must be run on the same data to be accurately compared. We have supplied a Python script (see the file bf.py in the tutorial package) that can do these calculations automatically. The script uses the line with Bézier log marginal likelihood and then calculates log Bayes factors, which are the differences of the log marginal likelihoods of the two models, and the model probability (Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-tbl-0001]). Looking at the values in Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-tbl-0001], it becomes clear that the Model 3 is orders of magnitude better than the other tested models, and we should discuss this population model and its parameters in the report that discusses the data. The MIGRATE website will have more tutorials on how to handle such comparisons.\nTable 1.\n                Model Comparison of Four Modelsa[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-tbl1-note-0001_90]\ntable:\n﻿Model,Log(mL),LBF,Model probability\nBasic,−23751.68,−1580.85,0.0\nModel 1,−23387.34,−1216.51,0.0\nModel 2,−23052.66,−881.83,0.0\nModel 3,−22170.83,0.00,1.0\na The model with the highest model probability is the best found model. The data were simulated from a model that had a very high immigration rate from A to B and a population split that separated C from A and B. This table was produced with the UNIX command grep “All “ outfile * | sort -n -k 4,4 | python bf.py.\n4. Create the table with your own data (this will need a UNIX-style command line):\n         \ntable:\n﻿0\n\"# we assume that you are in the directory currentprotocols cd advanced_protocols/temp_advanced grep “All “ outfile_* | sort -n -k 4,4 | python ../bf.py\"\nIf this command fails, make sure that you have bf.py in the parental directory and a version of Python available; but steps 1 to 2 should give enough instructions to recreate the table by hand.",
    "This concludes Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0005]. The user may wonder why Model 3 was considered the best model. We simulated the sequence data for the three locations so that the locations Arbon and Berg have a high immigration rate between them (in fact, the gene flow is high enough that we may consider this a single population) and the location Chur was colonized later from Arbon/Berg; therefore, any of the three-population models should explain the data less well than a two-population model. We could test for many other models, but to be statistically consistent, users should define the models before they start testing, for example, by using existing biogeographic hypotheses to formulate models.",
    "Migrate is open-source software and can be accessed at http://popgen.sc.fsu.edu[href=http://popgen.sc.fsu.edu] or at http://peterbeerli.com/migrate[href=http://peterbeerli.com/migrate]. For this tutorial, we will need the MIGRATE-4 series. The download section (https://peterbeerli.com/migrate/download_version4/[href=https://peterbeerli.com/migrate/download_version4/]) gives a list of packages to install. For Windows and MacOS, pick the appropriate binary package; for Linux, pick the src package (the source package can also be installed on MacOS if a compiler is available). For example, the following commands download the source distribution and will generate a directory migrate-4.4.4 (or a newer version number):\n         \ntable:\n﻿0\ncurl -O https://peterbeerli.com/migrate/d4/migrate-newest.src.tar.gz tar zxvf migrate-newest.src.tar.gz\nCheck the version number of the unpacked directory; for the summer of 2019, it is 4.4.4, but this will change on a regular basis. The migrate-4.4.4 directory contains several directories and files. For a basic installation, the user will need to read the README textfile. The HISTORY textfile gives an overview over the software from the start of the distribution to today. The src directory contains all the source code, and the contribution directory contains helper programs that users have contributed (not discussed here). For standard installation, the compilation step for MIGRATE reduces to:\n         \ntable:\n﻿0\n# migrate source install procedure cd migrate-4.4.4/src ./configure make sudo make install\nThe README gives more information. The distribution of Mac and Windows executables is simpler, because the user will only need to copy the files to the appropriate directories. For a Mac, the easiest procedure is to use the following command on the command line:\n         \ntable:\n﻿0\n# migrate binary install procedure cd migrate-4.4.4 sudo mkdir -p/usr/local/bin sudo cp migrate-n/usr/local/bin/",
    "The user will need to be an administrator of the computer to use the sudo command that elevates the permissions from user to administrator, because /usr/local/ is usually protected. For Windows, the easiest way is to keep the migrate-4.4.4 folder in your directory and add the path to the directory that contains the executable migrate-n.exe to the system path file. For a session, you can change the path using:\n         \ntable:\n﻿0\nset path “%path%;C:\\your\\path\\tomigrate”\nFor permanent solutions, you will need to use setx, but that may be tricky if the path is already long, because the path used in Windows has fixed maximal length. A safe solution is setting the path per session (using the command above), or putting the program into the same directory as the data and parmfile.",
    "Installation of the parallel MIGRATE will need the source code and a compiler, and will also require additional software packages that handle the data-parallel distribution, such as OPENMPI (https://www.open-mpi.org[href=https://www.open-mpi.org]) or MPICH (https://www.mpich.org[href=https://www.mpich.org]). This support protocol will not address all installation steps of this additional package, but there are README files in the migrate directory and other help documentation on the internet and through the Google group migrate-support. The following outline works on Macintosh operating systems and also on UNIX-style operating systems, and installs OPENMPI into /usr/local; for a computer cluster, this directory would be best shared among different computers. MIGRATE is not strongly dependent on a fast transport protocol; therefore, fast ethernet connections among nodes in the computer-cluster will work fine. Setting up the computer cluster is beyond the scope of this tutorial, but the README files in the OPENMPI package will help. The following instructions work well on a single computer with a large number of CPU cores.\n1. Download and install OPENMPI:\n         \ntable:\n﻿0\ncurl -O https://download.open-mpi.org/release/open-mpi/v4.0/openmpi-4.0.1.tar.gz tar zxvf openmpi-4.0.1.tar.gz cd openmpi-4.0.1 ./configure make sudo make install\n2. Compile the parallel MIGRATE. It is assumed that the MIGRATE source is already downloaded (see Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.87#cpbi87-prot-0004]) and that the user has run ./configure and compiled the single-CPU version:\n         \ntable:\n﻿0\ncd migrate-4.4.4 ./configure make clean make mpis sudo cp migrate-n-mpi/usr/local/bin/\n3. Verify that the parallel version works:\n         \ntable:\n﻿0\ncd migrate-4.4.4/example mpirun -np 4 migrate-n-mpi parmfile.twoswisstowns\nThe MIGRATE menu must display “Compiled for a PARALLEL COMPUTER ARCHITECTURE.” You can either run the program or quit (Q; or use control-C because on some systems the Q option in the menu fails).",
    "Now, in all places where this tutorial suggests running migrate-n, you can use mpirun -np X migrate-n-mpi. The X is the number of cores on your system. Migrate uses a master-worker architecture that makes it possible to run different loci and replicates in parallel. The program uses its own load-balancing system for the X cores. If you have X cores and the number of loci multiplied by replicates is smaller than X, then some of the worker nodes will remain idle; the best strategy is X = loci × replicates + 1."
  ],
  "subjectAreas": [
    "Bioinformatics"
  ],
  "bigAreas": [
    "Bioinformatics & Computational Biology"
  ]
}