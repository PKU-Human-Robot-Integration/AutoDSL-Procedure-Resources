{
  "id": 3185,
  "origin_website": "Cell",
  "title": "Protocol for quantitative analysis of RNA 3'-end processing induced by disassociated subunits using chromatin-associated RNA-seq data",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\n      Chromatin-associated RNA extraction with spike-in control\n    \nTiming: ∼1–2 days\n    \n      Prepare chromatin-associated RNA according to protocol published\n      previously.13[href=https://www.wicell.org#bib13]\n        Pretreat mES cells with 1 μg/mL doxycycline for 12 h, treat RPB3 or\n        dRPB3 degron mES cells with or without 500 μM indole-3-acetic acid\n        (auxin/IAA).\n      \n        Collect approximately 10ˆ7 cells and mix them with 10% Drosophila S2\n        cells as spike-in control.\n      \n        Lyse the cells in ice-cold NP-40 lysis buffer for 5 min (10 mM Tris-HCl\n        (pH 7.5), 150 mM NaCl, 0.05% NP-40, 1 × proteinase[href=https://www.sciencedirect.com/topics/biochemistry-genetics-and-molecular-biology/proteases]\n        inhibitor cocktail).\n      \n        Cell lysates were gently put on the top of the sucrose cushion (24%\n        sucrose in NP-40 lysis buffer), centrifuged at 12,000 g for\n        10 min. Perform sucrose cushion precipitation to isolate nuclei. Discard\n        the supernatants representing the cytoplasm and resuspend the pellets in\n        0.5 mL glycerol buffer.\n      \n        Add 0.5 mL nuclei lysis buffer to lyse the nuclei and incubate on ice\n        for 2 min.\n      \n        Centrifuge the mixture and discard the supernatant representing the\n        nucleoplasm fraction.\n      \nDiscard the supernatant and washed twice with ice-cold PBS.\n        Extract the RNA from the chromatin pellet using TRIzol reagent according\n        to the manufacturer’s manual. Troubleshooting 1[href=https://www.wicell.org#sec7.1].\n      \n        Send the RNA samples to Novogene for ribosomal RNA depletion,\n        strand-specific library construction, and sequencing.\n      \nAlternatives: Cells from other\n      species can also be used for normalization. We recommend using higher\n      percentage of spike-in controls, such as 10%–20%.\n    \nNote: In 1–9 steps, different samples\n      should be processed at the same time by the same reagents and equipment to\n      reduce batch effects.\n    \nQuality control and sequence alignment\nTiming: ∼10 h\n      The workflow for ChAR-seq data processing is shown in\n      Figure 2[href=https://www.wicell.org#fig2].\n    \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2758-Fig2.jpg\n          Figure 2. Overview of the ChAR-seq data-processing pipeline\n        \n      The minimum computational requirement: this pipeline requires at least 10\n      GB of RAM.",
    "Trim adapter and low-quality bases from the raw sequencing data using\n        the cutadapt tool (v2.10) with customized settings. Low-quality bases\n        with a Phred quality score of <15 will be trimmed and reads with a\n        final length of <25 bp will be discarded.\n      \n#!/bin/bash\n# Step 10: Trim adapters from paired-end FASTQ files.\n# Note: Make sure cutadapt is installed before running this\n          script.\n# Set variables for the example of dRPB3_IAA_0h_rep1\noutputdir=\"/path/to/output_directory\"\nforward_adapt=\"CCCCCCCCCAGATCGGAAGAGCACACGTCTGAACTCCAGTCAC\"\nreverse_adapt=\"AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT\"\nmin_length=25\nprefix=\"dRPB3_IAA_0h_rep1\"\nfastq1=\"dRPB3_IAA_0h_rep1_R1.fq.gz\"\nfastq2=\"dRPB3_IAA_0h_rep1_R2.fq.gz\"\n# Create directory for cutadapt\nmkdir -p \"${outputdir}/cutadapt\"\n# Run cutadapt\ncutadapt -a \"${forward_adapt}\" ∖\n            -A \"${reverse_adapt}\" ∖\n    -q 15,15 ∖\n    --overlap 1 ∖\n    -m \"${min_length}\" ∖\n            -o \"${outputdir}/cutadapt/${prefix}_1.fq\" ∖\n            -p \"${outputdir}/cutadapt/${prefix}_2.fq\" ∖\n            \"${fastq1}\" \"${fastq2}\"\nCheck the quality of the trimmed reads using fastqc (v0.3.0).\n# Step\n11: Run FastQC to check the quality of the trimmed reads\n# Note: Step\n11 is part of a large script with the previous step.\n# Variables are defined earlier in the same script.\n# create directory for cutadapt output and quality control\n          results\nmkdir -p \"${outputdir}/cutadapt/QC\"\n# run FastQC on the cutadapt output files\nfastqc \"${outputdir}/cutadapt/${Prefix}_1.fq\"\n          \"${outputdir}/cutadapt/${Prefix}_2.fq\" ∖\n              -o \"${outputdir}/cutadapt/QC\"\n        Download rRNA sequences for Mus musculus from GenBank with\n        accession number BK000964.3.\n      \n        Build an index and map the trimmed reads to the rRNA sequence using the\n        bowtie2 aligner (v2.3.5.1).\n      \n# Note: Steps 12 and 13 are parts of a large script with the previous\n          step.\n# Variables are defined earlier in the same script.\n# create directory for genome sequence\nmkdir -p \"${outputdir}/genome/ \"\n# Define variables\nbowtie2_index=\"${outputdir}/genome/mm10_rRNA_bowtie2_index\"\nrRNA_accession=\"BK000964.3\"\n# Step 12: Download the rRNA sequence from GenBank\n# Note: The 'efetch' command is used to download sequences\n          from GenBank based on the accession number.\nefetch -db nucleotide -id \"${rRNA_accession}\" -format\n          fasta > \"${outputdir}/genome/mm10_rRNA.fasta\"\n# Step",
    "13: Build the index and map trimmed reads to the rRNA sequence and\n          keep unmapped reads\nbowtie2-build \"${outputdir}/genome/mm10_rRNA.fasta\"\n          \"${bowtie2_index}\"\nbowtie2 -x \"${bowtie2_index}\" -U\n          \"${trimmed_reads}\" ∖\n            --un \"${outputdir}/unmapped_reads.fastq\" ∖\n            -S \"${outputdir}/mapped_reads.sam\"\n        Map the unmapped reads from the output of bowtie2 to the concatenated\n        reference genome comprised of mouse and Drosophila chromosomes (mm10 +\n        dm6) using bowtie2 with options (-very-sensitive-local).\n        \n            Download the mouse (GRCm38/mm10) and Drosophilareference genome\n            sequences (dm6) from the UCSC genome browser and saved as\n            “mm10.fa.gz” and “dm6.fa.gz”, respectively.\n          \nUncompress “mm10.fa.gz” and “dm6.fa.gz”.\n            Because both mouse and Drosophila genomes have chromosome X (named\n            “chrX”) and chromosome Y (named “chrY”), we need to modify the\n            Drosophila chromosome IDs to make them different from that of\n            the mouse. In this case, we add “dm6_” to each chromosome ID of the\n            Drosophila. For example, we change Drosophila’s “chrX”\n            into “dm6_chrX”, “chr2L” into “dm6_chr2L”, and so forth.\n          \n            Concatenate the mouse (mm10) and Drosophilareference genome\n            sequences (mm10) into a single FASTA file – the composite reference\n            genome named “mm10_dm6.fa”.\n          \nIndex the “mm10_dm6.fa” using the “bowtie2-build” command.\n            Map reads to the composite reference genome using Bowtie2. Using\n            Samtools, convert the output alignments into BAM format, sort the\n            BAM files by position, and then index them.\n          \n            Repeat step f for all biological replicates of ChAR-seq data in\n            RPB3- and dRPB3-degron cells before and after IAA treatment.\n          \n# Note: Steps\n14(a)-(e) are parts of a large script with the previous step.\n# Variables are defined earlier in the same script.\n# Define variables\nunmapped_reads=\"${outputdir}/unmapped_reads.fastq\"\nmouse_reference=\"mm10.fa\"\ndrosophila_reference=\"dm6.fa\"\ncomposite_reference=\"mm10_dm6.fa\"\nbowtie2_index=\"${outputdir}/mm10_dm6_bowtie2_index\"\n# Step\n14a: Download the mouse and Drosophila reference genome sequences\n          from the UCSC genome browser\nwget\n          http://hgdownload.soe.ucsc.edu/goldenPath/mm10/bigZips/${mouse_reference}.gz\n          -P \"${outputdir}\"\nwget\n          http://hgdownload.soe.ucsc.edu/goldenPath/dm6/bigZips/${drosophila_reference}.gz\n          -P \"${outputdir}\"\n# Step\n14b: Uncompress the reference genome sequences\ngunzip \"${outputdir}/${mouse_reference}.gz\"\ngunzip \"${outputdir}/${drosophila_reference}.gz\"\n# Step\n14c: Modify the Drosophila chromosome IDs\nsed -i 's/ˆ>chr∖([0-9A-Za-z]∖)/>dm6_chr∖1/'\n          \"${outputdir}/${drosophila_reference}\"\n# Step",
    "14d: Concatenate the mouse and Drosophila reference genome sequences\n          into a single FASTA file\ncat \"${outputdir}/${mouse_reference}\"\n          \"${outputdir}/${drosophila_reference}\" > \"${outputdir}/${composite_reference}\"\n# Step 5e: Index the composite reference genome using the\n          bowtie2-build command\nbowtie2-build \"${outputdir}/${composite_reference}\"\n          \"${outputdir}/${bowtie2_index}\"\n        Remove unmapped or unpaired reads and sort and generate indexes of\n        filtered bam files using sambamba (v0.7.0) and SAMtools (v0.1.19).\n      \n        Classify reads by splitting the \"composite\" BAM files into\n        mouse and Drosophila BAM files.\n      \n# Note: Steps 15 and\n16 are parts of a large script with the previous step.\n# Variables are defined earlier in the same script.\n# create directory for mapping results\nmkdir -p \"${outputdir}/mapping\"\n# map reads to reference and spike-in genome using Bowtie2\nbowtie2 -q -x \"${index}\" --very-sensitive-local --reorder\n          -1 \"${outputdir}/cutadapt/${Prefix}_1.fq\" -2\n          \"${outputdir}/cutadapt/${Prefix}_2.fq\" -p 15 -S\n          \"${outputdir}/mapping/${Prefix}.sam\" 2>\n          \"${outputdir}/mapping/${Prefix}_mapping.stat\"\n# Step 15: mark duplicates using sambamba\n# Note: Sambamba is used to mark duplicates in the mapped\n          reads.\n# The '-r' option removes secondary and supplementary\n          alignments, '-t' specifies the number of threads.\nsambamba markdup -r -t 10\n          \"${outputdir}/mapping/${Prefix}.bam\"\n          \"${outputdir}/mapping/${Prefix}_rmdup.bam\"\n# Step\n15: sort the SAM file and convert it to BAM format\n# Note: The SAM file is sorted and converted to BAM format using\n          samtools mentioned in Step\n15.\n# The '-@' option specifies the number of threads,\n          '-o' specifies the output BAM.\nsamtools sort -@ 10 -o \"${outputdir}/mapping/${Prefix}.bam\"\n          \"${outputdir}/mapping/${Prefix}.sam\"\n# extract unique and concordant pairs from the BAM file\necho \"Extracting unique and concordant pairs...\"\nsamtools view -@ 5 -hF 4\n          \"${outputdir}/mapping/${Prefix}_rmdup.bam\" | grep -v\n          \"XS:\" | samtools view -@ 5 -bS -o\n          \"${outputdir}/mapping/${Prefix}_unique.bam\"\nsamtools view -H\n          \"${outputdir}/mapping/${Prefix}_rmdup.bam\" > \"${outputdir}/mapping/header.txt\"\nsamtools view -@ 5 -hF 4\n          \"${outputdir}/mapping/${Prefix}_unique.bam\" | grep\n          \"YT:Z:CP\" | cat \"${outputdir}/mapping/header.txt\"\n          - | samtools view -@ 5 -bS -o\n          \"${outputdir}/mapping/${Prefix}_unique_concordant.bam\"\nsamtools index\n          \"${outputdir}/mapping/${Prefix}_unique_concordant.bam\"\n# Step\n16: split the \"composite\" BAM files into mouse and",
    "Drosophila BAM files\necho \"Filtering out reads that map to non-target\n          regions...\"\nsamtools view -h\n          \"${outputdir}/mapping/${Prefix}_unique_concordant.bam\"\n          $(echo dm6_chr{2L,2R,3L,3R,4,X,Y,M}) -o\n          \"${outputdir}/mapping/${Prefix}_unique_concordant_dm6.bam\"\nsamtools view -h\n          \"${outputdir}/mapping/${Prefix}_unique_concordant.bam\"\n          $(echo chr{{1..19},X,Y,M}) -o\n          \"${outputdir}/mapping/${Prefix}_unique_concordant_mm10.bam\"\n        Count reads originating from Drosophila S2 spike-in cells and calculate\n        the calibration factors (alpha=1e6/dm6_count) for reads that mapped to\n        the mouse genome.\n      \n>scale_factor=$(echo 1000000/${fly_num} | bc -l)\n        Assign plus and minus strands to uniquely mapped reads using SAMtools.\n      \n# Step\n18: Use SAMtools to assign plus and minus strands for uniquely mapped\n          reads\n# Note: Step\n18 is part of a large script with the previous step.\n# Variables are defined earlier in the same script.\n# Create output directory\nmkdir -p \"$output_dir/mapping/split_strand\"\n# Split bam file by strand\nsamtools view -@ 10 -hf 80 -F 32 \"$input_bam\" -o\n          \"$output_dir/mapping/split_strand/${prefix}_r1_rev.bam\"\nsamtools view -@ 10 -hf 96 -F 16 \"$input_bam\" -o\n          \"$output_dir/mapping/split_strand/${prefix}_r1_forw.bam\"\nsamtools view -@ 10 -hf 144 -F 32 \"$input_bam\" -o\n          \"$output_dir/mapping/split_strand/${prefix}_r2_rev.bam\"\nsamtools view -@ 10 -hf 160 -F 16 \"$input_bam\" -o\n          \"$output_dir/mapping/split_strand/${prefix}_r2_forw.bam\"\n# Merge and sort strand-specific bam files\nsamtools merge -f -@ 5\n          \"$output_dir/mapping/split_strand/${prefix}_plus.bam\"\n          \"$output_dir/mapping/split_strand/${prefix}_r1_rev.bam\"\n          \"$output_dir/mapping/split_strand/${prefix}_r2_forw.bam\"\nsamtools sort -@ 5 -o\n          \"$output_dir/mapping/split_strand/${prefix}_plus_sorted.bam\"\n          \"$output_dir/mapping/split_strand/${prefix}_plus.bam\"\nsamtools index\n          \"$output_dir/mapping/split_strand/${prefix}_plus_sorted.bam\"\nrm\n          \"$output_dir/mapping/split_strand/${prefix}_plus.bam\"\nsamtools merge -f -@ 5\n          \"$output_dir/mapping/split_strand/${prefix}_minus.bam\"\n          \"$output_dir/mapping/split_strand/${prefix}_r1_forw.bam\"\n          \"$output_dir/mapping/split_strand/${prefix}_r2_rev.bam\"\nsamtools sort -@ 5 -o\n          \"$output_dir/mapping/split_strand/${prefix}_minus_sorted.bam\"\n          \"$output_dir/mapping/split_strand/${prefix}_minus.bam\"\nsamtools index\n          \"$output_dir/mapping/split_strand/${prefix}_minus_sorted.bam\"\nrm\n          \"$output_dir/mapping/split_strand/${prefix}_minus.bam\"\n        Convert final BAM files to bigWig tracks in consecutive 10 bp throughout\n        the genome, separated by strand, and normalize to spike-in controls\n        using bamCoverage from deeptools.\n      \n# Step\n19: Generate bigWig files for plus and minus strand reads\n# Note: Step\n19 is part of a large script with the previous step.\n# Variables are defined earlier in the same script.\nbamCoverage --bam\n          ${outputdir}/mapping/split_strand/${Prefix}_plus_sorted.bam ∖\n-o ${outputdir}/bigwig/${Prefix}_plus_spikein.bw ∖\n--binSize 10 ∖\n--normalizeUsing None ∖\n--scaleFactor ${scale_factor} ∖\n--effectiveGenomeSize 2652783500 ∖\n-p 5\nbamCoverage --bam\n          ${outputdir}/mapping/split_strand/${Prefix}_minus_sorted.bam ∖\n-o ${outputdir}/bigwig/${Prefix}_minus_spikein.bw ∖\n--binSize 10 ∖",
    "--normalizeUsing None ∖\n--scaleFactor ${scale_factor} ∖\n--effectiveGenomeSize 2652783500 ∖\n-p 5\n        Merge the bigWig score tracks from two biological replicates to an\n        averaged signal for visualization using the mean operator from the\n        WiggleTools (v1.2) package.\n      \n# Note: Step\n20 is standalone and function independently.\n# Variables are defined within this script.\n#Define the list of samples, stages and strands as arrays\nsamples=(\"RPB3_IAA\" \"dRPB3_IAA\")\nstages=(\"0h\" \"1h\" \"3h\")\nstrands=(\"plus\" \"minus\")\ngenome_file=\"mm10_dm6.genome.txt\"\n# Use arrays to loop through the values\nfor sample in \"${samples[@]}\"\ndo\n  for stage in \"${stages[@]}\"\n  do\n            for strand in \"${strands[@]}\"\n    do\n              # Use variables to make the command more readable\n          input_file_1=\"${output_dir}/bigwig/${sample}_${stage}_1_${strand}_spikein.bw\"\ninput_file_2=\"${output_dir}/bigwig/${sample}_${stage}_2_${strand}_spikein.bw\"\n              output_file=\"${sample}_${stage}_${strand}_spikein.bw\"\n              # Note: The 'wiggletools mean' calculates the mean of the\n          bigWig files, and the output is redirected to 'wigToBigWig'\n          along with the genome file and output file path. wigToBigWig\n          <(wiggletools mean \"$input_file_1\"\n          \"$input_file_2\") \"$genome_file\"\n          \"${output_dir}/bigwig/${output_file}\"\n      done\n    done\ndone\nEvaluate ChAR-seq library with summary statistics\nTiming: ∼4 h\n      Evaluate the ChAR-seq sequencing library with mapped reads distribution,\n      RNA fragment size and metagene profile (Figure 3[href=https://www.wicell.org#fig3]).\n    \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2758-Fig3.jpg\n          Figure 3. Assessment of ChAR-seq library\n        \n          (A) Distribution of uniquely mapped read pairs over gene features\n          (5′UTR, CDS, 3′UTR, exon, and intron) across six merged ChAR-seq\n          samples.\n        \n          (B) Distribution of fragment sizes of different samples, inferred from\n          the separation of read pairs using RSeQC.\n        \n          (C) Metagene profiles of normalized ChAR-seq reads in gene bodies at\n          each time point after IAA treatment. The vertical dashed lines\n          indicate the magnified portions of TSS (transcription start site,\n          left) and TTS (transcription termination site, right) regions.\n          ChAR-seq densities in the sense and antisense directions are indicated\n          by solid and dashed lines, respectively.\n        \nFigure adapted from Li et al.2[href=https://www.wicell.org#bib2]\n        Inspect the distribution of mapped reads and read density over gene\n        features using the read_distribution.py module from RSeQC.\n      \n        Prioritize gene features as follows: CDS exons > UTR",
    "exons > Introns.\n      \n        Calculate the inner distance between read pairs to estimate the RNA\n        fragment size using the inner_distance.py module.\n      \n        Record the calculated mean, median, and standard deviation values for QC\n        plots.\n      \n# Note: Steps 21 and\n23 are standalone and function independently.\n# Variables are defined within this script.\n# Define the list of samples and stages as arrays\nsamples=(\"RPB3_IAA\" \"dRPB3_IAA\")\nstages=(\"0h\" \"1h\" \"3h\")\n# Loop through each sample and stage\nfor sample in \"${samples[@]}\"\ndo\n  for stage in \"${stages[@]}\"\n  do\n            # Define the input and output filenames\n            input_bam=\"${sample}_${stage}.bam\"\n            output_inner=\"${sample}_${stage}.inner_distance\"\n# Step\n21: Inspect the distribution of mapped reads and read density over\n          gene features\n# Note: The 'read_distribution.py' module from RSeQC is used\n          to analyze the distribution of mapped reads over gene features.\n            read_distribution.py -i \"$input_bam\" -r mm10_RefSeq.bed\n          >> read_distribution.txt\n# Step\n23: Calculate inner distance between read pairs to estimate RNA\n          fragment size\n# Note: The 'inner_distance.py' module from RSeQC is used to\n          calculate the inner distance between read pairs.\n            inner_distance.py -i \"$input_bam\" -o\n          \"$output_inner\" -q 0 -r mm10_RefSeq.bed\n  done\ndone\n        Report the number of aligned reads and the alignment percentage as the\n        alignment statistics (Table 1[href=https://www.wicell.org#tbl1])\n        table:files/protocols_protocol_2758_5.csv\n# Step 25: Record alignment statistics\n# Note: Step\n25 is part of a large script along with the step\n19.\n# Variables are defined earlier in the same script.\n# Count the number of reads using the appropriate commands\ncutadapt=$(grep \"ˆ@\" ${outputdir}/cutadapt/${Prefix}_1.fq |\n          wc -l)\nmapping=$(samtools view -F 4 ${outputdir}/mapping/${Prefix}.bam | wc\n          -l)\nrmdup=$(samtools view -F 4 ${outputdir}/mapping/${Prefix}_rmdup.bam |\n          wc -l)\nunique=$(samtools view -c\n          ${outputdir}/mapping/${Prefix}_unique.bam)\nconcordant=$(samtools view -c\n          ${outputdir}/mapping/${Prefix}_unique_concordant.bam)\nmm10_concord=$(samtools view -c\n          ${outputdir}/mapping/${Prefix}_unique_concordant_mm10.bam)\ndm6_concord=$(samtools view -c\n          ${outputdir}/mapping/${Prefix}_unique_concordant_dm6.bam)\n# Write the statistics to the stastic file\necho -e \"sample_name,total_reads,cutadapt,mapping reads,rm\n          duplicate,unique mapping,concordant pairs,mm10 concordant pairs,dm6\n          concordant pairs\" >>\n          ${outputdir}/${Prefix}_stastic.csv\necho -e\n          \"${Prefix},${total_reads},${cutadapt},${mapping},${rmdup},${unique},${concordant},${mm10_concord},${dm6_concord}\"\n          >> ${outputdir}/${Prefix}_stastic.csv",
    "Generate strand-specific metagene, TSS and TTS profiles from a BAM file\n        using \"ngs.plot\".\n        \n            Set working directories, sample information and their corresponding\n            BAM file location.\n            \n#!/bin/bash\n# Note: Step 26a are standalone and function independently.\n# Variables are defined within this script.\n# Set working directory, temporary directory, and\n                  metaprofiles directory\nWORKDIR=\"/path/to/my/working_directory/\"\n# Note: $WORKDIR is where the BAM files to be plotted are\n                  stored.\nTMPDIR=\"${WORKDIR}tmp/\"\nPROFDIR=\"${WORKDIR}metaprofiles/\"\n# Create temporary and metaprofiles directories\nmkdir -p \"$TMPDIR\"\nmkdir -p \"$PROFDIR\"\n# Define the sample name and input BAM file\nSAMPLE=\"dRPB3_0h\"\nBAM=\"${WORKDIR}dRPB3_0h.bam\"\n# Define the output BAM file with mate pairs\nMATE1=\"${WORKDIR}dRPB3_0h.mate1.bam\"\n            Restrict to the first mate reads. If the BAM file contains paired\n            reads, create a new file containing only the first mate reads.\n          \n            Reformat the chromosome names in the BAM file to match those in the\n            ngs.plot database.\n            \n# Step\n26c: Reformat the chromosome names\n# Note: Step\n26c is part of a large script along with the step\n26a.\n# Variables are defined earlier in the same script.\n# Define output file names and the number of threads\nMATE1REHEADER=\"${WORKDIR}/dRPB3_0h.mate1.reheader.bam\"\nTHREADS=10\n# Convert BAM to SAM, filter by flag 64, and convert\n                  back\nsamtools view --threads $THREADS -h -b -f 64 $BAM -o\n                  $MATE1\n# Index the BAM file\nsamtools index $MATE1\n# Modify the header of the BAM file to replace chromosome\n                  numbers with \"chr\" prefix\nsamtools view --threads $THREADS -H ${MATE1} | sed -e\n                  's/SN:∖([0-9XY]∗∖)/SN:chr∖1/' -e\n                  's/SN:MT/SN:chrM/' | samtools reheader -\n                  ${MATE1} > ${MATE1REHEADER}\n# Index the reheadered BAM file\nsamtools index ${MATE1REHEADER}\n            Run ngs.plot to generate sense and anti-sense profiles for specific\n            regions of interest using the correct BAM file. Note that if the\n            libraries were produced such that mate2 represents the forward\n            strand, the sense and anti-sense profiles would be reversed.\n            \n# Note: Step",
    "26d is part of a large script along with the step\n26a and 26c.\n# Variables are defined earlier in the same script.\n## Genebody\nREGION=\"genebody\"\nfor STRAND in both same opposite\ndo\n                  OUTPUT=\"${PROFDIR}${SAMPLE}.${REGION}.${STRAND}\"\nngs.plot.r -G mm10 -R $REGION -C ${MATE1REHEADER} -O $OUTPUT\n                  -P 10 -SS $STRAND -SE 1 -L 5000 -F charseq -GO total -RB 0.05\n                  -AL bin -CS 500 -FL 150 -D ensembl\ndone\n## TSS\nREGION=\"tss\"\nfor STRAND in both same opposite\ndo\n                  OUTPUT=\"${PROFDIR}${SAMPLE}.${REGION}.${STRAND}\"\nngs.plot.r -G mm10 -R $REGION -C ${MATE1REHEADER} -O $OUTPUT\n                  -P 10 -SS $STRAND -SE 1 -L 5000 -F charseq -GO total -RB 0.05\n                  -AL bin -CS 500 -FL 150 -D ensembl\ndone\n## TTS\nREGION=\"tts\"\nfor STRAND in both same opposite\ndo\n                  OUTPUT=\"${PROFDIR}${SAMPLE}.${REGION}.${STRAND}\"\nngs.plot.r -G mm10 -R $REGION -C ${MATE1REHEADER} -O $OUTPUT\n                  -P 10 -SS $STRAND -SE 1 -L 5000 -F charseq -GO total -RB 0.05\n                  -AL bin -CS 500 -FL 150 -D ensembl\ndone\n            Use R to combine the sense and anti-sense profiles on a single set\n            of axes by utilizing the ngs.plot output.\n          \n            Scale the profile by employing the calculated calibration factors in\n            step 17.\n            Edit the resulting \".cnt\" file to multiply the read count\n            by the calibration factor, and re-run ngs.plot using the same\n            parameters as before with the modified one.\n            \n# This R code refers to plots in\nFigure 3[href=https://www.wicell.org#fig3]\n# Load required packages\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(ggpubr)\nlibrary(readxl)\n# Read the Excel file and remove missing values for\nFigure 3[href=https://www.wicell.org#fig3]A\n              \ndf <- na.omit(read_excel(\"protocol_stats.xlsx\",\n                  sheet = 1, trim_ws = FALSE, range = cell_cols(c(\"A\",\n                  \"E\"))))\n# Reshape the data using the melt function from the reshape2\n                  package\ndf_long <- reshape2::melt(df, id = \"Samples\",\n                  value.name = \"count\")\n# Round the count values to the nearest integer\ndf_long$count <- round(df_long$count, 0)\n# Create a grouped bar plot using ggbarplot from ggpubr",
    "p1 <- ggbarplot(data = df_long, x = \"Samples\",\n                  y = \"count\",\n                        fill = \"variable\", palette = c('#3494BAFF',\n                  '#58B6C0FF', '#75BDA7FF',\n                  '#666666FF'),\n                        position = position_dodge(0.7),\n                        # Set background and line colors\n                        background.color = \"white\", color = NA,\n                        xlab = \"\", ylab = \"FPKM\",\n                        remove = \"all\",\n                        axis.line = element_line(color = \"black\")\n) + ggpubr::theme_pubr()\n# Save the plot as a PDF file\nggsave(p1, filename =\n                  \"Figure 3A_gene_features.pdf\", width = 6, height =\n                  4)\n# Read the Excel file and remove missing values for\nFigure 3[href=https://www.wicell.org#fig3]B\n              \ndf <- na.omit(read_excel(\"protocol_stats.xlsx\",\n                  sheet = 2, trim_ws = FALSE, range = cell_cols(c(\"F\",\n                  \"J\"))))\n# Create the second plot\np2 <- ggplot(df, aes(x = Samples, y = Mean, fill =\n                  Group)) +\n                  geom_boxplot(aes(lower = Mean - SD, upper = Mean + SD,\n                  middle = Median, ymin = Mean - 3 ∗ SD, ymax = Mean + 3 ∗\n                  SD),\n                          stat = \"identity\", width = 0.8) +\n                  stat_summary(fun.y = mean, geom = \"point\", shape =\n                  20, size = 3, color = \"pink\", fill =\n                  \"pink\") +\n                  scale_fill_manual(values =\n                  c(\"#E64B35FF\",\"#4DBBD5FF\",\"#00A087FF\"))+\n  ggpubr::theme_pubr()\n# Save the box plot as a PDF file\nggsave(p2, filename = \"Figure 3B_insert size.pdf\",\n                  width = 5, height = 4)\n# The following R code refers to metagene plot for dRPB3\n                  in\nFigure 3[href=https://www.wicell.org#fig3]C\n              \n# Note: similar code can be employed for RPB3.\n# Define input files for\nFigure 3[href=https://www.wicell.org#fig3]C\n              \nsense_profile <- \"dRPB3_sense_avgprof.txt\"\nantisense_profile <-\n                  \"dRPB3_antisense_avgprof.txt\"\n# Read sense and anti-sense profiles from ngs.plot\n                  output\nsense <- read.table(sense_profile, header = TRUE)\nantisense <- read.table(antisense_profile, header =\n                  TRUE)\n# Plot the combined profiles\npdf(\"Figure 3C_metagene_dRPB3.pdf\", 8,8)\nplot(sense$position, sense$IAA_0h, type = \"l\",\n                  col = \"#1B9E77\", lwd = 2,\n                  xlab = \"Position\", ylab = \"Value\", main =\n                  \"Combined Profiles\")\nlines(sense$position, sense$IAA_1h, type = \"l\",\n                  col = \"#D95F02\", lwd = 2)\nlines(sense$position, sense$IAA_3h, type = \"l\",\n                  col = \"#7570B3\", lwd = 2)",
    "lines(antisense$position, antisense$IAA_0h, type =\n                  \"l\", col = \"#1B9E77\", lwd = 2)\nlines(antisense$position, antisense$IAA_1h, type =\n                  \"l\", col = \"#D95F02\", lwd = 2)\nlines(antisense$position, antisense$IAA_3h, type =\n                  \"l\", col = \"#7570B3\", lwd = 2)\nlegend(\"topright\", legend = c(\"Sense\n                  IAA_0h\", \"Sense IAA_1h\", \"Sense\n                  IAA_3h\",\n                                \"Anti-sense IAA_0h\", \"Anti-sense IAA_1h\",\n                  \"Anti-sense IAA_3h\"),\n                      col = c(\"#1B9E77\", \"#D95F02\",\n                  \"#7570B3\", \"#1B9E77\", \"#D95F02\",\n                  \"#7570B3\"), lty = 1, lwd = 2)\ndev.off()\n      Construct gene loci annotation and down-sample the resulting bam files\n    \nTiming: ∼6 h\n        Download the mouse gene annotation GTF file from “Comprehensive gene\n        annotation” in the “GTF/GFF3 files” table named\n        “gencode.vM23.annotation.gtf.gz”, which is the main annotation file for\n        most users.\n      \n> wget -c\nhttps://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M23/gencode.vM23.annotation.gtf.gz[href=https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_mouse/release_M23/gencode.vM23.annotation.gtf.gz]\nUnzip gene annotation files.\n> gunzip gencode.vM23.annotation.gtf.gz\n        Check the strandedness of comma-separated GTF files, and use it as input\n        to generate a gene loci annotation file.\n      \n> Get_loci_annotation -out ./gencode_mm10_vM23 -gtf\n          gencode.vM23.annotation.gtf\nNote: The output file is named\n      loci_annotation.bed, to be used as input for Get_DoGs\n    \n        Preprocess, sort and index the input bam files to keep their order\n        constant.\n      \n#!/bin/bash\n# Note: Step\n30 are standalone and function independently.\n# Variables are defined within this script.\n# Define the list of samples, stages, and repeats as arrays\nsamples=(\"RPB3_IAA\" \"dRPB3_IAA\")\nstages=(\"0h\" \"1h\" \"3h\")\nreps=(\"rep1\" \"rep2\")\n# Loop over samples, stages, and replicates to perform samtools\n          operations\nfor sample in \"${samples[@]}\"; do\n  for stage in \"${stages[@]}\"; do\n            for rep in \"${reps[@]}\"; do\n              # Perform samtools operations on the current sample, stage, and\n          repeat\n              samtools view -@ 10 -hF 4 ${sample}_${stage}_${rep}.bam | grep\n          \"YT:Z:CP\" | cat common_header.txt - | samtools view -@ 10\n          -bS -o ${sample}_${stage}_${rep}_reheader.bam\n              samtools sort ${sample}_${stage}_${rep}_reheader.bam -o\n          ${sample}_${stage}_${rep}.bam\n              samtools index ${sample}_${stage}_${rep}.bam\n      done\n  done\ndone\n        Downsample the ChAR-seq bam files to match the read depth of the\n        identified bam file with the lowest read depth.\n      \n> Pre_Process -Q 10 -bam dRPB3_IAA_0h_rep1.bam,\n          dRPB3_IAA_0h_rep2.bam, dRPB3_IAA_1h_rep1.bam, dRPB3_IAA_1h_rep2.bam,",
    "dRPB3_IAA_3h_rep1.bam, dRPB3_IAA_3h_rep3.bam, RPB3_IAA_0h_rep1.bam,\n          RPB3_IAA_0h_rep2.bam, RPB3_IAA_1h_rep1.bam, RPB3_IAA_1h_rep2.bam,\n          RPB3_IAA_3h_rep1.bam, RPB3_IAA_3h_rep3.bam -ref\n          ./gencode_mm10_vM23/loci_annotation.bed\nNote: Input sorted bam file of each sample\n      should be separated by comma, troubleshooting 3[href=https://www.wicell.org#sec7.5].\n    \nNote: This step may take a long time. Once\n      finished, the output raw and downsampled files will be located in the same\n      folder as the original bam files.\n    \nDetect readthrough gene candidates\nTiming: ∼2 h\n        Use the downsampled bam files and a loci annotation bed file as input\n        for the DoGFinder tool to identify readthrough gene candidates.\n        \nRemove all genic reads from the bam file.\n            Limit gene boundaries by the location of the nearest 3‘ neighboring\n            gene in the genome, and discard genes with 3’ nearest neighbor\n            closer than 4 kb.\n          \n            Run the Get_DoGs function with the following parameters to identify\n            readthrough gene candidates based on a minimum length of 4 kb and a\n            minimum coverage of 60% over the entire downstream length: -S\n            -minDoGLen 4000 -mode F -minDoGCov 0.6.\n          \n            Elongate the identified readthrough gene candidates to find their\n            putative endpoint.\n          \n#!/bin/bash\n# Note: Step\n32 are standalone and function independently.\n# Variables are defined within this script.\n# Usage: Get_DoGs -out /outdir -bam my_sorted_bam.sorted_DS.bam -a\n          loci_annotation.bed\n# This script executes the Get_DoGs command for multiple samples,\n          stages, and replicates.\n# Define variables\nsamples=(\"dRPB3_IAA\" \"RPB3_IAA\")\nstages=(\"0h\" \"1h\" \"3h\")\nreps=(\"rep1\" \"rep2\")\n# Loop over samples, stages, and replicates to call the Get_DoGs\n          command\nfor sample in \"${samples[@]}\"; do\n  for stage in \"${stages[@]}\"; do\n            for rep in \"${reps[@]}\"; do\n              Get_DoGs -out ./Get_DoGs ∖\n                    -bam\n\"${sample}_${stage}_${rep}.sorted_PE.sorted_DS.bam\" ∖\n                    -suff \"${sample}_${stage}_${rep}\" ∖\n                    -s -minDoGLen 4000 -minDoGCov 0.6 -w 200 -mode F ∖\n                    -a ./gencode_mm10_vM23/loci_annotation.bed ∖\n                    -max 100000 done\n    done\ndone\n        Intersect readthrough gene candidates from different replicates.\n        \n            Gather all the annotation bed files of readthrough gene candidates\n            from different replicates that need to be intersected.",
    "Use the \" Common_DoGs_annotation\" function from DoGFinder\n            to get the list of readthrough candidate gene sets common to all\n            biological replicates.\n          \n            Execute the \"sortBed\" function from bedtools to sort the\n            intersected bed file by chromosome and coordinate.\n          \n            Choose the most downstream coordinate as the end coordinate for all\n            intersected readthrough gene candidates. Use the \"awk\"\n            command to extract the most downstream coordinate for each gene name\n            and save it in a new bed file.\n          \n#!/bin/bash\n# Note: Step\n33 are standalone and function independently.\n# Variables are defined within this script.\n# Usage: Common_DoGs_annotation -comm\n          Dog_annotation_replicate1.bed,Dog_annotation_replicate2.bed -out\n          /outdir\n# This script executes the Common_DoGs_annotation command for\n          multiple samples and stages.\n# Define variables\nsamples=(\"dRPB3_IAA\" \"RPB3_IAA\")\nstages=(\"0h\" \"1h\" \"3h\")\n# Loop over samples and stages to run the Common_DoGs_annotation\n          command\nfor sample in \"${samples[@]}\"; do\n  for stage in \"${stages[@]}\"; do\n            Common_DoGs_annotation -comm\n          \"Dog_annotation_${sample}_${stage}_rep1.bed,\n          Dog_annotation_${sample}_${stage}_rep2.bed\" ∖\n                        ./Final_Common_Dog_annotation/\n    sortBed -\ni ./Final_Common_Dog_annotation/union_dog_annotation.bed ∖\n>\n          ./Final_Common_Dog_annotation/sorted_union_dog_annotation.bed\ncat ./Final_Common_Dog_annotation/sorted_union_dog_annotation.bed\n          ∖\n            | awk -F '∖t' -v OFS='∖t' '{if($4!=id) {print\n          chr, start, end, id, score, strand; id=$4; chr=$1; start=$2; end=$3;\n          score=$5; strand=$6;} else {if($3>end) end=$3;}} END {print chr,\n          start, end, id, score, strand;}' ∖\n            >\n          ./Final_Common_Dog_annotation/Final_CommonDog_annotation_${sample}_${stage}_rep1.bed\n  done\ndone\nNote: Assuming that the filenames for the\n      replicate 1 and replicate 2 outputs follow the same pattern as the inputs,\n    \n        Merge DoG annotations from different treatments or experiments.\n        \n            Collect all DoG annotation bed files to be merged for different\n            treatments.\n          \n            Use the \" Union_DoGs_annotation\" function from DoGFinder\n            to create a single DoG annotation bed file.\n          \n            For any DoG that appears in more than one input file, unify them\n            according to their maximal length.\n          \n            Execute the \"sortBed\" function from bedtools to sort the\n            merged bed file by chromosome and coordinate.\n          \n            Format the output bed file as a tab-separated gene annotation bed\n            file to be used as input for Get_DoGs\n          \n#!/bin/bash",
    "# Note: Step\n34 is standalone and function independently.\n# Variables are defined within this script.\n# Usage: Union_DoGs_annotation -dog\n          Final_Dog_annotation1.bed,Final_Dog_annotation2.bed -out /outdir\n# This script executes the Union_DoGs_annotation command for multiple\n          samples.\n# Define variables\nsamples=(\"dRPB3_IAA\" \"RPB3_IAA\")\n# Create directories and run the Union_DoGs_annotation command\nfor sample in \"${samples[@]}\"; do\n          mkdir -p \"./Final_UnionDog_annotation_${sample}\"\n          Union_DoGs_annotation -dog\n          \"./Final_Common_Dog_annotation/Final_CommonDog_annotation_${sample}_0h.bed,./Final_Common_Dog_annotation/Final_CommonDog_annotation_${sample}_1h.bed,./Final_Common_Dog_annotation/Final_CommonDog_annotation_${sample}_3h.bed\"\n          ∖\n-out \"./Final_UnionDog_annotation_${sample}/\"\ncat\n          \"./Final_UnionDog_annotation_${sample}/union_dog_annotation.bed\"\n          | awk -F '∖t' -v OFS='∖t' '{print\n          $1,$2,$3,$6,$5,$4\n          }' > \"./Final_UnionDog_annotation/Final_UnionDog_annotation_${sample}.bed\"\ndone\n        Calculate the expression levels of readthrough gene candidates across\n        experiments.\n        \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2758-Fig4.jpg\n              Figure 4. Comparison of readthrough gene candidates in dRPB3 and\n              RPB3 degron cells treated with IAA\n            \n              Top: Venn diagram illustrating the union overlap between genes\n              that produce readthrough genes at different time points (0 h, 1 h,\n              and 3 h) after IAA treatment in dRPB3 (left) or RPB3 (right)\n              degron cells. Bottom: Bar plot showing the number of readthrough\n              gene candidates discovered by DoGFinder in each sample. The number\n              in parentheses represents the common genes found in two replicates\n              across six conditions.\n            \n#!/bin/bash\n# Note: Step\n35 is standalone and function independently.\n# Variables are defined within this script.\n# Usage: Get_DoGs_rpkm -out /outdir -bam my_sorted_bam_DS.bam -s -dog\n          Final_Dog_annotation.bed\n# This script calculates RPKM values for DoGs using the Get_DoGs_rpkm\n          command.\n# Define variables\nsamples=(\"dRPB3_IAA\" \"RPB3_IAA\")\nstages=(\"0h\" \"1h\" \"3h\")\nreps=(\"rep1\" \"rep2\")\noutput_dir=\"./Get_DoGs_rpkm\"\nunion_dog_file=\"./Final_UnionDog_annotation/Final_UnionDog_annotation_\"\n# Loop over samples, stages, and replicates to run the command\nfor sample in \"${samples[@]}\"; do\n  for stage in \"${stages[@]}\"; do\n            for rep in \"${reps[@]}\"; do\ninput_bam=\"${sample}_${stage}_${rep}.sorted_PE.sorted_DS.bam\"\n            suffix=\"${sample}_${stage}_${rep}\"\n            output_file=\"${output_dir}/${suffix}_DoGs_rpkm.txt\"\n            dog_file=\"${union_dog_file}${sample}.bed\"\n            Get_DoGs_rpkm -out \"$output_dir\" ∖\n                -bam \"$input_bam\" ∖\n                -suff \"$suffix\" ∖\n        -s ∖\n                -dog \"$dog_file\" ∖\n                -g ./Get_DoGs/genome_file.txt\n              # Move output file to correct location and rename it\n              mv \"${output_dir}/${suffix}_DoGs_rpkm.txt\"\n          \"$output_file\"\n      done\n  done\ndone\n# This R code refers to metagene plot for dRPB3 in\nFigure 4[href=https://www.wicell.org#fig4]",
    "# Note: similar code can be employed for RPB3.\n# Load required packages\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(ggpubr)\nlibrary(readxl)\n# Read the Excel data into a dataframe, removing rows with missing\n          values\ndf <- na.omit(read_excel(\"protocol_stats.xlsx\", sheet =\n          3, trim_ws = TRUE, range =\n          cell_cols(c(\"A\",\"D\"))))\n# Display the first few rows of the dataframe\nhead(df)\n# Convert the \"sample\" column to a factor with specified\n          levels\ndf$sample <- factor(df$sample, levels = df$sample)\n# Create a bar plot using ggbarplot from ggpubr\np3 <- ggbarplot(df, x = \"sample\", y =\n          \"count\",\n                fill = \"cond\", color = \"cond\", palette =\n          \"npg\",\n                label = TRUE,\n                position = position_dodge(0.8)) +\n    ggprism::theme_prism() +\n            theme(axis.text.x = element_text(angle = 40, hjust = 1))\n# Save the plot as a PDF file\nggsave(p3, filename = \"Figure 4_\n          Readthrough_gene_number.pdf\", width = 10, height = 6)\n# Create a PDF device for the Venn diagram\npdf(\"Figure 4_Venn_Diagram.pdf\", 8, 8)\n# Set up the plotting layout\npar(mfrow = c(1, 2), bty = 'n')\n# Draw the Venn diagram for dRPB3 using the total number of\n          readthrough gene candidates from the bar plot, as well as determine\n          their overlaps\nvenn.dRPB3 <- draw.triple.venn(area1 = 10065,\n                        area2 = 10698,\n                        area3 = 10703,\n                        euler.d = TRUE, scaled = TRUE,\n                        n12 = 9552 + 215, n23 = 9552 + 598, n13 = 9552 + 155, n123 =\n          9552,\n                        category = c(\"IAA_0h\", \"IAA_1h\",\n          \"IAA_3h\"),\n                        lty = \"blank\",\n                        fill = c(\"#CF4C35\", \"#4DA8BE\",\n          \"#1A937D\"),\n                        alpha = 0.5,\n                        cex = 2, cat.cex = 2, cat.pos = c(-1, -1, 180))\n# Draw the Venn diagram for RPB3\nvenn.RPB3 <- draw.triple.venn(area1 = 7195,\n                        area2 = 7733,\n                        area3 = 8024,\n                        euler.d = TRUE, scaled = TRUE,\n                        n12 = 6651 + 258, n23 = 6651 + 592, n13 = 6651 + 136, n123 =\n          6651,\n                        category = c(\"IAA_0h\", \"IAA_1h\",\n          \"IAA_3h\"),\n                        lty = \"blank\",\n                        fill = c(\"#CF4C35\", \"#4DA8BE\",",
    "\"#1A937D\"),\n                        alpha = 0.5,\n                        cex = 2, cat.cex = 2, cat.pos = c(-1, -1, 180))\n# Close the PDF device\ndev.off()\nDetermine readthrough and non-readthrough genes\nTiming: ∼1 h\nDefine readthrough genes.\n        Exclude very short genes with a length of less than 2 kb from the\n        analysis.\n      \n        Generate a sub-list of active genes from our untreated PRO-seq data.\n      \nNote: Gene activity was determined based\n      on the ratio of N/L, where N corresponds to the count of coding-strand\n      Pro-seq reads from +1kb (relative to the TSS) to the end of each gene, and\n      L denotes the number of mappable bases in this region. The statistical\n      significance of a given gene's activity level was estimated by\n      calculating the probability of observing a minimum of N reads within an\n      interval of length L, derived from a Poisson distribution of mean λ = 0.04\n      reads/kb. Genes with a probability of less than 0.01 were defined as\n      active, as described in our publication.2[href=https://www.wicell.org#bib2]\n        Refine readthrough gene candidates identified in step 34 that\n        overlap with active genes but do not overlap with readthrough regions\n        that correspond to neighboring genes on either strand using Bedtools\n        intersect analysis.\n        \n            Identify readthrough gene candidates that overlap with active genes.\n          \n            Find transcripts whose TSS or TTS region extended in 5′ and 3′\n            overlaps with any transcript from another gene.\n          \n            Remove readthrough gene candidates that overlap with neighboring\n            genes on either strand.\n          \nKeep each readthrough gene a unique name.\n#!/bin/bash\n# Note: Step 38\nis standalone and function independently.\n# Variables are defined within this script.\n# Define input files and directories\npromoter_size=1000\n# Find genes that overlap promoters\ngtftk overlapping -i ./gencode_mm10_vM23/loci_annotation.bed -c\n          mm10.chromInfo -t promoter -u $promoter_size -d $promoter_size | gtftk\n          select_by_key -k feature -v transcript | gtftk tabulate -k\n          gene_id,overlap_promoter_u${promoter_size}_d${promoter_size} > dist_to_overlapping_mm10.txt",
    "# Use the paste command to join the files by columns\npaste gencode.vM23.gene.bed dist_to_overlapping_mm10.txt ∖\n            | awk -v FS='∖t' -v OFS='∖t' '{print\n          $5,$1,$2,$3,$4,$6}' ∖\n    | sort -k1,1 ∖\n    > overlapping_gene.bed\n# Use an array to store sample names\nsamples=(dRPB3_IAA RPB3_IAA)\n# Use a for loop to iterate over the sample names\nfor sample in \"${samples[@]}\"; do\n          bedtools intersect -s -a\n          ./Final_UnionDog_annotation/Final_UnionDog_annotation_${sample}.bed -b\n          gencode.vM23_active.bed ∖\n            | sort -u > Final_UnionDog_annotation_active_${sample}.bed\n          bedtools intersect -s same -v -a\n          Final_UnionDog_annotation_active_${sample}.bed -b overlapping_gene.bed\n          ∖\n            | sort -u > ${sample}_readthrough.bed\n# Use a single awk command to filter for the longest transcript per\n          gene with unique name\n          awk '{key=$4; if ($3-$2 > max[key]) {max[key]=$3-$2;\n          row[key]=$0}} END{for (k in row) print row[k]}'\n          ${sample}_readthrough.bed ∖\n    | sort -k4,4 -u ∖\n            > Final_${sample}_readthrough.bed\nDone\nNote: The bedtools and gtftk tools have\n      already been installed in the system's PATH.\n    \nDefine non-readthrough genes.\n        Obtain the genomic coordinates for the active genes and readthrough\n        regions of neighboring genes.\n      \n        Identify overlap between the active genes and the readthrough regions\n        according to bedtools intersect analysis.\n        \n            Create a list of active genes that do not overlap with readthrough\n            regions of neighboring genes on either strand.\n          \n            Subtract the readthrough genes from this list of active genes to\n            create a new list of non-readthrough genes that fail to generate\n            readthrough transcripts.\n          \nEnsure that each non-readthrough is given a unique name.\nNote: The script in this part is similar\n      to that of defining readthrough genes.\n    \nQuantify the readthrough indices\nTiming: ∼1–2 h\n        Consider genes with a minimum length of 2 kb to exclude very short genes\n        from the analysis. Troubleshooting 4[href=https://www.wicell.org#sec7.7].\n      \n        Define two sub-genic windows as the following: termination windows are\n        from 3 to 6 kb downstream of polyA sites; pre-polyA windows are 1 kb\n        upstream of respective polyA sites.",
    "Calculate the ChAR-seq read counts in two sub-genic windows.\n        Filter out genes with fewer than five reads in either termination or\n        pre-polyA windows from the analysis.\n      \n        Determine the readthrough index as the ratio of the ChAR-seq read\n        coverage in the termination window to that in the pre-polyA window.\n      \nOptional: Build high-quality 3′UTR\n      polyadenylation sites (PASs) for mouse genome directly from GENCODE\n      annotation GTF files (M23). It may be helpful to refine genes that contain\n      polyadenylation sites.\n    \n# This R code refers to an option of step 45\n% if (!\"BiocManager\" %in%\n          rownames(installed.packages()))\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"APAlyzer\")\n# Load required packages\nlibrary(APAlyzer)\nGTFfile=\"gencode.vM23.annotation.gtf.gz\"\nPASREFraw=PAS2GEF(GTFfile)\nrefUTRraw=PASREFraw$refUTRraw\nUTRdbraw=REF3UTR(refUTRraw)\nwrite.table(UTRdbraw, \"UTRdbraw.tsv\", append = TRUE, sep =\n          \"∖t\")\nNote: our quantification pipeline includes\n      a custom Perl (Calculate_readthrough_indices.pl) that (i) use downsampled\n      reads from step 32 and the bed file from step 45 to divide\n      read coverages in pre-polyA window by termination window to generate\n      readthrough indices and (ii) make sure genes are at least 2 kb long.\n    \n#!/usr/bin/perl\nuse strict;\nuse warnings;\nuse File::Basename;\nuse File::Spec::Functions qw(catfile);\n# Get command line arguments\nmy $genes_file = $ARGV[0];\nmy $frags_file = $ARGV[1];\n# Check if files exist\ndie \"Error: Genes file $genes_file not found∖n\" unless -e\n          $genes_file;\ndie \"Error: Fragments file $frags_file not found∖n\" unless\n          -e $frags_file;\n# Define output file names\nmy $genes_over_2kb_file = 'genes.over2kb.bed';\nmy $term_window_file = 'term.bed';\nmy $poly_window_file = 'poly.bed';\nmy $term_sorted_file = 'term.srt.bed';\nmy $poly_sorted_file = 'poly.srt.bed';\nmy $term_count_file = 'term.count';\nmy $poly_count_file = 'poly.count';\n# Make sure genes are at least 2 kb long\nsystem(\"awk '{if (∖$10-∖$9>2000) print ∖$0}'\n          $genes_file > $genes_over_2kb_file\");\nprint \"Genes < 2000bp parsed out∖n∖n\";\n# Define new termination window from TTS+3000 to TTS+6000 (only genes\n          >= 2000 bp and not overlapping any other gene)\nopen $over2kb_fh, '<', $genes_over_2kb_file or die\n          \"Cannot open $genes_over_2kb_file: $!\";",
    "open my $term_fh, '>', $term_window_file or die\n          \"Cannot open $term_window_file: $!\";\nwhile (my $line = <$over2kb_fh>) {\n  chomp $line;\n  my @fields = split(/∖t/, $line);\n  if ($fields[5] eq '+') {\n            print $term_fh join(\"∖t\", $fields[0], $fields[2] +\n          3000,\n$fields[2] + 6000, @fields[3..5]), \"∖n\";\n  } elsif ($fields[5] eq '-') {\n            print $term_fh join(\"∖t\", $fields[0], $fields[1] -\n          6000,\n$fields[1] - 3000, @fields[3..5]), \"∖n\";\n  }\n}\nclose $over2kb_fh;\nclose $term_fh;\n# Define new pre-polyA window from TTS-1000 to TTS+0 (only genes\n          >= 2000 bp and not overlapping any other gene)\nopen $over2kb_fh, '<', $genes_over_2kb_file or die\n          \"Cannot open $genes_over_2kb_file: $!\";\nopen my $poly_fh, '>', $poly_window_file or die\n          \"Cannot open $poly_window_file: $!\";\nwhile (my $line = <$over2kb_fh>) {\n  chomp $line;\n  my @fields = split(/∖t/, $line);\n  if ($fields[5] eq '+') {\n            print $poly_fh join(\"∖t\", $fields[0], $fields[2] - 1000,\n          $fields[2], @fields[3..5]), \"∖n\";\n  } elsif ($fields[5] eq '-') {\n            print $poly_fh join(\"∖t\", $fields[0], $fields[1],\n          $fields[1] + 1000, @fields[3..5]), \"∖n\";\n  }\n}\nclose $over2kb_fh;\nclose $poly_fh;\n# Sort termination and gene polyA window files\nsystem(\"sort -k1,1 -k2,2n\n          $term_window_file > $term_sorted_file\");\nsystem(\"sort -k1,1 -k2,2n\n          $poly_window_file > $poly_sorted_file\");\nprint \"Windowed files sorted∖n∖n\";\n# Calculate coverage over windows, run bedtools with -s option for\n          strandedness (ChAR-seq)\nsystem(\"bedtools coverage -s -a $term_sorted_file -b $frags_file\n          -counts > $term_count_file\") == 0\n          or die \"bedtools coverage failed for\n          $term_sorted_file∖n\";\nsystem(\"bedtools coverage -s -a $poly_sorted_file -b $frags_file\n          -counts > $poly_count_file\") == 0\n          or die \"bedtools coverage failed for\n          $poly_sorted_file∖n\";\nprint \"Read coverage over windows calculated∖n∖n\";\n# Open coverage files\nopen my $promcov, \"<\", \"term.count\" or die\n          \"Can't open term.count: $!\";\nopen my $genecov, \"<\", \"poly.count\" or die\n          \"Can't open poly.count: $!\";\nopen my $bed, \">\", \"readthrough_indices.txt\"\n          or die \"Can't open readthrough_indices.txt: $!\";\n# Print header to output file\nprint $bed\n          \"poly_chr∖tpoly_start∖tpoly_stop∖tpoly_strand∖tpoly_name∖tpoly_cov∖tterm_name∖tterm_start∖tterm_stop∖tterm_strand∖tterm_cov∖tri∖n\";\n# Read through coverage files\nmy %poly_cov;\nwhile (my $line1 = <$promcov>) {\n  chomp $line1;",
    "my ($chr, $start, $stop, $name, $cigar, $strand, $cov) = split /∖t/,\n          $line1;\n          $poly_cov{$name} =\n          \"$chr&$start&$stop&$name&$cigar&$strand&$cov\";\n}\nwhile (my $line2 = <$genecov>) {\n  chomp $line2;\n          my ($term_chr, $term_start, $term_stop, $term_name, $term_cigar,\n          $term_strand, $term_cov) = split /∖t/, $line2;\n# Check if termination coverage file has matching name to polyA\n          window coverage file\n  if (exists $poly_cov{$term_name}) {\n            my $storedvalue = $poly_cov{$term_name};\n            my ($poly_chr, $poly_start, $poly_stop, $poly_name, $poly_cigar,\n          $poly_strand, $poly_cov) = split /&/, $storedvalue;\n            # Calculate readthrough indices\n            if ($poly_cov > 5 && $term_cov > 5) {\n              my $poly_density = $poly_cov / 3000;\n              my $term_size = $term_stop - $term_start;\n              my $term_density = $term_cov / 1000;\n              my $ri = $poly_density / $term_density;\n              print $bed\n          \"$poly_chr∖t$poly_start∖t$poly_stop∖t$poly_strand∖t$poly_name∖t$poly_cov∖t$term_name∖t$term_start∖t$term_stop∖t$term_strand∖t$term_cov∖t$ri∖n\";\n      }\n  }\n}\n# Close files\nclose $promcov;\nclose $genecov;\nclose $bed;\nexit;\n        Compute readthrough indices of readthrough genes and non-readthrough\n        genes for every bam file in step 32.\n#!/bin/bash\n# Note: Step 46\nis standalone and function independently.\n# Variables are defined within this script.\n# Loop through samples, stages, and genes to calculate readthrough\n          indices\nfor sample in dRPB3_IAA RPB3_IAA; do\n  for stage in 0h 1h 3h; do\n            for gene in readthrough non_readthrough; do\n              BED_FILE=\"${sample}_${stage}_${gene}.bed\"\nBAM_FILE=\"${sample}_${stage}_merged.sorted_PE.sorted_DS.bam\"\n              OUT_FILE=\"${sample}_${stage}_${gene}.txt\"\n              # Run Calculate_readthrough_indices.pl command\n              perl Calculate_readthrough_indices.pl \"$BED_FILE\"\n          \"$BAM_FILE\" > \"$OUT_FILE\" || { echo\n          \"Calculate_readthrough_indices.pl failed for $BED_FILE and\n          $BAM_FILE\"; exit 1; }\n      done\n  done\ndone\n      Compare the changes of 3′end processing upon RPB3 and dRPB3 depletion\n    \nTiming: ∼30 min\n        Apply the DESeq2 package to perform the differential 3′end processing\n        analyses before (IAA-0 h) and after (IAA-3 h) dRPB3 or RPB3 depletion.\n      \nNote: The readthrough indices are float\n      numbers generated in step 45, which need to be rounded into an\n      integer.\n    \n        Organize the readthrough indices data into the matrix format required\n        for DESeq2 analysis.\n      \n        Select genes whose adjusted p-values are less than 0.05 and whose",
    "absolute fold changes are greater than 2 (Figure 5[href=https://www.wicell.org#fig5]B).\n        \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2758-Fig5.jpg\n              Figure5. Results of ChAR-seq analysis\n            \n              (A) Metagene profiles of ChAR-seq signals at the polyadenylation\n              sites of readthrough and nonreadthrough transcripts at different\n              time points (0 h, 1 h, and 3 h) after IAA treatment in dRPB3\n              (left) or RPB3 (right) degron cells. Boxplots showing ChAR-seq\n              readthrough indices of gene sets identified by DoGFinder,\n              presented as the median in an interquartile range with whiskers\n              indicating 1.5-fold the interquartile range and confidence region\n              notches. A two-sided Wilcoxon rank-sum test was performed to\n              determine significance. The data were reported as the average of\n              two biological replicates for each treatment.\n            \n              (B) Volcano plots of induced 3′ end-processing changes upon dRPB3\n              (left) or RPB3 (right) depletion, as determined by ChAR-seq.\n            \n              (C) Metagene analysis of spike-in–normalized ChAR-seq reads around\n              annotated polyadenylation sites of ribosomal subunit genes before\n              and after depletion of RPB3 or dRPB3. The corresponding 3′ end RNA\n              processing changes were quantified and displayed as boxplots. The\n              middle line, lower hinge and upper hinge in the boxplot indicate\n              the median, first quartile and third quartile, respectively.\n              Significance was determined by a two-tailed Wilcoxon rank-sum\n              test. ∗P < 0.05, ∗∗∗P < 0.001.\n            \n              Figure reprinted and reorganized with permission from Li et al.1[href=https://www.wicell.org#bib1]\n# This chunk of R code refers to steps 47\nand 49\n# Load required packages\nlibrary(DESeq2)\nlibrary(org.Mm.eg.db)\nlibrary(data.table)\n# read data\nrawcount <-\n          data.table::fread(\"dRPB3_combined_RIs.tsv\")\n# select columns of interest and set GeneID as row names\nct <- data.frame(rawcount[, c(\"dRPB3_IAA_0h_rep1\",\n          \"dRPB3_IAA_0h_rep2\", \"dRPB3_IAA_3h_rep1\",\n          \"dRPB3_IAA_3h_rep2\")])\nrow.names(ct) <- rawcount$GeneID\n# create column data\ncolData <- data.frame(\n          condition = factor(rep(c(\"0h\", \"3h\"), each =\n          2)),\n  ind = factor(c(1, 2, 1, 2)),\n  row.names = colnames(ct)\n)\n# create DESeqDataSet object\ndds <- DESeqDataSetFromMatrix(\n  countData = round(ct, 0),\n  colData = colData,\n  design = ∼ condition + ind\n)",
    "# filter genes with no counts\ndds <- dds[rowSums(counts(dds)) > 0, ]\n# estimate size factors\ndds <- estimateSizeFactors(dds)\n# run DESeq2\ndds <- DESeq(dds)\nres <- results(dds, contrast = c(\"condition\",\n          \"3h\", \"0h\"))\nsummary(res)\n# create differential expression table\ndiff <- data.frame(res@listData, row.names = res@rownames)\nlfc_thresh <- 1\npadj_thresh <- 0.05\n# classify genes based on log2FoldChange and adjusted p-value\ndiff$reg <- \"unchanged\"\ndiff$reg[diff$log2FoldChange < -lfc_thresh &\n          diff$padj < padj_thresh] <- \"down\"\ndiff$reg[diff$log2FoldChange > lfc_thresh &\n          diff$padj < padj_thresh] <- \"up\"\n# display the number of genes in each category\ntable(diff$reg)\ndiff$ensembl_id <- rownames(diff)\n# Mapping Ensembl IDs to gene symbols using org.Mm.eg.db\ngene_name <- mapIds(x=org.Mm.eg.db, keys=diff$ensembl_id, column =\n          \"SYMBOL\", keytype = \"ENSEMBL\")\ngene_name <- data.frame(ensembl_id=names(gene_name),\n          gene=gene_name)\n# Joining 'gene_name' and 'diff' data frames\ndiff <- plyr::join(gene_name, diff, type=\"full\")\nhead(diff)\n# Creating a data frame of normalized counts\nnorm_ct <- as.data.frame(counts(dds, normalized = T))\nnorm_ct$ensembl_id <- rownames(norm_ct)\n# Joining 'norm_ct' and 'diff' data frames\ndiff <- plyr::join(norm_ct, diff, type=\"right\")\nhead(diff)\nthis_tile <- paste0('Up :\n          ',nrow(diff[diff$reg =='up',]) ,' | ','Down :\n          ',nrow(diff[diff$reg =='down',]),' |\n          ','Unchange :\n          ',nrow(diff[diff$reg =='unchanged',]))\n# Calculating the number of genes in each category\nndown <- table(diff$reg)[1]\nnunchange <- table(diff$reg)[2]\nnup <- table(diff$reg)[3]\n# Creating a scatterplot for dRPB3 as displayed in\nFigure 5[href=https://www.wicell.org#fig5]B\n      \n# Note: similar code can be employed for RPB3.\np4 <- ggplot(data = diff, aes(x = log2FoldChange, y = -log(padj),\n          color = reg)) +\ngeom_point() +\n          ggrepel::geom_text_repel(data = filter(diff, gene %in% label_ribo),\n          aes(label = gene), box.padding = 0.5, max.overlaps = Inf) +\n          geom_hline(yintercept = -log(0.05), linetype = \"dashed\",\n          color = \"grey30\") +\n          geom_vline(xintercept = -1, linetype = \"dashed\", color =\n          \"grey30\") +\n          geom_vline(xintercept = 1, linetype = \"dashed\", color =\n          \"grey30\") +\n  xlab(\"log2 (FC)\") +\n  ylab(\"-log10 (p-adj)\") +\n          ggtitle(\"R3F 3h-VS-Dox Readthrough Index\") +\n  scale_x_continuous(limits = c(-5, 5)) +\n  scale_y_continuous(limits = c(0, 30)) +",
    "scale_color_manual(values = c(\"#005792\", \"grey\",\n          \"#ca3e47\"), name = \"\",\n                    label = c(paste0(\"down (\", ndown, \")\"),\n          paste0(\"unchanged (\", nunchange, \")\"),\n          paste0(\"up (\", nup, \")\"))) +\n          theme(plot.title = element_text(colour = \"black\", size =\n          20, hjust = 0.5),\n              axis.line.x = element_blank(), axis.line.y = element_blank(),\n              legend.text = element_text(size = 15),\n              axis.text = element_text(colour = \"black\", size = 17),\n          axis.title = element_text(size = 20),\n              panel.border = element_rect(colour = \"black\", fill = NA,\n          size = 0.5),\n              panel.background = element_blank())\n# Saving the scatterplot as a PDF file\nggsave(p4, filename = \"Figure 5B_dRPB3_scatterplot.pdf\",\n          width = 5, height = 4)\n        Conduct GO term analysis to show distinct gene ontologies of 3′end\n        processing-affected genes linked to ribosomal subunit genes, as\n        described in our publication.1[href=https://www.wicell.org#bib1]\n        Perform a Wilcoxon test to assess the statistical significance of\n        differences in 3′end processing before and after dRPB3 or RPB3 depletion\n        (Figure 5[href=https://www.wicell.org#fig5]C)."
  ],
  "subjectAreas": [
    "Genomics",
    "Gene Expression",
    "Bioinformatics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}