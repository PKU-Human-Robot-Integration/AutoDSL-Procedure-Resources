{
  "id": 2684,
  "origin_website": "Cell",
  "title": "An analysis pipeline to compare explorative locomotion across fish species",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nUsing half tail beats to compare short timescale kinematics\nTiming: 20 min\nThis section makes use of the high frequency acquisition data to calculate short timescale (milliseconds) swimming kinematics such as swimming speed, tail beat frequency and tail angle per half tail beat. This provides information about the swim pattern utilized by the larva to achieve the generated thrust. The MATLAB Signal Processing Toolbox 8.6 and Statistics and Machine Learning Toolbox 12 are used in this section. There are a few external functions that we use and provide with this script (Data S1[href=https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2175-Mmc1.zip]; licenses included wherever applicable). We describe some of the critical or uncommon external functions here:\ninterp1gap: this function interpolates gaps (by default represented by NaN) in data x when the gaps are smaller than certain sample size of s. This avoids interpolation of large gaps. The default interpolation method is linear but can be changed if needed.3[href=https://www.wicell.org#bib3]\ny = interp1gap(x,s).\ntxt2mat: this function can carry out automated data analysis on simple text files (decimal number data with common delimiters). Hence, it can be used to import .csv files easily into MATLAB.4[href=https://www.wicell.org#bib4]\nY = txt2mat(name.csv);\nround_one: the output (y) is the closest odd number to input (a).\ny= round_one(a).\nNote: In additional to the external functions that we provide with this publication and describe here, we describe other critical MATLAB functions that are used within the main script when we encounter them. This will make the adaption of this script to any other programing language easier for readers who are more comfortable with another programing language.\nSmooth the X and Y coordinates using the Savitzky Golay digital filter.\nNote: In MATLAB, sgolayfilt function is used to carry this out.\nUse a 2nd order polynomial fit on a window of 30 ms.",
    "Calculate the displacement and velocity using the filtered X and Y coordinates of the fish centroid.\nNote: sgolayfilt is a MATLAB function which applies a Savitzky-Golay smoothing filter of nth order polynomial and frame length L to the data in vector x.\nY=sgolayfilt(x,n,L);\nMeasure the tail curvature to identify the swim events.2[href=https://www.wicell.org#bib2]\nSelect the number of tail segments incorporated in the analysis based on the reliability of tracking available from raw pixel intensities of the segments.\nAs we want to detect movements, calculate the difference in tail angles.\nCalculate the cumulative sum of the angle differences along the tail to capture the change in the overall curvature of the tail over the local fluctuations.\n% unfiltered raw trace\n>dx = [0; diff(xPos)]; % distance between two consecutive x-coordinates\n>dy = [0; diff(yPos)]; % distance between two consecutive y-coordinates\n% prepare for filtering\n>idx_nan = isnan(dx);\n>idx_nan = find(idx_nan==1);\n% filter positions\n>xPos_filt = sgolayfilt(xPos,2,21);\n>yPos_filt = sgolayfilt(yPos,2,21);\n% displacement and velocity\n>dxF = [0; diff(xPos_filt)]; % distance between two consecutive x-coordinates\n>dyF = [0; diff(yPos_filt)]; % distance between two consecutive y-coordinates\n>tmp_dist_filt = sqrt(dxF.ˆ2 + dyF.ˆ2); % distance moved between iterations, in pixels\n>tmp_dist_filt = tmp_dist_filt./camscale_px_per_mm; % convert to distance in mm\n>tmp_vel_filt = tmp_dist_filt.∗datarate_Hz; % convert to velocity in mm/s\nCalculate the absolute value of this accumulated tail curvature so bends in both directions are considered. Smooth this further to give a single measure of curvature. For the zebrafish, based on the available information on bout duration, beat frequency and inter-bout interval, a maximum filter of 28.6 ms is applied to smooth over individual tail beats, and a minima filter of 572 ms is used to calculate and subtract a rolling background to filter out slow changes in tail posture.",
    "%for the bout detection we smooth the tail curvature to eliminate kinks due to tracking noise\n>for n=2:size(cumsumtailangles,2)-1\n>smoothedCumsumFixedSegmentAngles(:,n)=mean(cumsumtailangles(:,n-1:n+1)');\n>end\n%we consider the difference in segment angles, because we want to detect tail movement\n>fixedSegmentAngles = [zeros(size(cumsumtailangles,2),1)'; diff(smoothedCumsumFixedSegmentAngles)];\n%Filter angles\n>bcsize=14; %this parameter sets the timescale at which to smooth the tail movement\n>filteredSegmentAngle = realSegmentAngles∗0;\n>for n = 1 : (size(realSegmentAngles,2)) %smooth the tail movements at the shorter timescale\n>filteredSegmentAngle(:,n) = conv(realSegmentAngles(:,n),ones(bcsize,1)'/bcsize,'same');\n>end\n%we sum the angle differences down the length of the tail to give prominence to regions of continuous curvature in one direction\n>cumFilteredSegmentAngle = cumsum(filteredSegmentAngle')';\n%we sum up the absolute value of this accumulated curvature so bends in both directions are considered\n>superCumSegAngle = cumsum(abs(cumFilteredSegmentAngle)')';\n%Calculate tail curvature; it convolves all segments in one\n>bcFilt=14; tailCurveMeasure = conv(superCumSegAngle(:,end), ones(bcFilt,1)'/ bcFilt, 'same');\nIdentify the start and end of swimming bouts/events based on empirically selected cut-offs in both the species.\nNote: The cut-offs should work well across various swim types and species if the data is not very noisy.\n% tailCurveMeasure is filtered more and smootherTCM is the resultant filtered curvature measure\n>allbout= smootherTCM>0.13; %empirically selected threshold for one of the species\n>allstart=max([0 diff(allbout')],0);\n>allend=max([0 -diff(allbout')],0);\nNow, detect the half tail beats in the identified swim events.\nDefine a half tail beat as a peak-to-peak half cycle and use this to calculate the short timescale swimming kinematics (Figure 2[href=https://www.wicell.org#fig2]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2175-Fig2.jpg\nFigure 2. Identification of half tail beats\nIllustration of dissection of a swim event into half tail beats for calculation of short timescale swim kinematics.\nTo identify half tail beats, calculate the absolute value of the tail angle signal and then identify the peaks. In MATLAB, the peaks are identified using the findpeaks function.",
    "Note: findpeaks is a MATLAB function that identifies local maxima (peaks) in the input vector (data). It also returns the indices (locs) of the identified peaks.\n[peaks, loc] = findpeaks(data).\nUsing this information about peaks, calculate the kinematic parameters like swim duration, distance, mean and maximum speed, maximum tail angle and half beat frequency on the individual half tail beats.\n>for swm = 1 : length(starts) %go through each swim event\n>tmp_forTBF_intrp=forTBF_intrp(starts(swm):ends(swm));\n>[pks_tmp,locs_tmp]=findpeaks(abs(tmp_forTBF_intrp),'MinPeakProminence',thresholdBeats,'MinPeakDistance',cutOff); %ID all half beats; swim pattern specific thresholds are provided\n>IDfalsePeaks=locs_tmp(forVeloFilt_intrp_filtfilt(locs_tmp)<1);\n>locs_tailPeaks=setdiff(locs_tmp,IDfalsePeaks);\n>beatStarts=[locs_tailPeaks(1:end-1)];\n>beatEnds=[locs_tailPeaks(2:end)];\n>  for nHBT=1:length(beatStarts) %go through each half beat\n    %calculate all the half beat based kinematics here.\n>  end\n>end\nCritical: The filtering is carried out to remove high frequency noise. It is a good practice to compare the filtered signal against the unfiltered signals to make sure that only the high frequency noise is removed, and no artefacts are introduced because of the filtering process. While the selection of filters can vary based on the signal, we share two separate kinematic analysis scripts (see Data S1[href=https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2175-Mmc1.zip]) for analysis of intermittent and continuous swimming patterns. This is expected to apply to a variety of species with differing swim patterns. The user is expected to select the script based on whether the animal’s navigation fits an intermittent or continuous swimming pattern (see problem 2[href=https://www.wicell.org#sec5.3]).\nUsing mean square displacement and heading decorrelation to compare long timescale kinematics\nTiming: 20 min",
    "This section only uses low frequency acquisition data (or down sampled high frequency data) to compute the mean square displacement (MSD) and heading persistence (R) as a function of time. R(Δt) is defined as the mean dot product of the heading vectors computed at time points separated by a delay Δt. The heading persistence thus characterizes how the correlation in heading orientation is progressively lost as the animal explores its environment. A purely ballistic (straight) movement correspond to R=1 for any delay. Reversely, for a purely diffusive process, R immediately decays to zero. Together, these two quantities characterize the spatial and angular dynamic underlying the long timescale (seconds) exploration of the fish.\nThis section makes use of the MATLAB Signal Processing Toolbox 8.6, Statistics and Machine Learning Toolbox 12, and Statistics and Machine Learning Toolbox 12.1.\nApply a Savitsky-Golay filter on the X/ Y traces to fit a 2nd order polynomial on a 200 ms window.\nDown sample the filtered trajectories to 70 Hz.\nNote: This is done as our original sampling rate was 700 Hz. Perform this step only if it applies to your acquisition.\n>x=dt(n).xPos;\n>y=dt(n).yPos;\ndownsample=70; % data are downsampled by this factor for the analysis.\n>x=sgolayfilt(x,2,2∗downsample+1); % filter trajectories over twice the sampling window\n>y=sgolayfilt(y,2,2∗downsample+1);\n>x=x([1:downsample:end]); % downsample\n>y=y([1:downsample:end]);\n>w=find(((x-center(1)).ˆ2+(y-center(2)).ˆ2)>Radiusˆ2); % detect positions too close to the border\n>IndIn=ones(length(x),1);\n>IndIn(w)=0; % IndIn is one when the fish is inside the ROI, zero otherwise\ndt_v=2; % time interval over which to compute heading orientation (in number of tau)\ndelta=[0:1:200]; % time indices at which we evaluate MSD (i.e., 0 to 20 s every 0.1 s)",
    "Identify discrete continuous trajectories in a circular region within the arena (Figure 3[href=https://www.wicell.org#fig3]). In doing so, we remove parts of the trajectories close to the border of the dish which may affect the exploratory dynamics of the fish.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2175-Fig3.jpg\nFigure 3. Identification of discrete swim trajectory\nIllustration of discrete swim trajectories identified for calculation of long timescale swim kinematics. An example trajectory is highlighted in red. The ROI (dark grey) is used to avoid border-induced bias in the swimming activity.\nEvery 100-ms time step, calculate the time-evolution of MSD and R over all the identified trajectories.\n% separate the data into a discrete collection of trajectories within the ROI\n>[L,Ntraj]=bwlabel(IndIn); % Ntraj is the number of trajectories\n>Ltraj=zeros(Ntraj,1); % Ltraj gives the length of each trajectory\n>for traj=1:Ntraj;\n>  Ltraj(traj)=length(find(L==traj));\n>end\n>Xsp=NaN(Ntraj, max(Ltraj)); % x,y position split in trajectories\n>Ysp=NaN(Ntraj, max(Ltraj));\n>theta=NaN(Ntraj, max(Ltraj)-dt_v); % heading orientation\n>Npoints_dt(n)=length(find(IndIn==1 & isnan(x)==0));\n% The X and Y positions vectors are split into separate trajectories defined as uninterrupted periods during which the animal remains in the ROI : Xsp(i,j) is the X coordinates for the ith trajectory at time j counted from the onset of this particular trajectory.\n>for traj=1:Ntraj;\n>  Xsp(traj,1:Ltraj(traj))=x(find(L==traj));\n>  Ysp(traj,1:Ltraj(traj))=y(find(L==traj));\n% Same computation is performed for the heading vector [dX,dY]. The heading angle is only computed when the animal has moved over at least 10 pixels over 1 s.\n>  dXsp=Xsp(traj,(dt_v+1):end)-Xsp(traj,1:end-dt_v);\n>  dYsp=Ysp(traj,(dt_v+1):end)-Ysp(traj,1:end-dt_v);\n>  w=find(dXsp.ˆ2+dYsp.ˆ2)>100;\n>  theta(traj,w)=atan2(dYsp(w),dXsp(w));\nTo calculate R (heading persistence), if the fish moves at least 0.5 mm, extract at each time t a unit vector u(t) aligned along the fish displacement [dx, dy] calculated over a 1 s time window.\nCompute the heading decorrelation over a period Δt as R(Δt)=<u(t).u(t + Δt)>t.",
    "% First we calculate the MSD. we successively compute the mean displacement travelled over time delay delta(k).\n>for k=1:length(delta);\n>    p=delta(k);\n>    dx=Xsp(:,(p+1):end)-Xsp(:,1:end-p);\n>    dy=Ysp(:,(p+1):end)-Ysp(:,1:end-p);\n>    MSD(k,n)= nanmean(dx(:).ˆ2+dy(:).ˆ2); % recall n is the fish index\n% we also compute the standard error of the mean for each time delay\n>    Ndata=sum(isfinite(dx(:))==1);\n>    if Ndata >=1;\n>    semMSD(k,n)=nanstd(dx(:).ˆ2+dy(:).ˆ2)/sqrt(Ndata);\n>    end\n% The heading persistence, i.e., the mean of the heading vectors dot product, is computed as the cosine of the reorientation angle dtheta\n>    dtheta=theta(:,(p+1):end)-theta(:,1:end-p);\n>    R(k,n)=nanmean(cos(dtheta(:)));\n>    \n>    Ndata=sum(isfinite(dtheta(:))==1);\n>end\nR quantifies the heading persistence in a given time period. R = 1 indicates a perfect maintenance of the heading orientation, whereas R = 0 indicates a complete randomization of the orientation."
  ],
  "subjectAreas": [
    "Bioinformatics",
    "Neuroscience",
    "Model Organisms",
    "Behavior"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Ecology & Environmental Biology",
    "Bioinformatics & Computational Biology"
  ]
}