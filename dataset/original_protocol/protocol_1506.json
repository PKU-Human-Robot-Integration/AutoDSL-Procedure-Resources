{
  "id": 1611,
  "origin_website": "Cell",
  "title": "Protocol for post-processing of bacterial pangenome data using Pagoo pipeline",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nStep 1: Installing Pagoo\nTiming: 4 min\nFull installation of Pagoo includes downloading the Pagoo package and resolving all its dependencies from CRAN. Alternatively, the last development version of Pagoo can be installed from GitHub.\nInstall Pagoo from CRAN by running the following code:\ninstall.packages(\"pagoo\")\nAlternatively, install Pagoo from GitHub by running the following code:\nif (!require(\"devtools\"))\ndevtools::install_github(\"iferres/pagoo\")\nStep 2: Loading pangenome data from scratch\nTiming: 5 min\nFirst, we provide a toy example that describes how to create Pagoo’s data structure from scratch independently of the pangenome reconstruction software that was used to generate the data. This toy dataset is included when the user installs Pagoo package.\nGenerate a Pagoo object. To generate a Pagoo object, the only mandatory data structure is a data.frame with information relating organisms to genes to orthologous clusters. Other optional data can be also added as additional columns or tables. Load toy example files by running the code in Box 3:\nlibrary(pagoo)\ntgz <- system.file(\"extdata\", \"toy_data.tar.gz\", package = \"pagoo\")\nuntar(tarfile = tgz, exdir = \".\")\nfiles <- list.files(full.names = TRUE, pattern = \"tsv$|fasta$\")\nWe will see the case_df.tsv file that is the mandatory data.frame. Run the code in Box 4 to load and inspect it:\ndata_file <- grep(\"case_df.tsv\", files, value = TRUE)\ndata <- read.table(data_file, header = TRUE,\n          sep = \"\\t\", quote = \"\")\nhead(data)\n##        gene        org cluster                                annot\n## 1  gene081  organismA  OG001  Thioesterase superfamily protein\n## 2  gene122  organismB  OG001          Thioesterase superfamily\n## 3  gene299  organismC  OG001  Thioesterase superfamily protein\n## 4  gene186  organismD  OG001  Thioesterase superfamily protein\n## 5  gene076  organismE  OG001          Thioesterase superfamily\n## 6  gene352  organismA  OG002  Inherit from proNOG: Thioesterase",
    "The first column in this file identifies each gene, the second column identifies the organism to which each gene belongs and the third column shows the orthologous cluster to which each gene was assigned in the pangenome reconstruction. The fourth column shows the annotation of each gene (optional as other additional metadata columns that can be added to this table). With only this data you can start working with Pagoo as follows:\np <- pagoo(data = data)\nAdding metadata to organisms. Relevant data associated to each organism (i.e., geographic origin, collection date, phenotyping, etc.) can be added to the basic pangenome structure as detailed in Box 5:\norgs_file <- grep(\"case_orgs_meta.tsv\", files, value = TRUE)\norgs_meta <- read.table(orgs_file, header = TRUE,\n                            sep = \"\\t\", quote = \"\")\nhead(orgs_meta)\n##           org sero    country\n## 1  organismA    a    Westeros\n## 2  organismB    b    Westeros\n## 3  organismC    c    Westeros\n## 4  organismD    a      Essos\n## 5  organismE    b      Essos\nCritical: Beware that organism names provided in orgs_meta$org must coincide with names provided in the data$org field, in order to correctly map each variable.\nNote: If partial metadata is available, for example host data is only available for a subset of organisms, fields with missing data will be automatically filled with NAs.\nAdding metadata to orthologous clusters. Relevant data can be also incorporated to each orthologous cluster, for example its functional annotation as detailed in Box 6 (see here for a guide for generating functional annnotations using the eggNOG database and related tools):\nclust_file <- grep(\"case_clusters_meta.tsv\", files, value = TRUE)\nclust_meta <- read.table(clust_file, header = TRUE,\n                            sep = \"\\t\", quote = \"\")\nhead(clust_meta)\n##     cluster    kegg    cog\n## 1    OG001    <NA>      S\n## 2    OG002    <NA>      S\n## 3    OG003    <NA>  <NA>\n## 4    OG004    <NA>      D\n## 5    OG005    K01990    V",
    "## 6    OG006    <NA>      V\nCritical: Again, the column clust_meta$cluster must contain the same identifiers as the data$cluster column to be able to map one into the other.\nAdding sequences. If the user wants to add sequences, these must be provided for all organisms in the dataset. The type of data needed are multi-FASTA files where each individual sequence represents a gene whose name can be mapped to the data$gene column. Sequences need to be loaded as a list where each element is named with an organism name that maps to data$org and org_meta$org. This can be done as described in Box 7:\nfasta_files <- grep(\"[.]fasta\", files, value = TRUE)\nnames(fasta_files) <- sub(\"[.]fasta\", \"\", basename(fasta_files))\nlibrary(Biostrings)\nsq <- lapply(fasta_files, readDNAStringSet)\n# Names are the same as in data$org\n## [1] \"organismA\" \"organismB\" \"organismC\" \"organismD\" \"organismE\"\nNote: Pagoo currently supports the incorporation of DNA sequences. However, once sequences are incorporated into the Pagoo object, these can be translated and used as protein sequences for downstream analysis using Biostrings and other R packages.\nGenerate an object with multiple data. Now, we can set up a Pagoo object integrating all this data, including presence/absence of each orthologous cluster in each organism, gene annotations, functional annotations, organisms metadata and sequences. To build the Pagoo object run the code in Box 8:\np <- pagoo(data = data, # Required data\n            org_meta = orgs_meta, # Organisms metadata\n            cluster_meta = clust_meta, # Clusters metadata\n            sequences = sq) # Sequences",
    "Adding more metadata after creating the Pagoo object. The user can add new metadata as the outcome of downstream analysis or experiments. This can be achieved by adding new metadata columns either to each gene, cluster or organism defined in the Pagoo object. By running the following code, we illustrate how to add a new column to the $organisms field named host that describes the host where each organism was isolated from (see Box 9):\nhost_df <- data.frame(org = p$organisms$org,\n                        host = c(\"Cow\", \"Dog\", \"Cat\", \"Cow\", \"Sheep\"))\np$add_metadata(map = \"org\", host_df)\np$organisms\n##          org    sero    country      host\n## 1  organismA        a  Westeros      Cow\n## 2  organismB        b  Westeros      Dog\n## 3  organismC        c  Westeros      Cat\n## 4  organismD        a      Essos      Cow\n## 5  organismE        b      Essos    Sheep\nCritical: To allow Pagoo to correctly map the data, values in the first column of the host_df table must be the same as in p$organisms$org, and its column header must also be named org.\nNote: Preparing data from scratch and loading classes can be relatively laborious, but in real life working datasets this will be rarely needed. To avoid this, Pagoo provides helper functions that directly parse and read-in output files produced by most widely-used pangenome reconstruction software, avoiding any formatting or manipulation of data (see next step).\nStep 3: Input from pangenome reconstruction software\nTiming: 10 min",
    "Pagoo allows read-in output files produced by most widely-used pangenome reconstruction software. Since its publication in 2015, Roary (Page et al., 2015[href=https://www.wicell.org#bib4]) has been the standard and most cited software for pangenome reconstruction. More recently, other related software have emerged like PIRATE (Bayliss et al., 2019[href=https://www.wicell.org#bib1]), Panaroo (Tonkin-Hill et al., 2020[href=https://www.wicell.org#bib7]) and PEPPAN (Zhou et al., 2020[href=https://www.wicell.org#bib10]) that improved different steps of pangenome reconstruction or provided new analytical approaches. Also, we have created our own pangenome reconstruction software called Pewit (unpublished but available at https://github.com/iferres/pewit[href=https://github.com/iferres/pewit]), which automatically generates a Pagoo-like object to perform downstream analyses. This object contains all the methods and fields that Pagoo provides, but adding a set of methods and fields exclusive to Pewit (not covered in this protocol). Here, we provide full details on how to load output files from Roary and indicate how to load output files from other above-listed software.\nTo create a pangenome object using Pagoo from output files produced by Roary (as described in step 2), run the code described in Box 10 assuming you are placed in the output directory generated by Roary:\ngffs <- list.files(path = \"../gffs/\", pattern = \"[.]gff$\", full.names = TRUE)\ngpa_csv <- \"gene_presence_absence.csv\"\nlibrary(pagoo)\np <- roary_2_pagoo(gene_presence_absence_csv = gpa_csv, gffs = gffs)\nNote: Exactly the same approach can be used to load output files from Panaroo, by using the analogous function panaroo_2_pagoo(). Other software like PIRATE and PEPPAN provide scripts (PIRATE_to_roary.pl and PEPPAN_parse.py, respectively) that transform their output files into Roary’s output format. Then, roary_2_pagoo() function can be used to generate the pangenome object from PIRATE and PEPPAN once this transformation has been applied.\nStep 4: Querying pangenome data\nTiming: 10 min",
    "The user can easily explore information that is stored inside the Pagoo object using standard R notation. Indeed, this object has its own associated data and methods that can be easily queried with the '$' operator. These methods allow for the rapid subsetting, extraction and visualization of pangenome data.\nSummary statistics. A pangenome can be stratified in different gene subsets according to their frequency. The core genes are defined as those present in every genome (also the term soft core is typically used for genes occurring in 95%–100% of genomes). The remaining genes are defined as the accessory genome, that can be subdivided in cloud genes or singletons (present in only one genome or only in genomes that) and shell genes which are those in the middle. Run the following code in Box 11 to see this:\np$summary_stats\n#    Category  Number\n# 1    Total    7326\n# 2    Core    1489\n# 3    Shell    5010\n# 4    Cloud    818\nCore level. The core level defines the minimum number of genomes (as a percentage) in which a certain gene should be present to be considered a core gene. By default, Pagoo considers as core genes all those present in at least 95% of organisms. The core level can be modified to be more or less stringent defining the core genome. Modifying the core level will affect the pangenome object state resulting in different core, shell and cloud sets. See this running the command in Box 12:\np$core_level # [1] 95\np$core_level <- 100 # Change value\np$summary_stats # Updated object\n#    Category    Number\n# 1      Total      7326\n# 2      Core      1117\n# 3      Shell      5391\n# 4      Cloud        818",
    "Pangenome matrix. The pangenome matrix is one of the most useful things when analyzing pangenomes. Typically, it represents organisms in rows and clusters of orthologous genes in columns informing about gene abundance (considering paralogues). The pangenome matrix looks like the one shown in Box 13 (printing only first 5 rows and columns):\np$pan_matrix[1:5, 1:5]\n#               aadK   aaeA_1   aaeA_2   aat   aat_2\n# 16244_6#1      1        0        0    1      0\n# 16244_6#10    0        0        0    1      0\n# 16244_6#11    1        0        0    1      0\n# 16244_6#12    0        0        0    1      0\n# 16244_6#13    1        0        0    1      0\nGenes metadata. Metadata associated with each individual gene can be accessed by the $genes suffix. It always contains the gene name, the organism to which it belongs, its assigned cluster and a gene identifier (gid). Optionally, it can typically include annotation data, genomic coordinates, etc. Gene metadata is splitted by cluster, so it consists of a list of dataframes (Box 14, showing only the first rows):\np$genes[1]\n# SplitDataFrameList of length 1\n# $aadK\n# DataFrame with 7 rows and 10 columns\n#                      cluster           org                 gene                      gid\n#                      <factor>    <factor>            <factor>            <character>\n# 16244_6#1_00636      aadK    16244_6#1    16244_61_00636    16244_6#1__16244_6..\n# 16244_6#11_00101      aadK  16244_6#11  16244_6#11_00101  16244_6#11__16244_6..\n# 16244_6#13_00100      aadK  16244_6#13  16244_6#13_00100  16244_6#13__16244_6#..\nClusters metadata. Groups of orthologous genes (clusters) are also stored in Pagoo objects as a table with a cluster identifier per row, and additional columns as optional metadata (Box 15, showing only first rows):\np$clusters\n# DataFrame with 7326 rows and 2 columns\n#   cluster                Annotation\n#<factor>                <character>\n# 1  aadK        hypothetical protein\n# 2  aaeA_1    Ribonuclease P prote..\n# 3  aaeA_2    N-carbamoyl-D-amino..\n# 4  aat        putative ABC transpo..\n# 5  aat_2      hypothetical protein",
    "Sequences. Although it is an optional field (it exists only if the user provides this data as an argument when the object is created), $sequences gives access to sequence data. Sequences are stored as a DNAStringSetList object as defined in the Biostrings package. The code in Box 16 will list all sequences in clusters (only showing first rows):\np$sequences\n# DNAStringSetList of length 7326\n# [[\"COQ2\"]] 16244_6#1__16244_6#1_01627=ATGGCTAAATTTACTCAAATTTTAAAAGATATAAACGAA…\n# [[\"COQ3_1\"]] 16244_6#1__16244_6#1_00352=ATGAGTAACGCAAACGCATGGGACGATATGTCAAATT…\n# [[\"COQ3_2\"]] 16244_6#10__16244_6#10_01654=ATGAAAAAAACGTTTTCATTTGGAAAAAACTGGCT…\n# [[\"COQ3_3\"]] 16244_6#1__16244_6#1_00772=ATGAAAGAAAAGTTTTTTGAACTAAAAGTTTTAAGCC...\nThen, you can list all sequences of a single cluster by running the code in Box 17 (only showing first rows):\np$sequences[[\"aadK\"]]\n# DNAStringSet object of length 7:\n# [1] 858 ATGAAAATGAGAACAGAGAAACA...AAAAAGAAAAATATCAAAGATAA 16244_6#1__16244_…\n# [2] 858 ATGAAAATGAGAACAGAGAAACA...AAAAAGAAAAATATCAAAGATAA 16244_6#11__16244…\n# [3] 858 ATGAAAATGAGAACAGAGAAACA...AAAAAGAAAAATATCAAAGATAA 16244_6#13__16244…\n# [4] 858 ATGAAAATGAGAACAGAGAAACA...AAAAAGAAAAATATCAAAGATAA 16244_6#6__16244_…\nCritical: Note that sequence names are created by pasting organism names and gene names, separated by a string that by default is sep = '__' (two underscores). This is the same as the gid column in the $genes field, and is initially set when a Pagoo object is created. If you think your dataset contains names with this separator, then you should set this parameter to another string to avoid conflicts.\nNote: Sequences can be written to text as multi-FASTA format files using standard methods provided by the Biostrings package.\nOrganisms metadata. The $organisms field contains a table with organisms and metadata as additional columns if provided (Box 18, only showing first rows):\np$organisms\n# DataFrame with 168 rows and 10 columns\n#     org      Accession.Number  Identifier    Strain    Year    Country\n#     <factor><character>  <character>  <character>  <integer>  <character>\n# 1  16244_6#1  ERS672242          FR10    2006/367h        2006        France\n# 2  16244_6#10  ERS672251          FR19    2008/755h        2008        France\n# 3  16244_6#11  ERS672252          FR20    2008/898h        2008        France\n# 4  16244_6#12  ERS672253          FR21    2010/41h        2010        France\n# 5  16244_6#13  ERS672254          FR22    2010/524h        2010        France",
    "Step 5: Data subsetting\nTiming: 10 min\nData subsetting is a fundamental operation when working with pangenome, enabling structured and more in depth analyses. Pagoo provides three ways of subsetting: (i) predefined subsets, (ii) classic R’s subsetting operations using square bracket operators, and (iii) removal or recovering organisms from the dataset.\nPredefined subsets. As explained in step 10, elements within a pangenome can be classified in different compartments given their frequency of occurrence: core, shell and cloud. Pagoo provides operators to directly access elements in these compartments, independently if they are genes, clusters or sequences. Look at the following table for all possible combinations:\ntable:files/protocols_protocol_1048_1.csv\nAs seen in the above table, the notation is quite straightforward. See example in Box 19 using $clusters to illustrate this better:\ndim(p$clusters)[1]\n# [1] 7326\ndim(p$core_clusters)[1]\n# [1] 1498\ndim(p$shell_clusters)[1]\n# [1] 5010\ndim(p$cloud_clusters)[1]\n# [1] 818\nIt can be appreciated that the total number of orthologous clusters in this pangenome is 7326, but only 1498 represent clusters of core genes.\nStandard R subsetting notation. Elements represented as matrices or vectors contained in the Pagoo object can be subsetted using standard R notation using square brackets. Let’s see a couple of examples.\nSubsetting the pangenome matrix (Box 20):\np$pan_matrix[1:3, 10:15]\n#               accB  accB_1  accC  accC_1  accD  accD_2\n# 16244_6#1      1        0      1        0      1        0\n# 16244_6#10    1        0      1        0      1        0\n# 16244_6#11    1        0      1        0      1        0\nSubsetting core sequences (Box 21):\np$core_sequences[c(1,30)]\n# DNAStringSetList of length 2\n# [[\"COQ2\"]] 16244_6#1__16244_6#1_01627=ATGGCTAAATTTACTCAAATTTTAAAAGATATAAACGAA…\n# [[\"ansA\"]] 16244_6#1__16244_6#1_00415=ATGTGCTTAAAAAAGGTGTTTATACTTATGCTGATTACG…",
    "Dropping and recovering organisms. The possibility of hiding certain organisms from the dataset is useful if we want to remove some genome with abnormal characteristics (i.e., potentially contaminated), if we want to focus just in a subset of genomes of interest given any metadata value, or if we included an outgroup for phylogenetic purposes but we want to discard it from downstream analyses. The following steps show how this works:.\nWe are working with 168 organisms in the dataset, out of which 74 are from human origin (see Box 22):\ntable(p$organisms$Host)\n# Bovine Human Monkey Ovine Turtle\n# 78 74 1 13 2\nWe will hide these 74 from the dataset (see Box 23):\nto_drop <- which(p$organisms$host==\"Human\")\np$drop(to_drop)\ntable(p$organisms$host)\n# Bovine  Monkey  Ovine  Turtle\n# 78        1      13        2\nNote: When the user hides a set of organisms, this will have an impact on all the information stored in the object. This means that all features associated with these genomes including genes, sequences, clusters and metadata will be hidden. It is important to note that the user does not have to reassign the object to a new one, it is self-modified (in place modification) according to R6 reference semantics.\nTo recover hidden organisms run the following (see Box 24):\ndropped <- p$dropped p$recover(dropped)\nStep 6: Built-in methods and visualizations\nTiming: 10 min\nPagoo provides basic but fundamental statistical analyses and visualizations for straightforward exploration of pangenome features. All these methods are embedded in the Pagoo object.\nPrincipal Components Analysis (PCA). PCA is a fundamental statistical tool that can be applied to pangenome data to see how organisms are grouped based on the diversity of their accessory genes. PCA can be calculated directly from the Pagoo object as follows (Figure 1[href=https://www.wicell.org#fig1]):\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1048-Fig1.jpg\nFigure 1. Principal components analysis",
    "A PCA is generated directly from the gene presence/absence matrix and in this case organisms are colored by host of origin.\nGenerate a standard PCA object for downstream analysis:\npca <- p$pan_pca()\nDirectly visualizing the first 2 PCs using a biplot. This uses the previous method to perform the PCA but allows you to generate a customizable ggplot2 object on the fly (see Box 25):\np$gg_pca(color = \"Host\", size = 4) +\n      theme_bw(base_size = 15) +\n      scale_color_brewer(palette = \"Set2\")\nRarefaction curves. Pangenome curves (Figure 2[href=https://www.wicell.org#fig2]) show the number of gene clusters that are subsequently discovered as more genomes are added to the dataset. If the pangenome is open, more novel accessory genes will be discovered as new genomes are added and the size of the core genome will tend to decrease. Pagoo applies the Power-law distribution to fit the pangenome size and the Exponential decay function to fit the core genome size. Run this method and customize results as shown in Box 26:\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1048-Fig2.jpg\nFigure 2. Pangenome curves\nPangenome curves show the accessory and core genome size and are indicative of the gene pool size in a certain dataset.\np$gg_curves(size = 2) +\n  ggtitle(\"Pangenome curves\") +\n  geom_point(alpha = 0.1, size = 4) +\n  theme_bw(base_size = 15) + ylim(0, 5000) +\n  scale_color_brewer(palette = \"Accent\")\nOther methods. Pagoo provides further methods for summary statistics whose application is analogous to the above described ones. These include pie charts using $gg_pie(), gene presence/absence bin maps using $gg_binmap() and gene frequency bar plots using $gg_barplot().\nDynamic visualization. The above-mentioned plots for summary statistics can be deployed through a R Shiny application, allowing responsive and dynamic exploration of pangenome data. The application can be run as follows:\np$runShinyApp()",
    "CAUTION: The method described in step 23 (R-Shiny application) is currently not intended for very large datasets, as it may render slow. We recommend it to work with dozens to hundreds of genomes. For bigger pangenomes we recommend the use of the R command line.\nNote: An online example for a set of 69 genomes can be found here.\nStep 7: Downstream analyses using recipes\nTiming: 20 min\nHere we show how Pagoo can interact with other R or external tools to generate more complex analyses. We introduce the concept of Pagoo recipes, that are concise pieces of code to complete different tasks. By using these recipes (or creating new ones) the user can take full profit of functionalities provided by Pagoo to perform a variety of analyses including phylogenetics, pangenome-wide association studies, sequence comparisons, ecological measures, preparation of publication-quality figures, among others. In this protocol, we provide a couple of examples of how to create these recipes, which can be found on GitHub.\nPublication quality figures. The following recipe (Box 27) allows to produce a publication quality figure showing pangenome main features using the previously mentioned methods (result shown in Figure 3[href=https://www.wicell.org#fig3]), directly from the Pagoo object in the R session:\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1048-Fig3.jpg\nFigure 3. Visualization of pangenome features\nPagoo can be integrated with other R packages to produce publication-quality figures in a simple way. In this case, the figure shows an assembly of different analyses that summarize general features of this example pangenome: (A) pangenome curves, (B) gene frequency plots, (C) Accessory genes PCA and (D) pie chart with gene subsets.\n# 1. Pangenome curves\npanel1 <- p$gg_curves() +\n    scale_color_manual(values = c(\"black\", \"black\")) +\n    geom_point(alpha = .05, size = 4, color = \"grey\") +\n    theme_bw(base_size = 15) +\n    labs(subtitle = \"A\") +\n    theme(legend.position = \"none\",",
    "axis.title = element_text(size = 12),\n      axis.text = element_text(size = 12))\n# 2. Gene frequency bar plots\npanel2 <- p$gg_barplot() +\n    theme_bw(base_size = 15) +\n    labs(subtitle = \"B\") +\n    theme(axis.title = element_text(size = 12),\n      axis.text = element_text(size = 12)) +\n    geom_bar(stat = \"identity\", color = \"black\", fill = \"black\")\n# 3. PCA of accessory genes colored by host\npanel3 <- p$gg_pca(color = \"Host\", size = 4) +\n    theme_bw(base_size = 15) +\n    labs(subtitle = \"C\") +\n    guides(color = guide_legend(nrow = 2, byrow = T)) +\n    theme(legend.position = \"bottom\",\n      legend.title = element_blank(),\n      legend.text = element_text(size = 10),\n      axis.title = element_text(size = 12),\n      axis.text = element_text(size = 12))\n# 4. Pie chart of core and accessory genes\npanel4 <- p$gg_pie() + theme_bw(base_size = 15) +\n    scale_fill_brewer(palette = \"Blues\") +\n    scale_x_discrete(breaks = c(0, 25, 50, 75)) + labs(subtitle = \"D\") +\n    theme(legend.position = \"bottom\", legend.title = element_blank(),\n      legend.text = element_text(size = 10),\n      legend.margin = margin(0, 0, 13, 0), legend.box.margin = margin(0, 0, 5, 0),\n      axis.title = element_blank(), axis.ticks = element_blank(),\n      axis.text.x = element_blank())\n# 5. Use patchwork to arrange plots using math operators\nlibrary(patchwork)\nfigure <- (panel1 + panel2) / (panel3 + panel4)\nNote: Pagoo includes a responsive visualization dashboard through a R-Shiny application that allows the user to explore pangenome characteristics and perform standard comparative analyses like those shown in Figure 3[href=https://www.wicell.org#fig3]. For a pangenome object named p, deploy the Shiny application running p$runShinyApp().\nCore genome phylogeny and population structure. The following recipe (Box 28) shows how to build a phylogenetic tree directly from the Pagoo object by using concatenated alignments of each individual core gene. This is performed by interacting with diverse R packages like Biostrings and DECIPHER (Wright, 2015[href=https://www.wicell.org#bib8]) for sequence handling and alignment, phangorn (Schliep, 2011[href=https://www.wicell.org#bib5]) for phylogenetic reconstruction, and ggtree (Yu et al., 2017[href=https://www.wicell.org#bib9]) for tree visualization.",
    "# Load required packages\nlibrary(magrittr)\nlibrary(DECIPHER)\nlibrary(Biostrings)\nlibrary(phangorn)\nlibrary(ggtree)\nlibrary(rhierbaps)\n# Drop Cft and set core level to 100\ncft <- p$organisms[which(p$organisms$Subspecies==\"Cft\"),\"org\"]\np$drop(cft)\np$core_level <- 100\n# Align individual core genes\nali <- p$core_seqs_4_phylo() %>%\n  lapply(DECIPHER::AlignTranslation)\n# Identify neutral core clusters using Tajima's D\ntajD <- ali %>%\n    lapply(ape::as.DNAbin) %>%\n    lapply(pegas::tajima.test) %>%\n    sapply(\"[[\", \"D\")\nneutral <- which(tajD <= 2 & tajD >= -2)\n# Concatenate neutral core gene clusters\nconcat_neu <- ali[neutral] %>%\n      do.call(Biostrings::xscat, .) %>%\n      setNames(p$organisms$org) %>%\n      as(\"matrix\") %>%\n      tolower()\n# Find population structure with RhierBAPS\nrhb <- hierBAPS(snp.matrix = concat_neu, n.pops = 10,\n        max.depth = 1, n.extra.rounds = 5)\n# Add lineage information to organisms metadata\nres <- rhb$partition.df\nlin <- data.frame(org = as.character(res[, 1]),\n          lineage = as.factor(res[, 2]))\np$add_metadata(map = \"org\", data = lin)\n# Compute phylogeny\ntre <- concat_neu %>%\n  phangorn::phyDat(type = \"DNA\") %>%\n  phangorn::dist.ml() %>%\n  phangorn::NJ()\n# Draw phylogeny with lineage and host information\ngg1 <- ggtree(tre, ladderize = T, layout = \"slanted\") %<+%\n  as.data.frame(p$organisms) +\n  geom_tippoint(aes(color = as.factor(lineage))) +\n  labs(subtitle = \"A\") +\n  scale_color_discrete(\"Lineage\")\ngg2 <- ggtree(tre, ladderize = T, layout = \"slanted\") %<+%\n  as.data.frame(p$organisms) +\n  geom_tippoint(aes(colour = as.factor(Host))) +\n  labs(subtitle = \"B\") +\n  scale_colour_discrete(\"Host\")\nfig2 <- gg1 + gg2\nResults presented in Figure 4[href=https://www.wicell.org#fig4] exemplify how a relatively complex task that needs of many steps like extracting core genes, keeping those that show signal of neutral evolution, aligning and concatenating them, determining population structure to finally perform a phylogenetic reconstruction, can be achieved directly from the Pagoo pangenome object with different sequential code recipes using different microbial genomics packages within the R environment.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1048-Fig4.jpg\nFigure 4. Core genome phylogenies",
    "This shows the output of the above-described recipe aiming to generate a core genome phylogeny directly from the pangenome object. Panel (A) shows the three colored by lineage defined in the same recipe through a population structure analysis and panel (B) shows the tree colored by host.\nStep 8: Saving and loading pangenome data\nTiming: 5 min\nOnce the pangenome object is created, Pagoo provides two methods for saving and reloading it to a new R session:\nSaving as plain text files (Box 29):\noutdir <- paste(\".\", \"my_pangenome\", sep = \"/\")\np$write_pangenome(dir = outdir)\nlist.files(outdir, full.names = TRUE)\n## [1] \"./my_pangenome/clusters.tsv\"\n## [2] \"./my_pangenome/data.tsv\"\n## [3] \"./my_pangenome/organisms.tsv\"\nThis will create a directory with 3 text files. The advantage of this approach is that you can analyze it outside R, the disadvantage is that full reproducibility can be compromised since reading text could be less stable (classes or number precision can be lost).\nSaving as R data format (Box 30):\nrds <- paste(\"./my_pangenome\", \"pangenome.RDS\", sep = \"/\")\np$save_pangenomeRDS(file = rds)\np2 <- load_pangenomeRDS(rds)\nThis solution preserves data structures, such as column data types (numeric, character or factor). So, this method is more stable (compatible between Pagoo versions), secure (uses the same metadata classes), and convenient (the exact state of the object can be saved and restored, keeping all modifications performed to the object during the analysis). Importantly, this option allows to store all pangenome data in a single and easily shareable file.\nNote: Authors recommend using the R data format for saving and loading Pagoo objects."
  ],
  "subjectAreas": [
    "Genomics",
    "Microbiology",
    "Bioinformatics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}