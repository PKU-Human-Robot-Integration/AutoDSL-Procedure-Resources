{
  "id": 4195,
  "origin_website": "Cell",
  "title": "A computational approach for identification of core modules from a co-expression network and GWAS data",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nNote: Further discussion of the research questions underlying this protocol can be found in our two prior publications that leveraged this approach (Calabrese et al., 2016[href=https://www.wicell.org#bib7], Sabik et al., 2020[href=https://www.wicell.org#bib30]). For example, in these publications, we explore the specificity of the module enrichments against other GWAS studies and more deeply characterize the topology of the genes in the annotated gene lists within the co-expression modules.\nStep 1: Creating GWAS gene list\nTiming: 20 min\nIn order to identify co-expression modules enriched for GWAS genes, we first identify all genes overlapping a GWAS locus, defined as the set of SNPs in high linkage disequilibrium with the lead SNP.\nUsing the previously identified GWAS study, read in the list of lead SNPs that are significantly associated with the study trait. In many cases, this will be the output of fine-mapping (Schaid, et. al. 2018[href=https://www.wicell.org#bib31]) or a file containing just the lead SNPs for each independent association. For downstream analysis, generate a table with these lead SNPs and their genome coordinates.\nIn order to programmatically access the LDLink data using the LDLinkR package in R, users must register on the LDLink website in order to receive an LDLink token. The token will be emailed to you.",
    "Using this table and the LDLinkR package, each lead variant is queried in the 1000 Genomes database and the variants in linkage disequilibrium, or proxy SNPs, for each lead SNP are downloaded (1000 Genomes Project Consortium et al., 2012[href=https://www.wicell.org#bib9]; Machiela and Chanock, 2015[href=https://www.wicell.org#bib23]). In using this resource, you need to be aware of the population used in the GWAS study you are analyzing. In many cases, the European (“EUR”) population is representative of the population used in the study, however, this is not always the case. Compare the available populations from 1000 Genomes against the GWAS study publication to find the appropriate option for the analysis. Using the LDproxy_batch function, all GWAS SNPs can be queried at once, and the proxy SNPs will all be written to a file on disk using the append = TRUE option.\n>LDproxy_batch(\n  snp = bmd_snps$SNP,\n  pop = “EUR”,\n  r2d = “r2”,\n  token = [insert_personal_token],\n  append = true)\nNext, this set of proxy SNPs is filtered to include only those with linkage disequilibirum R2 >= 0.7 with the lead variant. These are the regions of the genome that will determine which genes are implicated by the GWAS in cis.\n>ld_regions = proxies %>%\n  filter(r2 >= 0.7) %>%\n  separate(col = coord, sep = “:”,\n    into = c(“chr”, “coord”)) %>%\n  group_by(query_snp %>%\n  summarize(chr = max(chr),\n    min = as.numeric(min(coord),\n    max = as.numeric(max(coord)))\nThen, using the Genomic Ranges tool, identify all genes from the GRCh37/hg19 Ensembl gene set overlapping a GWAS bin (Lawrence et al., 2013[href=https://www.wicell.org#bib21]). Depending on the build of the genome used in the GWAS in the study, the correct gene annotation reference will need to be used. Download the reference file from the UCSC table browser (Haeussler et al., 2019[href=https://www.wicell.org#bib15]).\nCreate a GenomicRanges representation of both the GWAS regions and the reference gene set.",
    ">gr_genes = Granges(genes)\n>gr_gwas = Granges(ld07_gwas_regions)\nNext, identify the overlapping genes for each region using the findOverlaps function\n>overlaps = GenomicRanges::findOverlaps(gr_genes, gr_gwas)\n>overlaps_info = cbind(ld07_gwas_regions[overlaps@to,\n  genes[overlaps@from,]$name)\n>overlaps_info = overlaps_info[,c(1,4,5)]\n>overlaps_info$type = “overlaps”\n>overlaps_info = overlaps_info[!duplicated(overlaps_info,]\n>colnames(overlaps_info) = c(“chromosome”, “gwas_snps”,\n  “gene_name”, “type”)\nIf no gene intersected a given region, include the nearest upstream and downstream genes from the region. These are identified using the “precede” and “follow” functions from GenomicRanges. The results are converted into data frames and filtered to include only nearest upstream and downstream genes associated with variants that do not overlap a gene.\n>nearest_precede = GenomicRanges::precede(gr_gwas,gr_genes)\n>precede_info = cbind(ld07_gwas_regions,\n  genes[nearest_precede,])\n>precede_info = precede_info[,c(1,4,9)]\n>precede_info$type = “precede”\n>precede_info = precede_info[!duplicated(precede_info),]\n>colnames(precede_info) = c(“chromosome”, “gwas_snp”,\n  “gene_name, “type”)\n>precede_info = precede_info[which(precede_info$morris_snp %in% overlaps_info$gwas_snp),]\n>nearest_follow = GenomicRanges::follow(gr_gwas,gr_genes)\n>follow_info = cbind(ld07_gwas_regions,\n  genes[nearest_follow,])\n>follow_info = follow_info[,c(1,4,9)]\n>follow_info$type = “follow”\n>follow_info = follow_info[!duplicated(follow_info),]\n>colnames(follow_info) = c(“chromosome”, “gwas_snp”,\n  “gene_name, “type”)\n>follow_info = follow_info[which(follow_info$morris_snp %in% overlaps_info$gwas_snp),]\nCombining these three results, create a table where each row represents a gene overlapping a region implicated by a GWAS-associated variant, the lead variant in that region, the chromosome, and whether the gene overlaps the region or is an upstream/downstream gene.\n>gwas_region_genes = rbind(overlaps_info,\n  precede_info, follow_info)\nFinally, the list of human genes is converted to mouse homologs using the MGI mouse to human homology map (Bolser, 2004[href=https://www.wicell.org#bib3]) (http://www.informatics.jax.org/downloads/reports/HOM_MouseHumanSequence.rpt[href=http://www.informatics.jax.org/downloads/reports/HOM_MouseHumanSequence.rpt]).\n>gwas_gene_hom = homology %>%\n  filter(Symbol %in% gwas_region_genes$gene_name)\n>gwas_mouse_hom = homology %>%\n  filter(‘HomoloGene ID’ %in% gwas_gene_hom$’HomoloGene ID′) %>%\nfilter(‘NCBI Taxon ID’ == 10090)\nStep 2: Construct co-expression network\nTiming: 30 min to 1 h",
    "This step uses the WGCNA package to create a co-expression network (Figure 1[href=https://www.wicell.org#fig1]) by grouping genes that co-vary across samples into modules (Langfelder and Horvath, 2008[href=https://www.wicell.org#bib20]). This co-expression network serves as a basis for the enrichment analysis in the next set of steps. This section closely follows the WGCNA tutorials created by the authors of WGCNA, found here: https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/[href=https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/Tutorials/].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/955-Fig1.jpg\nFigure 1. Example co-expression network from murine osteoblasts and GO annotations for individual modules\nAs expected, some modules have generic functions, for example immune response and RNA processing, and others represent more specific functions, like osteoblast differentiation or Wnt signaling. Adapted from Figure 1 in (Sabik et al., 2020[href=https://www.wicell.org#bib30]).\nCheck the relationship among your samples using clustering to identify outliers.\n>sampleTree = hclust(dis(norm_exp_mat), method = “average”)\nClustering and plotting the resulting tree will allow visualization of the relationships among your samples.\nAs a result, you may want to remove samples that are dramatically different from the mean by cutting the tree using cutHeight; more details can be found in the WGCNA data processing tutorial.\nNext, the soft-thresholding power is empirically determined using the pickSoftThreshold function. Because it is assumed that the co-expression network will have a scale-free topology, the scale-free topology fit index is calculated across a range of powers, and the minimum power required to reach the point of diminishing returns is selected as the soft thresholding power. This power is applied to the adjacency matrix prior to the calculation of the Topological Overlap Matrix.\n>powers = c(c(1:10), seq(from = 12, to = 20, by = 2))\n>sft = pickSoftThreshold(norm_exp_mat,\n  powerVector = powers,\nverbose = 5, networkType = “signed”)\nNote: This step may take a few minutes to run.",
    "After determining the optimal soft-thresholding power, we can now calculate co-expression modules from the gene expression dataset. There are many parameters that can be tweaked in this function that can alter the resulting network. In this example, values close to the defaults, however the default values may not be optimal for your dataset. In this example, we used a minModuleSize of 20 genes and a mergeCutHeight of 0.15, in order to avoid having a large number of small modules. Additionally, a signed network was constructed, as Peter Langfelder recommends for biological network (Langfelder, 2018[href=https://www.wicell.org#bib19]). For more information about the parameters of the network calculation step, consult the WGCNA help files in the R environment.\n>net = blockwiseModules(norm_exp_mat, power = 8,\n  TOMType = “signed”, minModuleSize = 20,\n  networkType = “signed”, reassignThreshold = 0,\n  mergeCutHeight = 0.15, numericLabels = TRUE,\n  pamRespectsDendro = FALSE, saveTOMs = TRUE,\n  saveTOMFileBase = “,/network/norm_exp_mat_TOM”,\n  verbose = 3)\nNote: This step may take a while, from 15–20 min to run.\nWhile the network is constructed, the topological overlap matrices (TOMs) are saved, however, we also suggest saving the soft-thresholding results, the tree cutting results, the module labels, colors, and eigengenes so they can be easily reloaded later without re-running any of the above code.\n>moduleLabels = net$colors\n>moduleColors = labels2colors(net$colors)\n>MEs = net$MEs\n>geneTree = net$dendrogram[[1]];\n>save(sft, MEs, moduleLabels, moduleColors, geneTree,\n  File = “./network/network.RData\nPause point: This is a good stopping point, as you can always come back and reload the network.RData file to come right back to where you are right now. To reload the network, use this code:\n>load(“./data/network/network/RData”)",
    "Finally, network results are all labeled with the identifiers from the expression matrix, however, it would also be useful to have them labeled with alternative identifiers that map to other applications we intend to use, including gene ontology analysis software and enrichment analysis with our curated gene lists. A common identifier for both of these applications in our case is gene symbol, however, this code can be modified for other organisms and ontologies.\n>ensembl = useMart(“ensembl”)\n>mm19 = useDataset(mart = ensembl, dataset = “mmusculus_gene_ensembl”)\n>m = getBM(attributes = c(“ensemble_transcript_id”,\n“external_gene_name”, “description”, “chromosome_name”,\n“start_position”, “end_position”),\n  filters = c(“ensembl_transcript_id”),\n  values = colnames(norm_exp_mat),\n  mart = mm19)\n>gene_MEs = t(rbind(colnames(norm_exp_mat), moduleColors, moduleLabels))\n>colnames(gene_MEs)[1:3] = c(“ensemble_transcript_id”,\n“mod_color”, “mod_number”)\n>annotated_mods = merge(gene_MEs, m, by =\n“ensembl_transcript_id”)\nStep 3: Gene ontology analysis\nTiming: 30 min\nNext, perform gene ontology analysis for each module in the network to identify the functional categories represented by each module (Figure 1[href=https://www.wicell.org#fig1]). There are numerous tools for conducting gene ontology analysis; however, our tool of preference for this project was ToppFun within the ToppGene suite (Chen et al., 2009[href=https://www.wicell.org#bib8]). This web interface tool searches for enrichment across an extensive set of functional categories, including gene ontology and pathways, but also human and mouse phenotypes, publications and published co-expression data sets, gene families, microRNAs, drugs, and diseases. The background geneset used in ToppFun is the full set of genes present in the gene ontology categories that are being analyzed for enrichment.\nPause point: From this point on, each step break can be considered a good stopping point, just be sure to save your script.",
    "In order to port our modules into the web interface and for ease of browsing, write each module out into a .csv file. For example, this code chunk writes out the genes in module 1 to a file that can be uploaded to the web interface.\n>annotated_mods %>%\n  filter(mod_number == 1) %>%\n  write_csv(., “./data/network/mod_1.csv”)\nUsing the column of identifiers from this table, copy and paste into the ToppFun input box and begin the analysis. For each module of genes, ToppFun will report back a summary of all the enriched gene sets. Click the button at the top of the results page reading “Download All”, and save the results for browsing in R. ToppFun reports back the significance of each enrichment with an assortment of multiple testing correction methods, the number of hits for that category from your query (\"Hit Count in Query List\"), and the total number of genes in the category (\"Hit Count in Genome\"). ToppFun returns three different adjusted p-values: the Bonferroni, Benjamini & Hochberg, and Benjamini & Yekutieli adjusted values. We recommend using a threshold of Bonferroni corrected p-values less than 0.05 to identify significant enrichments. This is the most conservative approach, but given the large number of gene ontology categories, we have deemed the conservative approach appropriate.\nStep 4: Module enrichment\nTiming: 20 min\nNow that a list of genes implicated by GWAS has been produced, we can identify which co-expression modules are enriched for GWAS genes and for the genes previously identified as causal of related monogenic diseases and phenotypes in mice.\nFirst, we define the set of modules in our co-expression network for analysis.\n>colors = unique(moduleColors)",
    "Then, a loop is initiated that begins by defining an object containing annotated information for the genes in each module. Next, a fisher’s exact test is applied to measure the statistical significance of the representation of genes implicated by the GWAS study. In this section a = overlap of module and gene list, b = the size of the gene list minus the overlap, c = the size of the module minus the overlap, and d = the number of genes with quantified expression levels in the RNA-seq experiment.\n>d = as.data.frame(get(paste0(“mod)”,color,“_trx_info”))\n>x = unique(d$external_gene_name) %in% gwas_mouse_genes\n>x = sum(x=TRUE)\n>print(dim(d))\n>print(x)\n>a = x\n>b = (417 – a)\n>c = (dim(d)[1] – a)\n>e = (29255 – c – b – a)\n>assign(paste0(“ft_mod_”, color),\n  fisher.test(matrix(c(a,b,c,e), 2, 2, byrow = TRUE),\n    alternative = “greater”))\nFinally, a table is produced that condenses results for each test, reporting the p-value and the odds ratio, for each module. A p-value adjustment is applied using the Benjamini & Hochberg (FDR) method and the results are returned, sorted by adjusted p-value. We recommend a threshold of FDR < 0.05 to identify enriched modules.\n>gwas_enrichment_results =\n  as.data.frame(matrix(nrow = 59, ncol = 3))\n>colnames(gwas_enrichment_results) =\n  c(“module_color”, “p_value”, “odds_ratio”)\n>for (i in 1:length(colors)){\n  color = colors[i]\n  ft = get(paste0(“ft_mod_”, color))\n  gwas_enrichment_results[i,1] = color\n  gwas_enrichment_results[i,2] = ft$p.value\n  gwas_enrichment_results[i,3] = ft$estimate\n  }\n>gwas_enrichment_results$p.adj = p.adjust(gwas)enrichment_results$p_value, method = “fdr”, n = length(gwas_enrichment_results$p_value))\n>gwas_enrichment_results %>% arrange(p.adj)",
    "This process can be repeated for each module from the co-expression network and the results can be compared using a scatter plot of the results (Figures 2[href=https://www.wicell.org#fig2]A, 2C, and 2D), where the enrichment and significance are plotted and each point represents a module. In this case, one module is among the most highly/significantly enriched across all gene sets, which is characteristic of a “core” module. The module that scores highest across all gene sets is a good candidate for a “core” module.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/955-Fig2.jpg\nFigure 2. Identifying co-expression modules enriched for genes with “core”-like properties\nModule enrichment for (A) GWAS genes, (B) GWAS heritability, (C) genes associated with related phenotypes, and (D) genes associated with related monogenic diseases. Adapted from Figure 2 in (Sabik et al., 2020[href=https://www.wicell.org#bib30]).\nIn this step of the analysis, the user will need to set their specific\nIn order to better understand the biological functions that the enrich modules represent, refer back to the results of the gene ontology analysis conducted in section 3. Filter the results of the module you identified in this section to see which gene ontology terms are enriched in your module of interest.\nStep 5: LD score regression\nTiming: 1 h",
    "Another lens through which we can understand the relationship between the modules in the co-expression network and the GWAS results is through partitioned heritability analysis using LD score regression. This workflow is used to identify modules that are composed of genes related to variants that are enriched for trait heritability in the GWAS study. LD score regression is conducted using the ldsc package, which takes GWAS summary statistics, baseline linkage disequilibrium measurements, and gene sets in which to identify enrichment (Finucane et al., 2015[href=https://www.wicell.org#bib12]). The partitioned heritability of the SNPs in the regions surrounding the genes in each module is calculated to identify the modules that are most highly enriched for heritability for the trait of interest.\nNote: While this package is not wrapped for R, it is accessible in python using the command line, so the code chunks from this section cannot be run in R! The ldsc package wiki on github has a detailed tutorial for the following steps, including links for downloading required files.\nThe first step of LD score regression is to format the GWAS summary statistics for using in the ldsc algorithm, the merge alleles file is provided with the ldsc package\n>./munge_sumstats.py \\\n--out BMD \\\n--merge-alleles w_hm3.snplist \\\n--a1-inc \\\n--sumstats bmd_gwas_sumstats.txt\nNext, a set of SNPs associated with each module are identified via the genes in each module. This function requires a gene set for each module (as Ensembl gene IDs), a file indicating the coordinates of each Ensembl gene ID (ENSG_coord.txt, provided in the ldsc documentation), the plink file for each chromosome (1000G_plinkfiles/1000G.mac5eur., provided in the ldsc documentation), and a path for the annotation output, indicating the module and the chromosome number. This will need to be run for each chromosome across all modules.\n>python ../../src/ldsc/make_annot.py –gene-set-file\nviolet_module_human_gene_ids.Geneset – gene-coord-file",
    "ENSG_coord.txt –windowsize 100000 – bimfile\n  ./100G_plinkfiles/1000G.mac5eur.1.bim –annot-file\n  ./violet_annot/violet_module.1.annot.gz\nFinally, using all of these annotations, run ldsc using the (1) processed summary statistics, (2) the base annotation paths for the modules' annotations, (3) the SNP weights and (4) frequencies for the European 1000 Genomes data that are provided with the ldsc package. The overlap annotations flag was used because transcripts were used to generate the co-expression network, so the gene sets are non-disjoint. Finally, a base name for the output is provided. This command will output a log file, recording the command used to generate the output and a results file. The results file contains a table reporting the proportion of SNPs associated with the gene set, the proportion and standard error of heritability in those SNPs, the enrichment and standard error of the enrichment, and a p-value indicating the statistical significance of the enrichment (Table 1[href=https://www.wicell.org#tbl1]). This table can be filtered to identify the modules that are significantly enriched for trait heritability, and ordered by enrichment to identify the most enriched modules.\ntable:files/protocols_protocol_955_1.csv\n>python ldsc.py\n--h2 BMD.sumstats.gz\\\n--ref-ld-chr antiquewhite4_module., bisque4_module., black_module., blue_modules., ...etc.\\\n--w-ld-chr ./weights_hm3_no_hls/weights.\n--overlap-annot\\\n--frqfile-chr 1000G.mac5eur.\\\n--out BMD_all_modules_compare\nStep 6: Gene-level analysis prioritization\nTiming: 30 min\nOnce key modules enriched for genes exhibiting core-like properties are identified in sections four and five, the next step is to use these modules as a platform for identifying key genes influencing the phenotype of interest. In sections seven and eight, it may not be feasible to analyze every gene in an enriched module. The topological properties of the nodes within the module can be used to prioritize genes for colocalization and phenstat analysis. In this section, the WGCNA package is used to calculate the module membership score for each gene within a module of interest.",
    "Quantitatively, the module membership score is the correlation between the module’s eigengene, which describes the collective expression profile of the group of genes, and each individual gene’s expression pattern. Module membership is highly correlated with intramodular connectivity, and thus, intramodular hub genes tend to have high module membership.\n>MMvalue = as.data.frame(cor(norm_exp_by_strain,\n  MEs, use = “p”))\n>MMPvalue = as.data.frame(corPvaluStudent(\nas.matrix(geneModuleMembership), nSamples))\nOnce module membership is calculated for all transcripts, we can annotate all the genes in our modules of interest with their module membership scores, sort the list to identify those genes with the highest module membership scores, and carry those into steps seven and eight.\n>module_color = “purple”\n>cols = c(paste0(“MM.”, module_color), paste0(“MM.p”, module_color), “MMValue”, “MMPvalue”, “Transcript.ID”)\n>mod_MMtable = dplyr::select(MMvalue, one_of(cols)) %>%\n  merge(., dplyr::select(MMPvalue, one_of(cols))\n>mod_mm_df = merge(mod_MMtable,\n  get(paste0(“mod)”, module_color, “_trx_info”)),\n  by.x = “Transcript.ID”, by.y = “ensembl_transcript_id”)\n>mod_mm_df %>% arrange(desc(MM.purple))\nStep 7: Colocalization analysis\nTiming: 1 h 30 min",
    "Colocalization analysis is conducted to provide support for hypotheses linking individual genes from core modules with the GWAS phenotype. Colocalization analysis is conducted to evaluate whether two loci share a causal variant. In this instance, the coloc package is implemented to identify relationships between trait-associated GWAS loci and cis expression quantitative trait loci (eQTLs) from Gene-Tissue Expression project (GTEx), however, any relevant eQTL dataset could be used in this step (Giambartolomei et al., 2014[href=https://www.wicell.org#bib13], GTEx Consortium et al., 2017[href=https://www.wicell.org#bib14]). The coloc package evaluates five different hypotheses regarding the relationship between the two associations and returns the probability of each as a value between zero and one: the H0 hypothesis, that neither association is significant, the H1/H2 hypotheses, that only one of the associations is significant, the H3 hypothesis, that both associations are significant but do not share a causal variant, and the H4 hypothesis, that the two associations are significant and share a causal variant. We are interested in identifying the pairs of eQTL and GWAS associations that have a high value of H4 (Table 2[href=https://www.wicell.org#tbl2]).\ntable:files/protocols_protocol_955_2.csv\nNote: If no single module is identified as a potential core module in steps 4 and 5, the results may need to be aggregated to create a ranking, see troubleshooting[href=https://www.wicell.org#troubleshooting], Problem 1.\nFirst, for the colocalization analysis, eQTL information from the GTEx consortium will need to be downloaded and filtered (GTEx Consortium et al., 2017[href=https://www.wicell.org#bib14]). The data are available for download at https://gtexportal.org/home/datasets[href=https://gtexportal.org/home/datasets].\nNote: The tarball required for this analysis is 188 Gb in size. It would not be advisable to operate on this data on a laptop, though it may be possible. It is recommended that this file is downloaded directly to a remote server using the command line.\n>wget\nhttps://storage.googleapis.com/gtex_analysis_x7/single_tissue_eqtl_data/GTEx_Analysis_v7_eQTL_all_associations.tar.gz[href=https://storage.googleapis.com/gtex_analysis_x7/single_tissue_eqtl_data/GTEx_Analysis_v7_eQTL_all_associations.tar.gz]",
    "Note: It is possible to use eQTL from any source, however, the below code is designed to work with GTEx data and may need to be modified to work with other eQTL sources.\nOnce the full eQTL data are acquired, the associations for each gene will need to be extracted from each tissue file. This can be accomplished using awk on the command line. These files can all be saved to a subdirectory of the downloaded github repo directory and read in as a part of the loop.\n>awk -F “\\t” ‘$1 ∼ /ENSG###\\ {print}’ .txt | awk -F “\\t”\n  ‘{ if (($3 >= lower_coord_limit) &&\n  ($3 <= upper_coord_limit)) { print } }’ >\n  tissue_gene_eqtl_output_file.txt\n>gene_files = list.files(“./data/eqtl_data/b4galnt3_snps/”)\nFurthermore, there are a few additional pieces of information required for input to coloc that have not been used in previous steps of this analysis. The sample size for each underlying GWAS or eQTL study, and the minor allele frequency (MAF) of the variants in each study are required. For the GTEx v7 eQTL studies, a key is provided with the sample sizes for each of these studies. The sample size for the GWAS study should be included in the summary statistics or associated manuscript. Additionally, the MAFs are included as part of the GTEx eQTL association table, and the frequencies of the alleles in the GWAS study are typically reported, however, the MAF is not always the reported frequency, so you may need to convert these frequencies if any are above 0.5. If MAFs are not reported, they can be sourced from the 1000 Genomes project using the LDLink tools.\n>gwas_coloc$MAF = ifelse(gwas_coloc$A1FREQ > 0.5,\n  (1 – gwas_colos$A1FREQ), (gwas_coloc$A1FREQ))\n>tis = read_tsv(“./data/eqtl_data/tissue_key.txt”)",
    "With all of this data read in, a loop can now be run that reads in and formats eQTL and GWAS data and runs coloc for each file in the eQTL data folder. The results of the five hypothesis test for each eQTL/GWAS association pait are saved in a dataframe.\nFirst, an empty dataframe is initiated\n>gene_coloc_results = data.frame(matrix(NA, nrow = length(tis$Tissue), ncol = 8))\nNext, we initiate a loop that iterates over each eQTL file, reads it in, and formats it with appropriate variant IDs.\n>for (i in 1:length(gene_files)){\n  print(i)\n  x = gene_files[i]\n  y = nchar(gene_files[i]) -23\n  tissue = str_sub(x, 1, y)\n  z = read_tsv(paste0(“./data/eqtl_data/b4galnt3_snps/”,\n    x). col_names = FALSE)\ncols = c(“X2”, “X3”, “X4”, “X5”, “X6”)\nz$variant_id = docall(paste, c(z[cols], sep = “_”))\nz = z[,c(1,14,7,8,9,10,11,12,13)]\ncolanmes(z) = c(“gene_id”, “variant_id”,\n  “tss_distance”, “ma_samples”, “ma_count”, “maf”,\n  “pval_nominal”, “slope”, “slope_se”)\ngene_snp_ids = GTExIdConvert(z$variant_id)\nz = merge(z, gene_snp_ids, by = “variant_id”)\ntissue_n = as.numeric(tis[which(tis$Tissue ==\n    tissue),2])\n...\nFinally, the coloc objects for the GWAS and the eQTL are formatted, coloc is run, and the results are written out into a dataframe.\n...\ngene.coloc = list(pvalues=as.numeric(z$pval_nominal),\n  N=as.numeric(tissue_n), type=‘quant’,\n  snp=as.character(z$rs_id),\n  MAF=as.numeric(z$maf))\ngwas.coloc = list(pvalues=as.numeric(gwas_coloc$P),\n  N=142487 type=‘quant’,\n  snp=as.character(gwas_coloc$SNP),\n  MAF=as.numeric(gwas_coloc$MAF))\ncoloc_x = coloc.abf(gene.coloc, gwas.coloc)\ngene_coloc_results[i,] =\n  c(tissue,z$gene_id[1],\n  coloc_x$summary[1],\n  coloc_x$summary[2],\n  coloc_x$summary[3],\n  coloc_x$summary[4],\n  coloc_x$summary[5],\n  coloc_x$summary[6])\n}\nThe resulting table will report the tissue (“tissue”), the gene ID (“gene”), number of SNPs included in the coloc analysis (“nsnps”), and the posterior probability of the four hypotheses assessed by coloc (“PP.H0.abf” = no significant association, “PP.H1.abf” = only the eQTL association was significant, “PP.H2.abf” = only the GWAS association was significant, “PP.H3.abf” = the associations are both significant and likely have independent genetic drivers, “PP.H4.abf” = the associations are both significant and likely share a common genetic driver).",
    "Optional: These results can also be visualized with the RACER package (Sabik and Farber, 2018[href=https://www.wicell.org#bib29])(Figures 3[href=https://www.wicell.org#fig3]A–3D). A detailed vignette for using the RACER package can be found here: https://oliviasabik.github.io/RACERweb/articles/IntroToRACER.html[href=https://oliviasabik.github.io/RACERweb/articles/IntroToRACER.html].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/955-Fig3.jpg\nFigure 3. Identifying core genes from a core module\n(A–D) represent the results of positive colocalization analyses, where there was a sufficiently high PP H4 to indicate that the BMD GWAS signal and the GTEx eQTL for the given gene shared a common genetic driver.\n(E–H) represent significant differences in a phenotype (bone mineral density) in knockout mice from the IMPC database, as analyzed by PhenStat.\nAdapted from Figure 5 in (Sabik et al., 2020[href=https://www.wicell.org#bib30]).\nStep 8: PhenStat analysis\nTiming: 1–2 hrs\nWhile the colocalization analysis provides evidence supporting a relationship between network identified genes and a trait of interest, a causal relationship can only be demonstrated through controlled perturbation of a target and direct measurement of the phenotype of interest. The hypotheses generated by the above steps can lead to a novel set of experiments, however, databases of experimental perturbations and measured phenotypes can be mined for evidence supporting a causal relationship between a gene and a phenotype of interest. For example, the International Mouse Phenotyping Consortium has a database of phenotypes measured in 7022 strains of knockout mice as of release 12.0 (Koscielny et al., 2014[href=https://www.wicell.org#bib17]).\nIdentify genes from your core module, perhaps those with eQTL that colocalize with the GWAS of interest that are represented in the IMPC database.\nFrom their home page (https://www.mousephenotype.org/[href=https://www.mousephenotype.org/]), search by gene name for potential causal genes.\nNavigate to a gene of interest to see what phenotypes are available, for example the page for the gene B4galnt3. (https://www.mousephenotype.org/data/genes/MGI:3041155[href=https://www.mousephenotype.org/data/genes/MGI:3041155]).",
    "IMPC reports which genotype/phenotype relationships are significant above a multiple testing threshold for all genes; however, they make all data available for testing a single hypothesis.\nThe data may be downloaded by clicking on a relevant phenotype icon (https://www.mousephenotype.org/data/charts?accession=MGI:3041155&allele_accession_id=MGI:4434237&pipeline_stable_id=ESLIM_001&procedure_stable_id=ESLIM_005_001&parameter_stable_id=ESLIM_005_001_004&zygosity=homozygote&phenotyping_center=ICS), scrolling to the “Access the results programmatically” section and clicking to download the “PhenStat-ready raw experiment data”.\nThis data can be loaded in R and the analysis can be run using the PhenStat package (Kurbatova et al., 2015[href=https://www.wicell.org#bib18]). First, the data are read in:\n>url = ‘htps://www.mousephenotype.org/data/exportraw? phenotyping_center=JAX&parameter_stable_id=IMPC_DXA_004_001&allele_accession_id=MGI:5804021&strain=MGI:3056279&pipeline_stable_id=JAX_001&&zygosity=homozygote&’\n>dataset1 = data.table::fread(url)\n>dataset1 = as.data.frame(dataset1)\n>dataset1 = dataset1[,c(15,16,21,26,28)]\nNext, a PhenList object is created for Phenstat\n>test = PhenList(dataset1,\n  testGenotype=”JR29804”,\n  dataset.colname.batch = “Assay.Date”,\n  dataset.value.male = “male”,\n  dataset.value.female = “female”,\n  dataset.clean = TRUE,\n  outputMessages = TRUE)\nNext, use the testDataset function to test for differences in a dependent variable, here \"Value\". The program will choose whether to keep specific model effects, and report if it corrects for batch, weight, and sex, or an interaction term. Additionally, it does not detect a difference in variance between the genotype groups.\n>results_MM_bmd = testDataset(test, depVariable = “Value”)\nUse the summaryOutput function to view the results of the statistical test for comparing the knockout phenotype against the control.\n>summaryOutput(results_MM_bmd)\nFinally, create a boxplot of the differences in the value between genotypes for both sexes using the boxplotSexGenotype function, or the boxplotSexGenotypeBatchAdjusted if the effect of batch was significant.\n>boxplotSexGenotype(test,\n  depVariable = “Value”,\n  graphingName = ‘Bone Mineral Density”,\n  outputMessages = T)\n>PhenStat::boxplotSexGenotypeCatchAdjusted(test,\n  depVariable = “Value”)\nThe adjusted variables can also be extracted, using the getColumnWeightBatchAdjusted function, and plotted using a different package, for example, ggplot2 (Figures 3[href=https://www.wicell.org#fig3]E–3H)."
  ],
  "subjectAreas": [
    "Genomics",
    "Rnaseq",
    "Bioinformatics",
    "Systems Biology",
    "Genetics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}