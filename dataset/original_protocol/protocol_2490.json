{
  "id": 2628,
  "origin_website": "Cell",
  "title": "Nondestructive microbial discrimination using single-cell Raman spectra and random forest machine learning algorithm",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nSet up your confocal Raman microscope\nTiming: 1–2 h\nThis section describes the setting of the confocal Raman microscope you use prior to measurements of single microbial cells. We used a laboratory-built confocal Raman microscope with the 632.8 nm light from a He–Ne laser as the Raman excitation source (Figure 1[href=https://www.wicell.org#fig1]) (Huang et al., 2011[href=https://www.wicell.org#bib6], 2012[href=https://www.wicell.org#bib5]; Matsuda et al., 2019[href=https://www.wicell.org#bib11]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig1.jpg\nFigure 1. Schematic diagram of the laboratory-built Raman microscope that we used\nAlternatives: A commercial Raman microscope available from Renishaw, HORIBA, Bruker, WITec, etc. can be used as well. We recommend an inverted microscope because it facilitates bright-field observation of cell suspension dropped in a glass bottom dish.\nNote: The same protocol can be applied for 532 nm excitation. Modifications may, however, be required in data preprocessing (see step 11 below), because 532 nm excitation often causes stronger cellular autofluorescence than 632.8 nm excitation.\nCritical: The following parameters or components of the confocal Raman microscope (Figure 1[href=https://www.wicell.org#fig1]) are of particular importance because they substantially affect measured Raman spectra: laser wavelength; an objective lens; a pinhole for confocal detection; and a grating of the spectrometer.\nLaser wavelength\nThe choice of the laser wavelength concerns with the resonance Raman effect and laser-induced damage of the cell. 532 nm excitation is most commonly used, but in this protocol, we adopted 632.8 nm excitation, which falls near the optical window of biology.\nObjective lens",
    "A phase-contrast objective is generally used to observe prokaryotic cells. We chose an oil-immersion phase-contrast objective (Nikon, 100×, NA 1.3, CFI Plan Fluor DLL). According to the Rayleigh criterion, the lateral (XY) resolution is given by 0.61λ/NA, where λ is the wavelength of light and NA is the numerical aperture of the objective. Using this relation, the lateral resolution of our Raman microscope is calculated to be 0.3 μm, while experimentally it is estimated to be ∼0.45 μm.\nConfocal pinhole\nA 100-μm pinhole is used to get rid of out-of-focus light; the resulting depth (Z) resolution is estimated to be ∼4.5 μm.\nGrating\nThe use of a 600 grooves/mm grating enables us to record the entire spectral window (approximately 660–3,020 cm−1) covering both fingerprint and CH-stretching regions with a spectral resolution of ∼5 cm−1.\nWait typically more than 30 min until the laser output and the temperature of the CCD detector (set to −70°C) are stabilized. Re-align the optical path if necessary.\nSet the laser power at the sample point to a desired value (3 mW in the present case) by adjusting a variable neutral-density (ND) filter.\nNote: The desired value of the laser power depends on purposes. If you do not care about the viability of the measured cell, you could use a higher power (e.g., ∼10 mW (Ho et al., 2019[href=https://www.wicell.org#bib3])) and improve the signal-to-noise ratio (S/N) of the spectrum.\nSet the center wavenumber of the grating in order to determine the wavenumber region to be measured.",
    "Note: The calibrated wavenumber region varies slightly from day to day, resulting in a shift in the horizontal axis of the measured spectra. This shift can be corrected for by using emission lines of a standard neon lamp (model: 6032, Newport) recorded on different days. To make the wavenumber regions as close as possible among different measurements, adjust them so that the peak position of a selected Raman band of the reference material comes at roughly the same CCD pixel.\nNote: In principle, do not change the grating setting during the experiment.\nSingle-cell Raman measurements\nTiming: 1.5 h for 40 cells/species\nThis section outlines steps to acquire Raman spectra of single cells of a microbial species.\nPrepare a cell-suspension sample (Figure 2[href=https://www.wicell.org#fig2]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig2.jpg\nFigure 2. Setting a microbial sample for Raman measurements\n(A) Photographs of a glass bottom dish containing a cell-suspension sample.\n(B) Phase-contrast optical micrographs of typical samples with adequate cell density (left) and too high cell density (right).\nHarvest 200 μL culture of each strain in a 1.5 mL microtube and wash it three times with 200 μL of PBS by centrifugation (e.g., 8,000–10,000 × g, 30–60 s) at room temperature.\nResuspend the pellet in 200 μL of PBS.\nEither dilute or concentrate the cell suspension for better microscopic observation of individual cells (Figure 2[href=https://www.wicell.org#fig2]B, left).",
    "Critical: When the cell density is too high (e.g., 5 × 107 cells/mL), multiple cells may be laser-trapped simultaneously (see Methods video S1[href=https://www.wicell.org#mmc1]). Adjust the cell density so that there are not too many (Figure 2[href=https://www.wicell.org#fig2]B, right) or too few cells in the field of view. For example, for E. coli cultured for 14–16 h (about 5 × 109 cells/mL) in LB medium, add a 0.5 μL aliquot to 200 μL of PBS, resulting in a cell density of ∼1.3 × 107 cells/mL.\n    Your browser does not support HTML5 video.\n  \nMethods video S1. Multiple-cell trapping, related to step 4\nTransfer 200 μL of the cell suspension to a glass bottom dish (hole diameter, 14 mm).\nRandomly select a single prokaryotic cell, capture it via the laser trapping technique (see Figure 3[href=https://www.wicell.org#fig3]A-i; troubleshooting 1) (Xie et al., 2002[href=https://www.wicell.org#bib16]), and record its Raman spectrum (see Methods video S2[href=https://www.wicell.org#mmc2]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig3.jpg\nFigure 3. Measurement of single-cell Raman spectra using laser trapping\n(A) Trapping a microbial cell in PBS away from (i) and very close to (ii) the cover glass.\n(B) Raman spectra of the cover glass (red) and PBS (blue). 10 spectra were averaged and subjected to noise reduction using singular value decomposition (SVD) (Huang et al., 2011[href=https://www.wicell.org#bib6]; van Manen et al., 2004[href=https://www.wicell.org#bib15]; Yasuda et al., 2019[href=https://www.wicell.org#bib18]).\n(C) Typical Raman spectra of single E. coli cells measured under the trapping situations i (upper trace) and ii (lower trace) depicted in (A). In both cases, 15 spectra were averaged and subjected to SVD denoising as in (B). Note that the raw data are much noisier. A glass signal at ∼915 cm−1 is observed only for situation ii.",
    "Note: We used laser power of 3 mW at the sample point and an exposure time of 30 s per cell. The total timing depends on the exposure time and how many cells you measure for each species. Troubleshooting 2.\nNote: Make sure that the measured spectrum is free from the glass signal (Figure 3[href=https://www.wicell.org#fig3]B, red). When a cell very close to the cover glass (see Figure 3[href=https://www.wicell.org#fig3]A-ii) is trapped and measured, the resulting Raman spectrum (Figure 3[href=https://www.wicell.org#fig3]C, lower trace) shows a Raman band of glass at ∼915 cm−1, which is absent in the one measured at the proper height from the cover glass (Figure 3[href=https://www.wicell.org#fig3]C, upper trace).\nRecord the PBS spectrum (Figure 3[href=https://www.wicell.org#fig3]B, blue) 10 times for averaging purposes.\n    Your browser does not support HTML5 video.\n  \nMethods video S2. Single-cell trapping, related to step 5\nData preprocessing\nTiming: 1 h\nThis section describes how to preprocess the recorded Raman spectra prior to training and testing in machine learning. The overall workflow is illustrated in Figure 4[href=https://www.wicell.org#fig4], which is adapted with permission from (Kanno et al., 2021[href=https://www.wicell.org#bib7]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig4.jpg\nFigure 4. Workflow of the data preprocessing\n(A) Subtraction of PBS spectrum (average of 10 spectra) from a cellular Raman spectrum.\n(B) Correction of a shift along the horizontal axis of the spectrum acquired on different days.\n(C) Separation of the spectrum by deleting the so-called silent region.\n(D) Baseline (linear function) subtraction. The upper and lower panels display the fingerprint and CH-stretching regions, respectively. The red and blue solid lines represent Raman spectral fragments of different microbial species as examples, and the red and blue dashed lines represent the corresponding baselines.\n(E) Vector normalization.\n(F) Combining the vector-normalized fingerprint and CH-stretching regions.",
    "Alternatives: This protocol uses Igor Pro 9.0.0.10 (WaveMetrics) to perform all of the following data preprocessing, but other data analysis software such as Origin (https://www.originlab.com/[href=https://www.originlab.com/]) can also be used.\nRemove spiky artifact caused by cosmic ray, if any.\nSubtract the PBS spectrum (average of 10 spectra) from each spike-free, single-cell Raman spectrum (Figure 4[href=https://www.wicell.org#fig4]A).\nUse emission lines of a standard neon lamp to correct for a daily shift of the horizontal axis (Figure 4[href=https://www.wicell.org#fig4]B).\nFor each measurement day, fit a particular emission line to the Lorentzian function and determine the wavenumber of its peak (Figure 5[href=https://www.wicell.org#fig5]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig5.jpg\nFigure 5. Determining the peak wavenumber of a neon emission line using curve fitting in Igor\n(A) Locate cursors (shown/hidden by using the shortcut key ‘Ctrl–I’) on the neon emission spectrum displayed as a Graph in order to define the region to be fitted. Then select ‘Curve Fitting’ from the ‘Analysis’ tab.\n(B) In the ‘Function and Data’ tab of the ‘Curve Fitting’ window, select the fitting function (Lorentzian function ‘lor’ in the present case) from the drop-down list.\n(C) In the ‘Data Options’ tab of the ‘Curve Fitting’ window, click ‘Cursors’ to define the start and end points of the fit. Subsequently, click ‘Do It’.\n(D) Fitted results shown in the Graph (left, red line) and in the command line (right). The peak wavenumber is given as ‘x0’ in the command line.\nDelete (typically a few) data points at both ends of each spectrum so that the peak wavenumbers of the above neon emission line match that of a reference spectrum within ±0.5 pixel that is pre-determined from all of the data from different days.\nDelete the so-called silent region (approximately 1,800–2,775 cm−1) and retain the fingerprint (660–1,800 cm−1) and CH-stretching (2,775–3,020 cm−1) regions (Figure 4[href=https://www.wicell.org#fig4]C).",
    "Note: No essential Raman bands appear in the silent region with few exceptions (e.g., C≡C and C≡N stretching bands (Yamakoshi et al., 2011[href=https://www.wicell.org#bib17]; Zhao et al., 2017[href=https://www.wicell.org#bib19]) and overtone and combination bands (Horiue et al., 2020[href=https://www.wicell.org#bib4])).\nPerform baseline subtraction for the fingerprint and CH-stretching regions separately (Figure 4[href=https://www.wicell.org#fig4]D).\nInstall the Baseline Fitting package in Igor (see https://www.wavemetrics.com/project/Baselines[href=https://www.wavemetrics.com/project/Baselines] for details).\nSelect ‘line’ from the drop-down list as the baseline function (Figure 6[href=https://www.wicell.org#fig6]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig6.jpg\nFigure 6. Baseline subtraction using the Baseline Fitting package in Igor\n(A) Select the baseline type (a linear function ‘line’ in the present case) and the region to be fitted. Then click ‘Subtract’ for a selected spectrum and ‘All in One’ for all spectra displayed on the Graph.\n(B) Comparison of the original Raman spectra (left panel) and corresponding baseline-subtracted spectra (right panel).\nCritical: What function is used to fit the baseline could significantly affect the performance of machine learning. Other functions than a linear function are available in this package. However, using a more complex function such as higher-order polynomials may often lead to overfitting. To avoid overfitting, linear approximation is a simple and effective means, although it may not be the best.\nDrag on the graph and then click the ‘+/-’ button to select/deselect the region(s) to be fitted. A linear fit will immediately be shown as a blue line (Figure 6[href=https://www.wicell.org#fig6]A).\nNote: Fit only the higher and lower wavenumber edges of each region, as indicated by grey parts in Figure 4[href=https://www.wicell.org#fig4]D and light-blue parts in the Graph in Figure 6[href=https://www.wicell.org#fig6]A.\nClick ‘Subtract’ for a selected spectrum and ‘All in One’ for all spectra displayed on the Graph, yielding baseline-subtracted Raman spectra (Figure 6[href=https://www.wicell.org#fig6]B).",
    "Perform vector normalization on each region (Figure 4[href=https://www.wicell.org#fig4]E), by dividing the intensity at each pixel by the square root of the sum of the squared intensities of the spectrum. Troubleshooting 3.\nCombine the normalized spectra in the fingerprint and CH-stretching regions to obtain a preprocessed single-cell Raman spectrum (Figure 4[href=https://www.wicell.org#fig4]F).\nTuning hyper-parameters for random forest model construction\nTiming: 1 h\nThis section details the procedures for optimizing the parameters needed for constructing RF machine learning models using the preprocessed data (40 spectra per species) in Python (Figure 7[href=https://www.wicell.org#fig7]A). First, a data file to be imported into Python is created. Subsequently, an optimal set of parameters is sought for by using grid search in Python, with a script in the Jupyter Notebook format, which is available on Zenodo (see key resources table[href=https://www.wicell.org#key-resources-table]). We used Jupyter Notebook in JupyterLab, a web-based interactive development environment.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig7.jpg\nFigure 7. Tuning hyper-parameters for random forest model construction\n(A) Workflow of the tuning of hyper-parameters and evaluation of the constructed random forest discrimination model. The dataset is divided into 10 folds with 9 being training sets and 1 being a test set. Grid search is performed on each of 9 training sets to determine the optimal values of ‘n_estimators’ and ‘max_features’.\n(B) Random forest hyper-parameters tuned in this protocol.\n(C) Out-of-bag (OOB) error rates as a function of the value of ‘n_estimators’, obtained with different ‘max_features’.\nPrepare a data file containing preprocessed single-cell Raman spectra in text format using Microsoft Excel or other software. An example is shown in Figure 8[href=https://www.wicell.org#fig8]. The columns ‘waves’ and ‘species’ specify the names of spectra and class labels (i.e., microbial species), respectively.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig8.jpg\nFigure 8. Example of a text file of single-cell Raman spectra of microbial species, to be imported into Python",
    "Column A headed with ‘waves’ shows the name of each spectrum, and Column B headed with ‘species’ the name of each microbial species. The values in Row 1 represent Raman shift values, and those shown below Row 2 are Raman intensities at each Raman shift for different cells.\nImport RandomForestClassifier and GridSearchCV from the scikit-learn package into Python (refer to the Jupyter notebook ‘GridSearch_10models.ipynb’).\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import GridSearchCV\nimport pandas as pd\nimport numpy as np\nImport the text data file into Python.\nExecute the following command. Type the file name in ‘ ’ with the file extension.\ndf = pd.read_table('dataset.txt')\nDivide the dataset into ‘species’ (i.e., class label) columns and the others.\ndata_x = df.drop(['species'], axis=1) # others\ndata_y = df['species'] # class labels\nTo perform N-fold cross-validation, split the dataset into N folds.\nfrom sklearn.model_selection import StratifiedKFold\nkfold = StratifiedKFold(n_splits = 10, random_state=123, shuffle=True)\nranges = range(1,11)\nfor i, (train_idx, test_idx) in zip(ranges,(kfold.split(data_x, data_y))):\n  X_train = data_x.iloc[train_idx, :]\n  X_test = data_x.iloc[test_idx, :]\n  y_train = data_y.iloc[train_idx]\n  y_test = data_y.iloc[test_idx]\n  train_concat = pd.concat([y_train, X_train],axis=1)\n  test_concat = pd.concat([y_test, X_test],axis=1)\n  train_concat.to_csv(\"train_\"+\"%02.f\"%(i)+\".csv\", index=False)\n  test_concat.to_csv(\"test_\"+\"%02.f\"%(i)+\".csv\", index=False)\nNote: N differs depending on the size of the dataset. In the case of 10-fold cross validation (N = 10), which we employed, the dataset is split into 10 folds, and 10 patterns of training (9 folds) and test (1 fold) sets are generated and exported as CSV files. You will find the resulting files as ‘train_01.csv’, ‘test_01.csv’, …, ‘train_10.csv’, and ‘test_10.csv’ in the working directory. The same number indicates a train/test set.\nExecute grid search for hyper-parameter optimization with M-fold (e.g., M = 5) cross-validation on each training set.",
    "Note: The hyper-parameters, n_estimators and max_features (Figure 7[href=https://www.wicell.org#fig7]B), that are frequently adopted in the N models are used to search for the optimal parameters that achieve high classification accuracy in the test datasets.\nSelect a model used for grid search.\nclf_cv = RandomForestClassifier()\nSet parameters for the search (see the example script below). The combinations of the numbers given in [ ] of 'n_estimators' and 'max_features' are attempted.\nsearch_params = {\n'n_estimators' : [10, 100, 200, 300, 500, 700, 1000, 1500],\n'max_features' : [\"sqrt\", 20, 30, 40, 50, 60, 70],\n'random_state' : [123],\n}\nNote: If you set too many parameters to search, it will take an enormous amount of time. We recommend that you first attempt a broad search, then narrow it down to the finest details, and search again.\nDefine grid search setting.\ngs = GridSearchCV(clf_cv,  # model\n    search_params,    # search parameters\n    cv=5,          # cross validation\n    verbose=True,    # display log\n    n_jobs=-1)  # Number of parallel processing CPU cores.\n              # -1: using all processors\nExecute grid search for each dataset.\nranges = range(1,11)\nfor i in ranges:\n  train = pd.read_csv(\"train_\"+\"%02.f\"%(i)+\".csv\")\n  train_x = train.drop(['species', 'waves'], axis=1)\n  train_y = train['species']\n  gs.fit(train_x, train_y)\n  print(gs.best_estimator_)\nDisplay grid search results for 10 sets as shown in Figure 9[href=https://www.wicell.org#fig9].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig9.jpg\nFigure 9. Grid search result\nThis example output shows a result for one train/test set, and similar results can be obtained for other 9 sets. Search results for ‘max_features’ and ‘n_estimators’ are highlighted with red boxes.\nCheck ‘n_estimators’ and ‘max_features’ in the result of each set and adopt the most frequently employed parameters.",
    "Note: ‘n_estimators’ specifies the number of decision trees, while ‘max_features’ is one of the parameters that restrict the shape of the decision trees and sets an upper limit of the number of features used for node splitting in each decision tree (Figure 7[href=https://www.wicell.org#fig7]B).\nNote: In steps 17 and 18b, a random number needs to be specified (‘random_state’). This ensures that the same result will be obtained whenever the same training samples and parameters are used.\nOptional: In addition to ‘max_features’, there are other parameters, such as ‘max_depth’, ‘min_samples_split’, and ‘min_samples_leaf’ in the scikit-learn library, that restrict the shape of the tree for reducing overfitting.\nOptional: For simplicity, dimensionality reduction (Guo et al., 2021[href=https://www.wicell.org#bib2]) is not employed in this protocol, which may be useful in some cases for reducing the number of features used for training.\nEvaluation of random forest discrimination model\nTiming: 1 h\nUsing the optimized hyper-parameters, construct a RF model for each combination of training and test sets and evaluate the constructed model using the test set (Figure 7[href=https://www.wicell.org#fig7]A). For details, refer to ‘RF_10models.ipynb’.\nSet the hyper-parameters derived from the above grid search.\nclf = RandomForestClassifier(max_features='sqrt', n_estimators=200, random_state=123)\nConstruct a RF model for each training data and evaluate it against the test data.\nFor each train/test set, output the feature importance and class probability in the CSV format and the confusion matrix, and calculate the accuracy score.\nCalculate the score of feature importance as the total reduction of the criterion brought by that feature (Gini importance) in each validation. Troubleshooting 4.\nranges = range(1,11)\nscore_all=['']∗11\nfor i in ranges:\n  train = pd.read_csv(\"train_\"+\"%02.f\"%(i)+\".csv\")\n  train_x = train.drop(['species','waves'], axis=1)\n  train_y = train['species']\n  test = pd.read_csv(\"test_\"+\"%02.f\"%(i)+\".csv\")\n  test_x = test.drop(['species','waves'], axis=1)\n  test_y = test['species']\n  test_w = test['waves']\n  clf.fit(train_x, train_y)\n  # feature importances export\n  FN =list(train_x.columns)\n  IF = list(zip(clf.feature_importances_,FN))\n  impFeat = pd.DataFrame(IF,columns=[\"Importance\",\"Feature_Name\"])\n  impFeat.to_csv(\"IF_\"+\"%02.f\"%(i)+\".csv\")",
    "# for confusion matrix, make array\n  y_pred = clf.predict(test_x)\n  conf_mat = confusion_matrix(test_y, y_pred,\n  labels=['Escherichia', 'Bacillus', 'Thermus', 'Thermococcus', 'Sulfolobus', 'Nitrososphaera'])\n  # Sorting Classes. Sort in the specified order.\n  np.save(\"model_array_\"+\"%02.f\"%(i), conf_mat)\n  # class probability export\n  classproba = pd.DataFrame(clf.predict_proba(test_x), columns=clf.classes_)\n  classproba = pd.concat([test_w, test_y, classproba],axis=1)\n  classproba.to_csv(\"predict_proba_\"+\"%02.f\"%(i)+\".csv\")\n  # for score\n  score_all[i] = clf.score(test_x, test_y)\nNote: An average of the scores over N validations (N = 10 in the present case) is used to represent each feature importance. The means of the feature importance (Figure 10[href=https://www.wicell.org#fig10]A) and class probability (Figure 10[href=https://www.wicell.org#fig10]B) are obtained from the exported data using Microsoft Excel or similar spreadsheet software.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig10.jpg\nFigure 10. Calculation of mean feature importance and class probability for one train/test set\n(A) The importance for each feature (i.e., Raman shift) obtained from one of 10 validation results.\n(B) Workflow of calculation of the mean class probability for each true class (i.e., microbial species). Similar calculation is done for other 9 sets.\nDisplay the accuracy for each train/test set.\nscore_all.pop(0)\nprint(score_all)\nDisplay the mean accuracy and standard deviation of 10 models. Troubleshooting 5.\nprint(np.mean(score_all))\nprint(np.std(score_all))\nGenerate a confusion matrix to visualize the performance of the classification model, in which the sum (or average) of the N patterns of results is displayed in a table layout (Figure 11[href=https://www.wicell.org#fig11]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2124-Fig11.jpg\nFigure 11. Confusion matrix with ‘normalize=False’, for displaying classification results\nImport all of the 10 arrays obtained from the above classification.\nmodel_array_01 = np.load('model_array_01.npy')\nmodel_array_02 = np.load('model_array_02.npy')\nmodel_array_03 = np.load('model_array_03.npy')\nmodel_array_04 = np.load('model_array_04.npy')\nmodel_array_05 = np.load('model_array_05.npy')\nmodel_array_06 = np.load('model_array_06.npy')\nmodel_array_07 = np.load('model_array_07.npy')\nmodel_array_08 = np.load('model_array_08.npy')\nmodel_array_09 = np.load('model_array_09.npy')\nmodel_array_10 = np.load('model_array_10.npy')\nSum up the 10 arrays.\nmodel_array_sum = model_array_01 + model_array_02 + model_array_03 + model_array_04 + model_array_05 + model_array_06 + model_array_07 + model_array_08 + model_array_09 + model_array_10",
    "Set up displaying of a confusion matrix. The parameters ‘normalize=True’ and ‘normalize=False’ specify that the values in the matrix are displayed as percentage or as they are, respectively.\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport itertools\nimport numpy as np\ndef plot_confusion_matrix(cm, classes, normalize=True, title='Confusion matrix', cmap=plt.cm.Blues):\n  \"\"\"\n  This function prints and plots the confusion matrix.\n  Normalization can be applied by setting `normalize=False`.\n  \"\"\"\n  if normalize:\n    cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]\n    print(\"Normalized confusion matrix\")\n  else:\n    print('Confusion matrix, without normalization')\n  print(cm)\n  plt.imshow(cm, interpolation='nearest', cmap=cmap)\n  plt.title(title)\n  plt.colorbar()\n  tick_marks = np.arange(len(classes))\n  plt.xticks(tick_marks, classes, rotation=45)\n  plt.yticks(tick_marks, classes)\n  fmt = '.2f' if normalize else 'd'\n  thresh = cm.max() / 2.\n  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):\n    plt.text(j, i, format(cm[i, j], fmt),\n        horizontalalignment=\"center\",\n        color=\"white\" if cm[i, j] > thresh else \"black\")\n  plt.tight_layout()\n  plt.ylabel('True label')\n  plt.xlabel('Predicted label')\nDisplay the confusion matrix.\nspecies=['Escherichia', 'Bacillus', 'Thermus', 'Thermococcus', 'Sulfolobus', 'Nitrososphaera']\nplot_confusion_matrix(model_array_sum, species)\nNote: The order of the labels to be included in the ‘species’ should be the same as that of the ‘labels’ above (see step 19b).\nNote: Recently, a method for visualizing feature importance in convolutional neural network (CNN) has been reported (Lu et al., 2020[href=https://www.wicell.org#bib10]), but it requires complicated calculations and own coding. In contrast, this protocol using RF can extract feature importance more easily with standard commands available in Python.",
    "Note: In constructing each decision tree, a subset of the spectral data sampled by bootstrapping (random resampling of data with replacement) is used, thereby leaving unsampled data (i.e., OOB samples). The performance of each tree can be validated by using these OOB samples. As can be seen from Figure 7[href=https://www.wicell.org#fig7]C, the OOB error rate in general decreases with increasing the number of trees (‘n_estimators’). This curve is used to derive an optimal value of ‘n_estimators’ (Figure 9[href=https://www.wicell.org#fig9]); it converges for the ‘n_estimator’ value larger than ∼200 in the present case. Detailed instructions on how to display the OOB error rate can be found on the scikit-learn library web site: https://scikit-learn.org/stable/auto_examples/ensemble/plot_ensemble_oob.html?highlight=oob[href=https://scikit-learn.org/stable/auto_examples/ensemble/plot_ensemble_oob.html?highlight=oob] (our script file deposited on Zenodo also contains the code for OOB error rate).\nAssign the wavenumbers with high feature importance scores obtained in step 19d by referring to one of the many previous papers that show tables of the Raman band assignments for major biological molecules; see, for example, (Carey, 1982[href=https://www.wicell.org#bib1]; Kuhar et al., 2018[href=https://www.wicell.org#bib8]; Matsuda et al., 2019[href=https://www.wicell.org#bib11]; Naumann, 2001[href=https://www.wicell.org#bib12])."
  ],
  "subjectAreas": [
    "Chemistry",
    "Bioinformatics",
    "Microbiology",
    "Single Cell",
    "Biophysics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}