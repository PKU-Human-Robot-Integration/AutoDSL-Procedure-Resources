{
  "id": 18129,
  "origin_website": "Jove",
  "title": "Executing Complexity-Increasing Queries in Relational (MySQL) and NoSQL (MongoDB and EXist) Size-Growing ISO/EN 13606 Standardized EHR Databases",
  "procedures": [
    "1. Build a Relational MySQL DBMS to Store Three Double Sized Standardized EHR Extracts Databases\nImport the W3C (World Wide Web Consortium) XML Schema corresponding to the ISO/EN13606 RM and the ISO21090 Data types into a 'Java IDE' (Integrated Development Environment).\n\tNOTE: ISO stands for International Standards Organization. EN stands for European Norm.\nExecute the JAXB (Java XML Binding) plug-in in the IDE; this produces Java classes corresponding to the structure of the elements of the EHR extracts XML files.\nTag manually the Java classes produced with JPA labels. These labels refer to the cardinalities and other relations between the relational tables of the MySQL database.\nImport the libraries of the JPA (Java Persistence API) into the IDE and execute the method that builds a MySQL database out of the tagged Java classes.\nCreate three directories with 5,000, 10,000 and 20,000 realistic EHR extracts XML files.\nExecute the JPA method to load an XML extract into the MySQL DBMS on all the extracts of the 5,000 extracts directory.\nRepeat step 1.6 twice, once with the 10,000 extracts directory and once with the 20,000 extracts directory.\n2. Build a NoSQL MongoDB DBMS to Store Three Double Sized Standardized EHR Extracts Databases\nProcess each of the three directories containing 5,000, 10,000 and 20,000 realistic EHR extracts XML files with a standard program to convert XML files to JSON files, such as json.org.XML. Three directories with 5,000, 10,000 and 20,000 JSON files should be produced.\nLaunch a MongoDB GUI (Graphic User Interface, see Table of Materials).\nLaunch the MongoDB 2.6 server executing the mongod program from a DOS (Disk Operating System) system window.\nConnect the MongoDB GUI to the localhost server using port 27017.\n\t\nSelect the \"Connect\" menu.\nWrite a name for the connection (for instance 'first').",
    "Write localhost:27017 in the DB Server textbox.\nPress the \"Connect\" button ; a tree with the current databases should appear on the left.\nBuild a database containing 5,000 standardized EHR extracts.\n\t\nClick on the name of the connection at the top of the tree on the left.\nSelect the \"File\" menu.\nChoose \"Add Database\".\nEnter the name of the database in the dialog that appears.\nClick OK.\nBuild a collection containing 5,000 standardized EHR extracts.\n\t\nClick on the name of the database in the tree on the left.\nSelect menu \"Database\".\nChoose \"AddCollection\".\nEnter the name of the collection in the dialog that appears.\nClick \" create\".\nClick on the name of the collection.\nSelect the \"Import\" menu.\nChoose radio button ''JSON - mongo shell / / mongoexport\".\nClick \"next\".\nPress the \"Add Source Files\" button.\nNavigate on the computer using the dialog.\nOpen the directory containing 5,000 JSON extract files.\nSelect all the files in the directory.\nPress \"Open\". The list of JSON files should appear in the Import dialog.\nPress \"Next\"; a preview of the new collection in the database appears on the left.\nPress \"Next\".\nPress \"Start Import\". The progress of the import appears down on the left, indicating the number of files imported and the elapsed time.\nRepeat steps 5 and 6 to build a collection of 10,000 standardized EHR extracts.\nRepeat steps 5 and 6 to build a collection of 20,000 standardized EHR extracts.\n3. Build a NoSQL eXist DBMS to Store Three Double Sized Standardized EHR Extracts Databases\nLaunch the eXist database.\nUsing the database's icon, open the Java Admin Client.\nEnter the admin password.\nPress the \"Connect\" button.\nBuild a collection containing 5,000 standardized EHR extracts.\n\t\nIn the toolbar, select the menu \"Create a new Collection\".",
    "In the dialog that appears, type the name of the new collection.\nClick \"accept\"; the new collection will appear.\nSelect the name of the collection.\nIn the toolbar, select the menu \"Store files in the database\".\nNavigate on the computer using the dialog box.\nSelect the directory containing 5,000 standardized XML extract files.\nClick the button \"Select the files or directories to store\". Note that a dialog box appears showing the progress, the files being stored, and the percentage of the database created.\nRepeat step 5 to build a collection containing 10,000 standardized EHR extracts.\nRepeat step 5 to build a collection containing 20,000 standardized EHR extracts.\n4. Design and Execute in the 3 Relational MySQL Databases 6 Complexity-Increasing Queries\nDesign six complexity-increasing queries according to the archetypes used by the EHR extracts.\nProgram an SQL script with the first query on the MySQL database. The SQL must adapt to the special structure of the MySQL database due to extracts standardization (archetypes). The database maps the whole structure of the extracts. As a result, the SQL query is rather complex.\nIdentify the attributes of the databases that would speed up the response time of the queries if an index was built on them, then construct such indexes, though most indexes are built automatically by the DBMS.\nIf a query needs a non-automatically built index, build it manually.\n\t\nConnect to the MySQL server (Supplementary Figure 1).\nSelect and click on the database name on the left.\nSelect and click on the relational table where the indexed field resides.\nClick on the tab \"Structure\".\nSelect and click on the column where the index will be built.\nClick on \"index\". Note that the SQL sentence building the index appears, and a message stating that the sentence has been built successfully appears.",
    "Execute the first query.\n\t\nSelect and click on the database name on the left.\nClick on the tab \"SQL\".\nWrite or paste the SQL code of the first query (see Supplementary Figure 2).\nPress \"continue\". Note that the first screen of the list of results appears, along with a message with the execution time of the query.\nRepeat the execution 5 times and compute the average response time.\nRepeat step 5 with queries 2 through 6.\nDo the whole process three times, with the 5,000, 10,000 and 20,000 extracts databases.\n5. Design and Execute in the 3 NoSQL MongoDB Databases 6 Complexity-Increasing Queries\nLaunch the MongoDB GUI (see Table of Materials).\nLaunch the MongoDB 2.6 server executing the mongod program from a DOS system window (see Supplementary Figure 3).\nFollow step 2.4 to connect the MongoDB GUI to the localhost server using port 27017.\nSelect and expand the MongoDB database on the left side.\nSelect the collection.\nClick on the \"Collection\" menu in the toolbar.\nExecute the first MongoDB query.\n\t\nDouble-click the \"Query Builder\" button.\nDouble-click on the \"Query field\" of the Query Builder at the right.\nWrite the field of the MongoDB query in the field textbox of the query panel (See Supplementary Figure 4).\nWrite the value of the MongoDB query in the value textbox of the query panel.\n\t\tNOTE: This query should be something like {\"ns3:EHRExtract.allCompositions.content.items.parts.parts.name.ns2:originalText. value\": \"Descripcion\"}. The field and the value are quoted and separated by semicolon.\nDouble-click on the Projection field of the Query Builder\nWrite the first projection in the projection textbox (see Supplementary Figure 5).\nDouble-click on the projection field to add a new projection textbox.\nWrite the second projection in the projection textbox.",
    "NOTE: A projection selects a part of the document retrieved by the query. These should be something like {\"ns3:EHRExtract. allCompositions.content.items.parts.parts.value.value\": 1} and {\"ns3: EHRExtract.all Compositions.content.items.parts.parts.value.nullFlavor\" : 1}\nClick on the blue play button to execute the query.\nVisualize the query code in the Query Code tab.\nView the details of the result in the Explain tab: number of results, execution time in milliseconds.\nView, expand, and examine the results in the Result tab.\nIf further processing of the query is required, write a Java program with the MongoDB Java driver with the query and a method to process the results.\nRepeat the execution 5 times and compute the average response time.\nDo step 5.7 for the remaining 2 through 6 queries.\nRepeat the whole process in the 5,000, 10,000 and 20,000 extracts MongoDB databases.\n6. Design and Execute in the 3 NoSQL eXist Databases 6 Increasing-Complexity Queries\nLaunch the eXist DBMS.\nOpen the Java Admin Client.\nPress the button \"connect to the database\".\nSelect the database and click on it.\nClick on the menu \"Consult database using XPath\"; the consult dialog box appears.\nExecute the first XPath query (see Supplementary Figure 6).\n\t\nWrite or paste the XPath code of the first query in the upper part of the dialog box.\nClick on the menu \"Execute\" in the toolbar of the dialog box.\nView XML results using the \"XML\" tab in the lower part of the dialog box.\nView number of results and compilation and execution time at the bottom of the dialog box.\nRepeat the execution 5 times and compute the average response time.\nRepeat step 6 for queries 2 through 6.\nDo the whole process three times, for the 5,000, 10,000 and 20,000 extracts eXist databases.",
    "7. Design and Execute a Concurrency Experiment using the MySQL and MongoDB 5,000 Extracts Databases\nNOTE: The eXist database has been removed from the experiment at this juncture due to worse performance in the previous experiments.\nSelect the queries with the three shortest time responses in the previous experiments using the 5,000 extracts databases (typically under several seconds).\nIdentify and manually build appropriate attribute indexes for those queries, if necessary.\nProgram two Java multithread applications, one for MySQL and the other for MongoDB; each application will have three different priority threads, one for each query selected in step 1.\nExecute and compute the CPU (Central Processing Unit) use distribution for each thread (query).\nExecute each multithread application, clicking on the execute button five times during each 10-min span, and compute the most executed (highest priority) query average throughput and the average time response of the three queries.\nView the queries in execution, with priorities and execution time.\nCompute average throughput and average response time of each of the three queries."
  ],
  "subjectAreas": [
    "Medicine"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research"
  ]
}