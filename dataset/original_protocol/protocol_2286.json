{
  "id": 2406,
  "origin_website": "Cell",
  "title": "Protocol for topology-preserving smoothing of BOLD fMRI retinotopic maps of the human visual cortex",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nOrganize the project folders and add the search paths\nTiming: 2 min\nThis section mainly describes the recommended location of our package and outputs in user projects.\nNote: We recommend that the user organize the project into several folders. The “code” folder contains our Topology-Preserving Smoothing of Retinotopic Maps (TPSR) package and third-party libraries, the “data” folder contains the necessary data for processing, and the “Figures” and “result” folders are optional and can be generated by the smoothing package automatically.\n| - code/ // all the codes for the project.\n  | - Libraries/ // third party libraries.\n  | - TPSR/ // the core smoothing package.\n| - data/ // data for validating our method.\n  | - mesh/\n  |- ...\n| - Figures/ // figures generated by the smoothing package.\n| - result/ // results generated by the smoothing package.\nAdd “TPSR” to the MATLAB search path:\n> addpath(genpath('TPSR'));\nAdd the third-party packages:\n> addpath(genpath('libraries'));\nAlternatively, the user can add search paths using the MATLAB user interface (Figure 1[href=https://www.wicell.org#fig1]): Select the “libraries” folder, right click, and “Add to Path” with “Selected Folders and SubFolders”.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1892-Fig1.jpg\nFigure 1. Adding path with the MATLAB user interface\n(A) A screenshot of MATLAB user interface for adding path for the TPSR package.\n(B) A screenshot of MATLAB user interface for adding path for the libraries.\nLoad and preprocess data\nTiming: 5 min\nThis section introduces data preprocessing, including directly loading data from the OSF website or processing data from the HCP, flattening the cortical patch to a 2D disk, finding the region of interest on the disk, and establishing the visual coordinates of the boundary of the ROI.\nData preparation.\nLoad data from our OSF website.",
    "Note: For users who wish to reproduce the results in Tu et al. (2021)[href=https://www.wicell.org#bib1], we recommend that they directly download the “data/mesh_data” from our osf website (OSF data: https://doi.org/10.17605/OSF.IO/DBGKF[href=https://doi.org/10.17605/OSF.IO/DBGKF]) into “data/mesh”. The mesh data contain visual cortical surfaces cut from both hemispheres of the brain (Tu et al., 2021[href=https://www.wicell.org#bib1]). Specifically, each cortical surface mesh has one boundary and contains the retinotopic coordinates and perceptual field sizes from the pRF solution and initial visual area labels.\nLoad the mesh data with the “read_mfile” function in the < geometry-processing-package> library (In this example, the mesh file has 6K vertices, the computer has 8G RAM, and the loading takes less than 1 s):\n> [Fm, Vm, Em]=read_mfile('../data/mesh_data/102311lh.m')\nNote: “Fm” is the face list, “Vm” is the vertex list. Extra information is stored in the “Em” struct, which contains pRF decoding result and visual area label for each vertex. [Note that the mesh data from our OSF site also contain pial surface coordinates, sphere registration coordinates, vertex id before cutting, etc.]\nSome background on discrete surface: the fundamental data structure in surface processing is the triangular mesh, which consists of a list of vertices, a list of faces, and maybe (very often) some extra features associated with the vertices or faces.\nProcess data from the HCP. For users who wish to start from a hemisphere of the brain in the HCP dataset, which is a genus zero sphere-like surface (therefore no boundaries), they need to cut a geodesic disk with the following procedure:",
    "Find a center point roughly corresponding to the fovea of the primary visual cortex V1 (In our experiments, cortical surfaces are registered by FreeSurfer in the released HCP data. We are able to select a consistent point across subjects. There is probably some flexibility in center point selection, but more work is necessary to verify it.).\nCompute the geodesic distance between each point on the hemisphere and the center with the fast marching algorithm, which is similar to the Dijkstra algorithm that computes geodesic distance on graphs;\nKeep the patch made of points within a threshold geodesic distance (to include all points within the region of interest, e.g., radius=100). The final output, (Fcut, Vcut, id_cut), consists of the mesh of the geodesic disk and the index (before the deletion) of the kept vertices.\nstart_points = 23452; % this point roughly corresponds to the fovea of V1 in the left hemisphere in the hcp 53k mesh\nradius=100; % set the radius to keep\n[D,S,Q]= perform_fast_marching_mesh(double(Vm), double(Fm),start_points);\nind2del = find(D > radius); % find points that are outside of the radius\n[Fcut, Vcut, id_cut] = gf_remove_mesh_vertices(Fm, Vm, ind2del); % cut\nFlatten the patch to a 2D disk.\nNote: To simplify the smoothing process, we first convert the retinotopic map from the 3D cortical surface to a 2D disk. This involves flattening the 3D cortical surface onto a 2D planar disk in one-to-one mapping. We have written three functions to support the flattening process. The user can choose any one of them based on their own needs.\nThe function “disk_harmonic_map” flattens the patch with sufficient smoothness:\n> uv = disk_harmonic_map(Fcut, Vcut)\nThe function “disk_conformal_map” flattens the patch conformally (angle preserving):\n> uv = disk_conformal_map(Fcut, Vcut)\nThe function “disk_area_mapping” flattens the patch while preserving each local area:\n> uv = disk_area_mapping (Fcut, Vcut)",
    "Note: We provide three different functions to parametrize the 3D visual cortical patch to the 2D domain to support different types of analysis of human retinotopic mapping. If the goal is to analyze angle distortions in retinotopic mapping, we recommend “disk_conformal_map” because the function does not introduce angle distortion in the flattening process. One may adopt “disk_area_mapping” function if the goal is to study metric properties in retinotopic mapping (e.g., cortical magnification factor). As a convenient and robust disk parameterization method, the function, \"disk_harmonic_map\" may be used to perform preliminary qualitative analysis.\nDraw the region of interest (ROI).\nCritical: The geodesic disk from steps 4a or 4b may contain too many vertices. In the example case, there are about 310 vertices. In this step, a region of interest (ROI) for smoothing is further cut from the disk with the following utilities (See Methods video S1[href=https://www.wicell.org#mmc1]).\nIf you start with our OSF data, please use the boundary provided in “data/V1.mat”. Because the HCP 53k mesh data are registered and resampled with the same resolution, this boundary file can be applied to all the subjects in the HCP dataset.\nIf you start with the HCP data without registration or other data, the boundary of the ROI must be defined. We provide an interactive function, boundary_editor.m, for you to manually define the ROI.\nNote: You can call this function directly in the MATLAB command line when the current path is the ‘code’ folder.\n% You can pass the file name as the parameter in this function. In our sample code, we use 102311lh.m\n> boundary_editor('102311lh.m');",
    "The program draws a visual polar angle mesh on the parametrized disk. Please left-click the mouse to define the mouse position as the starting vertex of the ROI polygon. Then right click the mouse on the disk to define other vertices of the ROI polygon.\nAfter defining the ROI, a notice will appear in your command line. You need to input a file name to save the results.\n    Your browser does not support HTML5 video.\n  \nMethods video S1. Draw the_ROI, related to step 6\n% Input the custom file name\n> filename: result\nNote: Then, the ‘result.mat’ file will be generated in your current path.\nPrepare visual coordinates of the boundary.\nIf you start from our OSF data, the visual coordinates of the boundary are provided in “data/V1.mat”.\nIf you start from the HCP data without registration or other data, visual coordinates of the boundary are generated after you finish running “boundary_editor.m”.\nNote: The visual coordinates of the boundary must be well-defined, with the winding number equal to 1. Otherwise, topological smoothing in step 9 will fail. We refer users to the troubleshooting[href=https://www.wicell.org#troubleshooting] section for further information. The visual coordinates of the boundary are stored in the variable “bd_vis0” after running the script “boundary_editor.m.”\nPrepare the data for topological smoothing.\nPrepare the face list of the ROI:\n[Froi, uv_roi, vfather] = gf_remove_mesh_vertices(Fcut, uv, id2delete);\nPrepare the visual coordinates of the ROI:\nprf = Em.Vertex_prf(vfather,:);\nvis = prf(:,[2 1]) % The data are sorted in the order of eccentricity and polar angle\nR2 = prf(:,5)\nPrepare the boundary id of the ROI:\nbd_id = compute_bd(Froi);\nConvert the parametric coordinates into a polar angle coordinate system by calling “uv_pol = cart2pol(uv_roi(:,1), uv_roi(:,2))”.\nSmooth the retinotopic maps\nTiming: 1 min",
    "This section describes the parameters used in the smoothing function and details of the smoothing process.\nUse the function “topological_smoothing” to smooth the retinotopic map within the ROI:\n> visxy_s = topological_smoothing(Froi, uv_pol, vis, R2,...\n                        anchor, anchorpos, changetol, ...\n                    smooth_lambda0, smooth_avg_k, meanddth);\nThe parameters specified in the input to the function are:\nFroi: the face list of the ROI;\nuv_pol: parametric coordinates of the ROI;\nvis: retinotopic visual coordinates (eccentricity and polar angle) before smoothing;\nR2: goodness of pRF decoding, ranging from 0 to 100;\nanchor: boundary index of the ROI (calculated in step 8);\nanchorpos: boundary visual coordinates of the ROI;\nchangetol: maximum change of boundary visual coordinates in smoothing; it is an empirical value. The user can customize it for different input data.\nsmooth_lambda0: smoothness factor, with higher values leading to more smoothing;\nsmooth_avg_k: number of neighbors of the boundary used to do average smoothing of the boundary if boundary smoothing is used during topological smoothing;\nmeanddth: mean visual coordinates change allowed during smoothing.\nThere are three sub-modules in this function:\nObtaining the boundary of the retinotopic map by extrapolating it from the interior of the ROI. We provide the function “smooth_bd_vis_byfit” to fit the interior of the ROI and predict new visual coordinates of the boundary.\n>\nif changetol > 0\n  for ti = 1:3\n    bd_vis_new = smooth_bd_vis_byfit(uv_pol, vis, bd_id, R2);\n    for i=1:size(bd_vis_new,1)\n      bd_vid_change = bd_vis_new(i,:) - bd_vis0(i,:);\n      if norm(bd_vid_change)> changetol\n        bd_vis_new(i,:) = bd_vis0(i,:) + bd_vid_change/norm(bd_vid_change)∗changetol; % update to the maximum tolerance\n        end\n      end\n      bd_vis = bd_vis_new;\n  end\nelse\n  bd_vis = bd_vis0;\nend\nNote: The new boundary for the first subject in the OSF data is shown in Figure 2[href=https://www.wicell.org#fig2] (the last segmentation of the boundary is not drawn to show the endpoints).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1892-Fig2.jpg\nFigure 2. The new boundary for the first subject in the OSF data",
    "Fixing the topology: Check the topological condition. It is well known from neurophysiology that retinotopic mapping is topological (i.e., the topology of neighborhood connectivity is preserved) within each visual area. In this study, we adopt the Beltrami coefficient, a metric of quasiconformal mapping, to define the topological condition, develop a mathematical model to quantify topological smoothing as a constrained optimization problem, and elaborate an efficient numerical method to solve the problem. The topological condition is met when Beltrami coefficient μ < 1 for all triangles.\n> flip = get_flips(face, uv_pol, hat_vis);\n  if flip > 0\n    % smooth and chop if not topological\n    [hat_vis, flip] = make_diffeomorphic(face, uv_pol, hat_vis, bd_id, bd_vis);\n    if size(hat_vis,1) ∼= size(vis,1)\n      hat_vis = vis;\n    end\n  end\nRe-check the topological condition and update the threshold if necessary. The smoothing process continues until the Beltrami coefficient μ < 1 for all triangles.\n>  if(flip > 0)\n    [∼,flipid] = get_flips(face, uv_pol, hat_vis);\n    % fail to fix topology, the only possible reason is that the boundary\n    % value is not good, so we smooth on boundary value\n    % smooth on boundary locally\n    flipid_v = [face(flipid,1);\n    face(flipid,2);face(flipid,3)];\n    % feed flip vertices, and smooth on boundary near flips\n    bd_vis_new = smooth_bd_vis_bybd(bd_id, bd_vis,smooth_avg_k, flipid_v);\n    for i=1:size(bd_vis,1)\n      bd_vid_change = bd_vis_new(i,:) - bd_vis(i,:);\n      if norm(bd_vid_change)> changetol\n        bd_vis_new(i,:) = bd_vis(i,:) + bd_vid_change/norm(bd_vid_change)∗changetol;\n      % update to the maximum tolerance\n      end\n    end\n    bd_vis = bd_vis_new;\n    % increase the strenth of smoothing\n    if changetol >= 0\n      smooth_avg_k = smooth_avg_k +1;\n    end\n  end\nLaplacian smoothing.\n  A = (diag(R2) + smooth_lambda∗ laplace_beltrami(face,uv_pol));\n  b = (diag(R2)∗hat_vis);\n  in = setdiff(1:size(uv_pol,1), bd_id);\n  hat_vis(in,:) = A(:,in)\\(b - A(:,bd_id)∗ bd_vis);\n  hat_vis(bd_id,:) = bd_vis;\nNote: An example is shown in Figure 3[href=https://www.wicell.org#fig3].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1892-Fig3.jpg\nFigure 3. The result of the smoothing process for the subject\nNote: The smoothing processing will terminate after the topological condition is satisfied.",
    "Extension to V2 and V3\nTiming: 1 min\nOur algorithm is designed to work within one visual area. However, with some adjustments, the algorithm can be applied to V1, V2, and V3 simultaneously. More specifically, since the fovea of V1, V2 and V3 are very close, we introduce “extended polar angle”, which is continuous and can be obtained from a set of linear transformations of the polar angles in different visual areas, to remove the phase-jumping and changes of visual field signs for the left and right hemispheres in multiple visual areas. The specific transformations are explained in (Tu et al., 2021[href=https://www.wicell.org#bib1]). We only list them here in Table 1[href=https://www.wicell.org#tbl1].\ntable:files/protocols_protocol_1892_1.csv\nIn this way, the algorithm can be applied to V1, V2, and V3 simultaneously. We provide the following utilities to compute the extended polar angles.\nUse the following utility to get the visual coordinates of the ROI:\nvisxy_corrected =correct_vis(Em, 'lh');% “lh” stands for the left hemisphere\nvisxy_corrected = visxy_corrected(vfather,:);\nApply the same smoothing in step 9:\nvisxy_s = topological_smoothing(Fcut, uv_pol, vis, R2,...\n                  anchor, anchorpos,changetol, ...\n                smooth_lambda0,smooth_avg_k, meanddth);\nAfter smoothing, the function “restore_vis” can be used to transform the extended polar angles back to the original visual polar angles.\nvis_c = restore_vis(visxy_s);\nNote: We provide an example, “GenFigure10_Smooth_V1V2V3.m”, for smoothing the retinotopic maps in V1, V2, and V3."
  ],
  "subjectAreas": [
    "Computer Sciences",
    "Neuroscience",
    "Cognitive Neuroscience"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research"
  ]
}