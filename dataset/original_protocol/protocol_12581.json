{
  "id": 15008,
  "origin_website": "Jove",
  "title": "Heuristic Mining of Hierarchical Genotypes and Accessory Genome Loci in Bacterial Populations",
  "procedures": [
    "1. Prepare input files\nNOTE: The protocol is available here - https://github.com/jcgneto/jove_bacterial_population_genomics/tree/main/code. The protocol assumes that the researcher has specifically used ProkEvo (or a comparable pipeline) to get the necessary outputs available in this Figshare repository (https://figshare.com/account/projects/116625/articles/15097503 - login credentials are required - The user must create a free account to have file access!). Of note, ProkEvo automatically downloads genomic sequences from the NCBI-SRA repository and only requires a .txt file containing a list of genome identifications as an input20, and the one used for this work on S. Newport USA isolates is provided here (https://figshare.com/account/projects/116625/articles/15097503?file=29025729).  Detailed information on how to install and use this bacterial genomics platform is available here (https://github.com/npavlovikj/ProkEvo/wiki/2.-Quick-start)20\nGenerate core-genome phylogeny using FastTree23 as previously described20, which is not part of the bioinformatics platform20. FastTree requires the Roary24 core-genome alignment as an input file. The phylogeny file is named newport_phylogeny.tree  (https://figshare.com/account/projects/116625/articles/15097503?file=29025690).\nGenerate SISTR25 output containing the information regarding serovars classifications for Salmonella and cgMLST variant calling data (sistr_output.csv - https://figshare.com/account/projects/116625/articles/15097503?file=29025699).\nGenerate BAPS file by fastbaps26,27 containing the BAPS levels 1-6 classification of genomes into sub-groups or haplotypes (fastbaps_partition_baps_prior_l6.csv - https://figshare.com/account/projects/116625/articles/15097503?file=29025684).\nGenerate MLST-based classification of genomes into STs using the MLST program (https://github.com/tseemann/mlst)28 (salmonellast_output.csv - https://figshare.com/account/projects/116625/articles/15097503?file=29025696).\nGenerate ABRicate (https://github.com/tseemann/abricate)29 output as a .csv file containing AMR loci mapped per genome (sabricate_resfinder_output.csv - https://figshare.com/account/projects/116625/articles/15097503?file=29025693).\n\tNOTE: The user can turn off specific parts of the ProkEvo bioinformatics pipeline (check here for more information - https://github.com/npavlovikj/ProkEvo/wiki/4.2.-Remove-existing-bioinformatics-tool-from-ProkEvo). The analytical approach presented here provides guidelines for how to conduct a population-based analysis after the bioinformatics pipeline has been run. \n2. Download and install the statistical software and integrated development environment (IDE) application\nDownload the most up-to-date freely available version of the R software for Linux, Mac, or PC30. Follow the default installation steps.",
    "Download the most up-to-date freely available version of the RStudio desktop IDE here31. Follow the default steps for installation.\n\t​NOTE: The next steps are included in the available script, including detailed information of code utilization, and should be run sequentially to generate the outputs and figures presented in this work (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/data_analysis_R_code.Rmd). The user may decide to use another programming language to conduct this analytical/statistical analysis such as Python. In that case, use the steps in the scripts as a framework to carry out the analysis. \n3. Install and activate data science libraries\nInstall all data science libraries at once as a first step in the analysis. Avoid installing the libraries every time the script needs to be re-run. Use the function install.packages() for library installation. Alternatively, the user may click on the Packages tab inside of the IDE and automatically install the packages. The code used to install all needed libraries is presented here:\n# Install Tidyverse\ninstall.packages(\"tidyverse\")\n\t# Install skimr\n\tinstall.packages(\"skimr\")\n# Install vegan\n\tinstall.packages(\"vegan\")\n# Install forcats\n\tinstall.packages(\"forcats\")\n# Install naniar\n\tinstall.packages(\"naniar\")\n# Install ggpubr\n\tinstall.packages(\"ggpubr\")\n# Install ggrepel\n\tinstall.packages(\"ggrepel\")\n# Install reshape2\n\tinstall.packages(\"reshape2\")\n# Install RColorBrewer\n\tinstall.packages(\"RColorBrewer\")\n# Install ggtree\n\tif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n\t  install.packages(\"BiocManager\")\n\tBiocManager::install(\"ggtree\")\n\t# Installation of ggtree will prompt a question about installation - answer is \"a\" to install/update all dependencies\nActivate all the libraries or packages using the library() function at the beginning of the script, right after installation. Here is a demonstration on how to activate all necessary packages:\n# Activate the libraries and packages\n\tlibrary(tidyverse)\n\tlibrary(skimr)\n\tlibrary(vegan)\n\tlibrary(forcats)\n\tlibrary(naniar)\n\tlibrary(ggtree)\n\tlibrary(ggpubr)\n\tlibrary(ggrepel)\n\tlibrary(reshape2)\n\tlibrary(RColorBrewer)\nSuppress outputting the code used for library and package installation and activation by using {r, include = FALSE} in the code chuck, as follows:\n``` {r, include = FALSE}\n\t# Install Tidyverse\ninstall.packages(\"tidyverse\")\n\t```",
    "NOTE: This step is optional but avoids showing chunks of unnecessary code in the final html, doc, or pdf report.\nFor a brief description of the specific functions of all libraries along with some useful links to gather further information, refer to steps 3.4.1-3.4.11.\n\t\nTidyverse - use this collection of packages used for data science, including data entry, visualization, parsing and aggregation, and statistical modeling. Typically, ggplot2 (data visualization) and dplyr (data wrangling and modeling) are practical packages present in this library32.\nskimr - use this package for generating summary statistics of data frames, including identification of missing values33.\nvegan - use this package for community ecology statistical analyses, such as calculating diversity-based statistics (e.g., alpha and beta-diversity)34.\nforcats - use this package to work with categorical variables such as re-ordering classifications. This package is part of the Tidyverse library32.\nnaniar - use this package to visualize the distribution of missing values across variables in a data frame, by using the viss_miss() function35.\nggtree - use this package for the visualization of phylogenetic trees36.\nggpubr - use this package to improve the quality of ggplot2-based visualizations37.\nggrepel - use this package for text labeling inside of graphs38.\nreshape2 - use the melt() function from this package for the transformation of data frames from wide to long format39.\nRColorBrewer - use this package to manage colors in ggplot2-based visualizations40.",
    "Use the following basic functions for exploratory data analysis: head() to check the first observations in a data frame, tail() to check the last observations of a data frame, is.na() to count the number of rows with missing values across a data frame, dim() to check the number of rows and columns in a dataset, table() to count observations across a variable, and sum() to count the total number of observations or instances.\n4. Data entry and analysis\nNOTE: A detailed information on each step of this analysis can be found in the available script (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/data_analysis_R_code.Rmd). However, here are some important points to be considered:\nDo all genomic data entry, including all genotypic classifications (serovar, BAPS, ST, and cgMLST) using the read_csv() function.\nRename, create new variables, and select columns of interest from each dataset before multi-dataset aggregation.\nDon't remove missing values from any independent dataset. Wait until all datasets are aggregated to modify or exclude missing values. If new variables are created for each dataset, then missing values are by default categorized into one of the newly generated classifications.\nCheck for erroneous characters such as hyphens or interrogations marks and replace them with NA (Not applicable). Do the same for missing values.\nAggregate data based on the hierarchical order of genotypes (serovar -> BAPS1 -> ST -> cgMLST), and by grouping based on the individual genome identifications.\nCheck for missing values using multiple strategies and deal with such inconsistencies explicitly. Only remove a genome or isolate from the data if the classification is unreliable. Otherwise, consider the analysis being done and remove NAs on a case-by-case basis.",
    "NOTE: It is highly recommended to establish a strategy to deal with such values a priori. Avoid removing all genomes or isolates with missing values across any variables. For instance, a genome may have ST classification without having cgMLST variant number. In that case, the genome can still be used for the ST-based analysis.\nOnce all datasets are aggregated, assign them to a data frame name or object that can be used in multiple locations in the follow-up analysis, to avoid having to generate the same metadata file for every figure in the paper.\n5. Conduct analyses and generate visualizations\nNOTE: A detailed description of each step needed to produce all the analysis and visualizations can be found in the markdown file for this paper (https://github.com/jcgneto/jove_bacterial_population_genomics/tree/main/code). Code for each figure is separated in chunks and the entire script should be run sequentially. Additionally, the code for each main and supplementary figure is provided as a separate file (see Supplementary File 1 and Supplementary File 2). Here are some essential points (with snippets of code) to be considered while generating each main and supplementary figures.\nUse ggtree to plot a phylogenetic tree along with genotypic information (Figure 1).\n\t\nOptimize the ggtree figure size, including diameter and width of rings, by changing the numerical values inside of the xlim() and gheatmap(width = ) functions, respectively (see example code below).\n\t\ttree_plot <- ggtree(tree, layout = \"circular\") + xlim(-250, NA)\n\t\tfigure_1 <- gheatmap(tree_plot, d4, offset=.0, width=20, colnames = FALSE)\n\t\tNOTE: For a more detailed comparison of programs that can be used for phylogenetic plotting, check this work20. The work highlighted an attempt made to identify strategies to improve ggtree-based visualizations such as decreasing the dataset size, but branch lengths and tree topology were not as clearly discriminating as compared to phandango41.",
    "Aggregate all metadata into as few categories as possible to facilitate the choice of coloring panel when plotting multiple layers of data with the phylogenetic tree (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/figure_1.Rmd). Conduct the data aggregation based on the question of interest and domain knowledge.\nUse a bar plot to assess relative frequencies (Figure 2).\n\t\nAggregate data for both ST lineages and cgMLST variants to facilitate visualizations. Choose an empirical or statistical threshold used for data aggregation, while considering the question being asked.\nFor an example code that can be used to inspect the frequency distribution of ST lineages to determine the cut-off see below:\n\t\tst_dist <- d2 %>% group_by(ST) %>% # group by the ST column\n\t\tcount() %>% # count the number of observations \n\t\tarrange(desc(n)) # arrange the counts in decreasing order \nFor an example code showing how minor (low-frequency) STs can be aggregated refer below. As demonstrated below, STs that are not numbered as 5, 31, 45, 46, 118, 132, or 350, are grouped together as \"Other STs\". Use a similar code for cgMLST variants (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/figure_2.Rmd).\n\t\td2$st <- ifelse(d2$ST == 5, \"ST5\", # create a new ST column for which minor S Ts are aggregated as Others\n\t\t ifelse(d2$ST == 31, \"ST31\",\n\t\t  ifelse(d2$ST == 45, \"ST45\",\n\t\t   ifelse(d2$ST == 46, \"ST46\",\n\t\t    ifelse(d2$ST == 118, \"ST118\",\n\t\tifelse(d2$ST == 132, \"ST132\", ifelse(d2$ST == 350, \"ST350\", \"Other STs\")))))))\nUse a nested approach to calculate the proportion of each ST lineage within each BAPS1 sub-group to identify STs that are ancestrally related (belong to the same BAPS1 sub-group) (Figure 3). The code below exemplifies how the ST-based proportion can be calculated across BAPS1 sub-groups (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/figure_3.Rmd):\n\tbaps <- d2b %>% filter(serovar == \"Newport\") %>% # filter Newport serovars \n\tselect(baps_1, ST) %>% # select baps_1 and ST columns \n\tmutate(ST = as.numeric(ST)) %>% # change ST column to numeric",
    "drop_na(baps_1, ST) %>% # drop NAs \n\tgroup_by(baps_1, ST) %>% # group by baps_1 and ST \n\tsummarise(n = n()) %>% # count observations \n\tmutate(prop = n/sum(n)*100) # calculate proportions\nPlot the distribution of AMR loci across ST lineages using the Resfinder-based gene annotation results (Figure 4).\n\tNOTE: Resfinder has been widely used in ecological and epidemiological studies42. Annotation of protein-coding genes can vary depending on how often databases are curated and updated. If using the suggested bioinformatics pipeline, the researcher can compare AMR-based loci classifications across different databases20. Be sure to check which databases are continually being updated. Do not use out-of-date or poorly curated databases, in order to avoid miscalls.\n\t\nUse an empirical or statistical threshold to filter out the most important AMR loci to facilitate visualizations. Provide a raw .csv file containing the calculated proportions of all AMR loci across all ST lineages, such as shown here (https://figshare.com/account/projects/116625/articles/15097503?file=29025687).\nCalculate the AMR proportion for each ST using the following code (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/figure_4.Rmd):\n# Calculations for ST45\n\t\td2c <- data6 %>% filter(st == \"ST45\") # filter ST45 data first\n\t\t# for ST45, calculate the proportion of AMR loci and only keep proportion greater than 10%\n\t\td3c <- d2c %>% select(id, gene) %>% # select columns\n\t\tgroup_by(id, gene) %>% # group by id and gene\n\t\tsummarize(count = n()) %>% # count observations\n\t\tmutate(count = replace(count, count == 2, 1)) %>% # replace counts equal to 2 with 1 to only consider one copy of each gene (duplications may not be reliable), but the researcher can decide to exclude or keep them. If the researcher wants to exclude them, then use the filter(count != 2) function or else leave as is\n\t\tfilter(count <= 1) # filter counts below or equal to 1 \n\t\td4c <- d3c %>% group_by(gene) %>% # group by gene",
    "summarize(value = n()) %>% # count observations\n\t\tmutate(total = table(data1$st)[6]) %>% # get the total counts of st mutate(prop = (value/total)*100) # calculate proportions \n\t\t​d5c <- d4c %>% mutate(st = \"ST45\") # create a st column and add ST information\nAfter calculations are done for all STs, combine datasets as one data frame, using the following code:\n# Combine datasets\n\t\td6 <- rbind(d5a, d5b, d5c, d5d, d5e, d5f, d5g, d5h) # row bind datasets \nTo export the .csv file containing the calculated proportions, use the code:\n# Export data table containing ST and AMR loci information\n\t\tabx_newport_st <- d6 write.csv(abx_newport_st,\"abx_newport_st.csv\", row.names = FALSE)\nBefore plotting the AMR-based distribution across ST lineages, filter the data based on a threshold to facilitate visualizations, as shown below:\n# Filter AMR loci with proportion higher than or equal to 10%\n\t\td7 <- d6 %>% filter(prop >= 10) # determine the threshold empirically or statistically\nPlot the core-genome phylogeny along with the hierarchical genotypic classifications and AMR data in a single plot using ggtree (Figure 5).\n\t\nOptimize the figure size inside ggtree using the abovementioned parameters (see step 5.1.1.).\nOptimize visualizations by aggregating variables, or using binary classification such as gene presence or absence. The more features are added to the plot, the harder the coloring selection process becomes (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/figure_5.Rmd).\n\t\tNOTE: Supplementary figures - detailed description of the entire code can be found here (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/data_analysis_R_code.Rmd).\nUse a scatter plot in ggplot2, without data aggregation, to display the distribution of ST lineages or cgMLST variants while highlighting the most frequent genotypes (Supplementary Figure 1) (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/supplementary_figure_s1.Rmd).",
    "Do a nested analysis to assess the composition of ST lineages through the proportion of cgMLST variants in order to get a glimpse of the ST-based genetic diversity, while identifying the most frequent variants and their genetic relationships (i.e., cgMLST variants that belong to the same ST shared an ancestor more recently than those belonging to distinct STs) (Supplementary Figure 2) (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/supplementary_figure_s2.Rmd). \nUse community ecology metric, namely Simpson's D index of diversity, to measure the degree of clonality or genotypic diversity of each of the major ST lineages43 (Supplementary Figure 3).\n\t\nCalculate the index of diversity across ST lineages at different levels of genotypic resolution including BAPS level 1 through 6 and cgMLST. Below is the code example on how to do this calculation at the BAPS level 1 (BAPS1) of genotypic resolution:\n\t\t# BAPS level 1 (BAPS1)\n\t\t# drop the STs and BAPS1 with NAs, group by ST and BAPS1 and then calculate Simpson's index\n\t\tbaps1 <- data6 %>%\n\t\tselect(st, BAPS1) %>% # select columns\n\t\tdrop_na(st, BAPS1) %>% # drop NAs\n\t\tgroup_by(st, BAPS1) %>% # group by columns\n\t\tsummarise(n = n()) %>% # count observations\n\t\tmutate(simpson = diversity(n, \"simpson\")) %>% # calculate diversity\n\t\tgroup_by(st) %>% # group by column\n\t\tsummarise(simpson = mean(simpson)) %>% # calculate the mean of the index\n\t\tmelt(id.vars=c(\"st\"), measure.vars=\"simpson\",\n\t\tvariable.name=\"index\", value.name=\"value\") %>% # covert into long format\n\t\tmutate(strat = \"BAPS1\") # create a strat column\n\t\tNOTE: A more genetically diverse population (i.e., more variants at different layers of genotypic resolution) has a higher index at the cgMLST level and produces an increasing index-based values going from BAPS level 2 to 6 (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/supplementary_figure_s3.Rmd).",
    "Examine the degree of genotypic diversity of ST lineages by plotting the relative frequency of BAPS sub-groups at all levels of resolution (BAPS1-6) (Supplementary Figure 4). The more diverse the population is, the sparser the distribution of BAPS sub-groups (haplotypes) becomes going from BAPS1 (lower level of resolution) to BAPS6 (higher level of resolution) (https://github.com/jcgneto/jove_bacterial_population_genomics/blob/main/code/supplementary_figure_s4.Rmd). \nSubscription Required. Please recommend JoVE to your librarian."
  ],
  "subjectAreas": [
    "Genetics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics"
  ]
}