{
  "id": 19698,
  "origin_website": "Wiley",
  "title": "Expanding the Perseus Software for Omics Data Analysis With Custom Plugins",
  "procedures": [
    "R is one of the most widely used programming languages for bioinformatics. Numerous packages for statistical data analysis and visualization have been created by R developers. In order to make Perseus more powerful by making these functions available from within the software, a package for integrating R scripts into Perseus was developed—PerseusR (Rudolph & Cox, 2019[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0016]). With this, all custom tools originally scripted in R can now be used within Perseus. In this basic protocol, a simple example of an R-only plugin, extracting the head (top rows) of a matrix, will be presented to illustrate how the data transfer between Perseus and R functions. This example will be run through the command line style interface. The code of this example is available at: https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head.R[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head.R].\nNecessary Resources\nHardware\nA computer running Windows 8 (64 bit) or higher, or Windows Server 2008 or higher\n4 GB RAM minimum\nAt least a quad core processor is recommended\nSoftware\nPerseus 1.6.13 or higher:–can be downloaded from https://maxquant.org/perseus[href=https://maxquant.org/perseus]\nR: Please use a version ≥ 3.5.0. The Rscript executable has to be listed in the PATH environment variable of the operating system. Please refer to the “Troubleshooting” if Perseus cannot find your R installation, which is indicated in the command line style interface.\nPerseusR: available at https://github.com/cox-labs/PerseusR[href=https://github.com/cox-labs/PerseusR], where installation instructions are provided\ninstall.packages(“devtools”)\nlibrary(devtools)\ninstall_github(“cox-labs/PerseusR”)\nR-supported editor like Visual Studio, RStudio or Notepad++\nInput files\nThis protocol requires no extra input files. The outlined plugin works with a randomly generated matrix, which can be done using the dice button in Perseus.\n1. Parse command line arguments from Perseus.\nThe communication between Perseus and R works through temporary files containing the data, their location being specified by fixed index command line arguments. Therefore, these command line arguments sent from Perseus need to be parsed first.",
    "args = commandArgs(trailingOnly=TRUE)\nif (length(args) != 2) {\n stop(\"Do not provide additional arguments!\", call.=FALSE)\n}\ninFile <- args[1]\noutFile <- args[2]\nSince the arguments from Perseus are input file and output file, the length of arguments should be 2. The order of the arguments is fixed: the first in this case is for input file and the last one is for the output file.\n2. Use PerseusR to read the data matrix written by Perseus.\n         \nlibrary(PerseusR)\nmdata <- read.perseus(inFile)\nPerseusR is the package that bridges between Perseus and R. It needs to be imported first. Afterwards, the matrix from Perseus can be read into a special matrixData object by read.perseus.\n3. Get the main matrix of Perseus for data processing.\nThe matrix in Perseus is composed of annotation rows/columns and the main data columns. In order to extract the main matrix for analysis, the function −main() needs to be used.\n         \ncounts <- main(mdata)\n4. Execute the main custom code for data analysis or modification.\nAfter obtaining the main matrix, the custom analysis steps and modifications can be done. In this protocol, the head of the matrix is extracted (“15 rows” is assigned).\n         \nmdata2 <- head(counts, n=15)\nSince the number of rows is reduced for the main matrix, the annotation columns need to be shortened for the output matrix as well. To get the annotation columns, use annotCols().\n         \naCols <- head(annotCols(mdata), n=15)\n5. Export the output matrix to Perseus with correct format.",
    "After finishing all data-processing steps, the data needs to be converted back to the Perseus txt format and written to the predefined temporary output file. For generating the final output, a new matrixData object consisting of main matrix (main), annotation columns (annotCols). and annotation rows (annotRows) needs to be created. Similar to annotCols(), the function annotRows() extracts the content of Perseus annotation rows. Since the annotation rows are not changed by the plugin, they are reused from the original matrix.\n         \nmdata2 <- matrixData(main=mdata2, annotCols=aCols, annotRows=annotRows(mdata))\nTo generate the temporary file, write.perseus() is used with the matrixData object and the outputfile location, which was read in the first step of this protocol.\n         \nprint(paste(`writing to', outFile))\nwrite.perseus(mdata2, outFile)\nThese are all the basic elements of an R-only Perseus plugin. If no further arguments are required, the developers only have to put their custom code in step 4.\n6. Apply the plugin in Perseus.\n         \nOpen Perseus and import the matrix/load a session file.\nA random matrix is used for testing the plugin in this tutorial.\nExecute the plugin.\nIn the “Processing” block, click “External” –> “Matrix –> R”. If the button “select” is green, it means that Perseus recognized your R installation and PerseusR (Figure 5A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0005]), otherwise navigate to your Rscript.exe or add it to your systems PATH variable. Afterwards, specify the R script that you want to execute and click OK (Fig. 5B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0005]).",
    "In order to make a script more flexible and useful, additional parameters are usually required. With the above example of extracting the head of a matrix (Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0001]), it will be much more convenient if the number of rows can be defined by the users. The following steps will provide the details of how to add parameters to the plugins. The script, including all steps, can also be found at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head_add_argument.R[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head_add_argument.R].\nNecessary Resources\nSame as Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0001]\n1. Install the argparser library (https://cran.r-project.org/web/packages/argparser/[href=https://cran.r-project.org/web/packages/argparser/]) with install_packages(\"argparser\") and parse command line arguments from Perseus.\n         \nargv <- commandArgs(trailingOnly=TRUE)\nlibrary(\"argparser\")\np <- arg_parser(description = \"Head processing\")\np <- add_argument(p, `input', help=\"path of the input file\")\np <- add_argument(p, `output', help=\"path of the output file\")\np <- add_argument(p, `--nrow', type=\"numeric\", default=15, help=\"the number of row\")\nargp <- parse_args(p, argv)\nThe first two arguments \"input\" and \"output\" are required arguments for storing the input and output files, respectively. An additional optional argument for the number of rows \"--nrow\" is added. Its default value is set to 15. Please refer to the argparser manual for more details.\n2. Use PerseusR to read the data in Perseus.\nIn the same was as for the scripts without parameters, PerseusR needs to be imported, and read.perseus is used for converting the matrix from Perseus to R format.\n         \nlibrary(PerseusR)\nmdata <- read.perseus(inFile)\n3. Get the main matrix of Perseus for the data processing.\nUse main() to obtain the main matrix that is needed for the following data processing.\n         \ncounts <- main(mdata)\n4. Execute the main part for data analysis or modification.\nThe information from the additional parameter was already parsed and stored. The extraction of the head of the matrix can be performed based on the number of rows that the user assigned.\n         \nmdata2 <- head(counts, n=num)",
    "aCols <- head(annotCols(mdata), n=num)\n5. Export the output matrix to Perseus with correct format.\nThis step is the same as last section. Generate matrixData() and write to Perseus by using write.perseus().\n         \nmdata2 <- matrixData(main=mdata2, annotCols=aCols, annotRows=annotRows(mdata))\nprint(paste(`writing to', outFile))\nwrite.perseus(mdata2, outFile)\n6. Apply the plugin in Perseus.\nNow the plugin is ready to be executed. The number of extracted rows can be assigned from “Additional arguments” in the pop-up window (Fig. 5B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0005]). For instance, writing “--nrow 10” in “Additional arguments,” only the first 10 rows will remain in the output matrix in Perseus.",
    "In recent years, many useful Python packages have been developed for computational biology and data visualization. Moreover, an annual conference (SciPy) provides a platform where up-to-date Python tools are released and presented. Perseuspy builds a bridge to integrate Python libraries into Perseus as plugins (Rudolph & Cox, 2019[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0016]). In this section, we provide the basic steps for generating Python-only plugins through the command line style interface. The code for this example is available at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head.py[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head.py].\nNecessary Resources\nHardware\nA computer running Windows 8 (64 bit) or higher or Windows Server 2008 or higher\n4 GB RAM minimum\nAt least a quad core processor is recommended\nSoftware\nPerseus 1.6.13 or higher: can be downloaded from https://maxquant.org/perseus[href=https://maxquant.org/perseus].\nPython: use version higher than 3.7.0. The Python executable has to be listed in the PATH environment variable of the operating system. Please refer to Troubleshooting if Perseus cannot find your Python installation, which is indicated in the command line−style interface.\nPerseuspy: available at https://github.com/cox-labs/perseuspy[href=https://github.com/cox-labs/perseuspy]. An installation guide and required dependencies can be found in the repository. Also available on PyPI (https://pypi.org/project/perseuspy/[href=https://pypi.org/project/perseuspy/]).\nPython supported editor like Visual Studio, PyCharm or Notepad++\nInput files\nThis protocol requires no extra input files. The outlined plugin works with a randomly generated matrix, which can be generated using the dice button in Perseus.\n1. Import the required packages.\n         \nimport sys\nfrom perseuspy import pd\nPerseuspy builds on top of the widely-used pandas package to handle matrix processing (Mckinney, 2010[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0012]). The nested namespace pd contains this extended version of pandas.\n2. Parse command line arguments from Perseus.\nThe communication between Perseus and Python works through temporary files containing the data, their location being specified by fixed index command line arguments. Therefore, these command line arguments sent from Perseus need to be parsed first.\n         \n_, infile, outfile = sys.argv",
    "By default, the name of the Python script occupies the first argument of sys.argv and the input and output file are always the last two arguments. Thus, the order of the arguments is: the name of Python script, input file, and output file.\n3. Read the data from Perseus.\nUsing the new pandas function read_perseus the data matrix from Perseus can be read from the input file directly into a pandas data frame object.\n         \ndf = pd.read_perseus(infile)\n4. The main custom code for data analysis or modification.\nThis part is for the custom desired data analysis. In this example, the code for extraction of the head of the matrix is placed in this position.\n         \ndf2 = df.head(15)\nBased on the code, only the first 15 rows will be kept in the matrix.\n5. Export the output matrix to Perseus with correct format.\nWhen all the steps of the data processing are done, the final matrix needs to be exported to Perseus in the correct format. For this, the second new function in pandas, to_perseus, can be used.\n         \ndf2.to_perseus(outfile)\n6. Apply the plugin in Perseus.\n         \nOpen Perseus and import the matrix or load a session.\nA random matrix is used for testing the plugin in this tutorial.\nExecute the plugin.\nIn the “Processing” block, click “External” –> “Matrix –> Python”. If the button “select” is green, it means that Perseus recognized your Python installation and perseuspy (Fig. 6A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0006]); otherwise, navigate to your python.exe or add it to your systems PATH variable. Afterwards, specify the Python script that you want to execute and click OK (Fig. 6B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0006]).",
    "For a more elaborate analysis, Python plugins can also be passed additional arguments just like R plugins. The following steps will demonstrate the steps needed for adding parameters to plugins. The example the number of rows to obtain from the top of the matrix can be specified by the user. The script is available at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head_add_argument.py[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/scripts/head_add_argument.py].\nNecessary Resources\nSame as Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0003]\nAdditionally, the package argparse needs to be installed in the Python environment\n1. Import the required packages.\n         \nimport argparse\nfrom perseuspy import pd\n2. Parse command line arguments from Perseus.\n         \nparser = argparse.ArgumentParser(\"Head processing\")\nparser.add_argument(\"input\", help=\"path of the input file\")\nparser.add_argument(\"output\", help=\"path of the output file\")\nparser.add_argument(\"--nrow\", type=int, default=15, help=\"the number of row\")\narg = parser.parse_args()\nThis part is similar to “Parse command line arguments from Perseus” in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0002]. The first two arguments \"input\" and \"output\" are positional arguments for storing the input and output files, respectively. The third argument, \"--nrow\" is for the number of rows.\n3. Read the data from Perseus.\n         \ndf = pd.read_perseus(arg.input)\n4. Retrieve the user-define arguments (--nrow) to modify the matrix.\nThe number of rows stored in \"--nrow\", can now be used for the extraction.\n         \ndf_head = df.head(arg.nrow)\n5. Export the output matrix to Perseus with correct format.\n         \ndf2.to_perseus(arg.output)\n6. Apply the plugin in Perseus.\nFor using the newly added parameter as an input, the assignment needs to be written in “Additional arguments” in the pop-up window (Fig. 6B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0006]). If “Additional arguments” is filled in with “--nrow 10”, the output matrix will be the first 10 rows.",
    "Even better integrated plugins with an automatically generated graphical user interface for the parameters can be generated when using C#, which is the original programming language of Perseus. The architecture of Perseus plugins is systematic and well structured. Numerous C# plugins can be found at https://github.com/JurgenCox/perseus-plugins[href=https://github.com/JurgenCox/perseus-plugins]. All the scripts can be recycled and modified by users. The same basic example as in the previous sections will be used to explain how to generate a C# plugin. The script of the example can be seen at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_c_sharp.cs[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_c_sharp.cs].\nNecessary Resources\nHardware\nA computer running Windows 8 (64 bit) or higher, or Windows Server 2008 or higher\n4 GB RAM minimum\nAt least a quad core processor is recommended\nSoftware\nPerseus 1.6.13 or higher: can be downloaded from https://maxquant.org/perseus[href=https://maxquant.org/perseus]\nFor editing C# code, Visual Studio Community Edition is recommended (https://www.visualstudio.com/downloads/[href=https://www.visualstudio.com/downloads/]). Please select the “.Net Desktop Development workflow” in the installer to install everything required. To ensure version compatibility, please use .NET Framework <= 4.7.2 or .NET Core <= 2.1.\n.NET packages BaseLibS and PerseusAPI: Both of these can be installed by using “Manage NuGet Packages” in Visual Studio, which is explained in step 2 of the protocol\n1. Create a C# project.\nDue to the internal connection between the plugin and Perseus, the project name should use “Plugin” as prefix and the type of project should be “Class Library (.NET framework).” In this demonstration, the Project name was set as “PluginTutorial”.\n2. Add the dependencies.\nPerseusAPI and BaseLibS need to be installed for generating plugins. For installation of these two packages, right-click on the “PluginTutorial” solution and choose “Manage NuGet Packages….” Afterwards, search for PerseusApi in the “Browse” tab and install it for “PluginTutorial”. The PerseusAPI and its dependency BaseLibS will be added.\n3. Import packages and define namespace with a class.",
    "In the Class1.cs file, remove all default packages and code generated by Visual Studio, and instead import the packages as shown here:\n         \nusing System.Linq;\nusing BaseLibS.Graph;\nusing BaseLibS.Param;\nusing PerseusApi.Document;\nusing PerseusApi.Generic;\nusing PerseusApi.Matrix;\nnamespace PluginTutorial\n{\n public class PluginHead : IMatrixProcessing\n {\n }\n}\nThe project name (PluginTutorial) should be placed in namespace, and the user-defined class (PluginHead) should inherit IMatrixProcessing, which is created for processing the matrix from Perseus.\n4. Generate basic structure of the C# plugin.\nTo make IMatrixProcessing work, a number of methods and variables need to be implemented.\n         \nnamespace PluginTutorial\n{\n public class PluginHead : IMatrixProcessing\n {\n public bool HasButton => false;\n public string Description => \"extract the header of the matrix.\";\n public string HelpOutput => \"extract the header of the matrix.\";\n public string[] HelpSupplTables => new string[0];\n public int NumSupplTables => 0;\n public string Name => \"Head CS only\";\n public string Heading => \"Tutorial\";\n public float DisplayRank => 6;\n public string[] HelpDocuments => new string[0];\n public int NumDocuments => 0;\n public string Url => null;\n public Bitmap2 DisplayImage => null;\n public bool IsActive => true;\n public int GetMaxThreads(Parameters parameters)\n {\n  return 1;\n }\n public void ProcessData(IMatrixData mdata, Parameters param, ref\n IMatrixData[] supplTables,\n ref IDocumentData[] documents, ProcessInfo processInfo)\n {\n }\n public Parameters GetParameters(IMatrixData mdata, ref string errorString)\n {\n }\n }\n}",
    "To customize the plugin, the modification of several parameters and methods is required. Name defines the name of the plugin as it will appear in Perseus (Fig. 7A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]). Heading defines the name of the drop-down menu the plugin will be added to (Fig. 7A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]). If the name of the menu does not yet exist, a new one will be created automatically without requiring further changes in other places. Optional parameter changes are the following: the Description of the plugin, which will be shown when hovering over the plugin in Perseus (Fig. 7A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]); the Url of the plugin's documentation, which can be opened by clicking the ghost icon besides the “OK” button (Fig. 7B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]); and DisplayImage, which is the icon appearing next to the plugin name in the menu. If more threads need to be used for the plugin, it can be changed in GetMaxThread. The code for actual data processing should be placed inside ProcessData. The additional input parameters required are defined in Parameters. The other parameters defined in the code above are not relevant for custom-generated plugins, but need to be defined for the class to be compiled successfully.\n5. Add parameters.\nThe method GetParameters returns a C# object (Parameters) containing all the parameters that the user has to provide in the interface.\n         \npublic Parameters GetParameters(IMatrixData mdata, ref string errorString)\n{\n return new Parameters(new IntParam(\"Number of rows\", 15)\n {\n  Help = \"The number of rows for the header needs to be kept.\"\n });\n}",
    "In this example, an integer parameter was created (IntParam). The name of the parameter is \"Number of rows,\" and the default is 15. A description of the parameter can be added in Help. This description will appear when hovering over the parameter text (Fig. 7B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]). If multiple parameters need to be added, the user just needs to add them one by one in Parameters, as shown below. A complete example can be seen at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_c_sharp_two_params.cs[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_c_sharp_two_params.cs].\n         \npublic Parameters GetParameters(IMatrixData mdata, ref string errorString)\n{\n return new Parameters(new IntParam(\"Number of rows\", 15)\n   {Help = \"The number of rows to retain.\"},\n   new IntParam(\"Number of columns\", 2)\n   {Help = \"The number of columns to retain.\"}\n );\n}\n6. Generate the code for data processing.\nThe main data processing is defined in ProcessData. In this example, the first n rows of the matrix are extracted.\n         \npublic void ProcessData(IMatrixData mdata, Parameters param, ref IMatrixData[]\n supplTables, ref IDocumentData[] documents,\n ProcessInfo processInfo)\n{\n int lines = param.GetParam<int>(\"Number of rows\").Value;\n int[] head = Enumerable.Range(0, lines).ToArray();\n mdata.ExtractRows(head);\n}\nparam.GetParam<int>(\"Number of rows\").Value will get the value stored in the integer parameter called \"Number of rows\", which was created in GetParameters before. The other lines use this number to extract the head of the matrix. mdata is the object that stores all the information on the Perseus matrix and ExtractRows can be used to extract the rows of the matrix based on the list of indices generated from the user input.\n7. Compile the plugin and copy the dll.",
    "Since C# is a compiled language, the next step is to build the project, which will generate a .dll file. If the build was successful, PluginTutorial.dll will be saved in the “bin/Debug” folder of the project directory, which you can open by right-clicking the project in the Solution Explorer –> “Open Folder in File Explorer” (PluginTutorial\\bin\\Debug, Fig. 7C[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]). For adding the newly created plugin to Perseus, this dll must be copied to the “bin” folder of Perseus (Perseus/bin, Fig. 7D[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]). Afterwards, the plugin can be used in Perseus after a re-start (Fig. 7A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007] and 7B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]).\n8. Apply the plugin in Perseus.\n         \nOpen Perseus and import the matrix or open a session.\nA random matrix is used for testing the plugin in this tutorial.\nExecute the plugin.\nClick “Tutorial” –> “Head CS only” in “Processing” block (Fig. 7A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]). Then, specify the number of rows for extraction and click OK (Fig. 7B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0007]).\nResource for C# Plugins\nFor more examples and source codes of C# plugins, please check the repository: https://github.com/JurgenCox/perseus-plugins[href=https://github.com/JurgenCox/perseus-plugins].",
    "Although C# can generate a user-friendly interface for the plugins, R and Python packages are still not able to be integrated into Perseus with the native C# interface. To combine the flexibility of R and Python with the graphical user interface generated by C#, the C# package PluginInterop was created (Rudolph & Cox, 2019[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0016]). Here, the basic methods of PluginInterop needed to create an R plugin with C# interface will be presented step by step. The R script can be found at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/head_c_sharpR.R[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/head_c_sharpR.R], and the C# script at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_with_r.cs[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_with_r.cs].\nNecessary Resources\nAll requirements of Basic Protocols 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0001] and 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005]\nAdditionally, the C# package PluginInterop is required: this can also be installed by using “Manage NuGet Packages” in a Visual Studio project as described in step 2.\n1. Create a C# project.\nSee step 1 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005].\n2. Add the dependencies.\nBesides PerseusAPI and BaseLibS, PluginInterop also needs to be installed. The steps are the same as step 2 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005]. Right-click on you project solution (PluginTutorial) and choose “Manage NuGet Packages….”, then search for PluginInterop in the “Browse” tab and install it to your project solution.\n3. Import packages and define namespace with a class.\nSince PluginInterop is the bridge between R and C#, it needs to be used in the wrapper. Additionally, the R script needs to be placed into the resource folder of the project (will be descripted at step 6). Thus, PluginTutorial.Properties needs to be used as well.\n         \nusing BaseLibS.Param;\nusing PerseusApi.Matrix;\nusing System.IO;\nusing PluginInterop;\nusing System.Text;\nusing PluginTutorial.Properties;\nnamespace PluginTutorial\n{\n public class HeadR : PluginInterop.R.MatrixProcessing\n {\n }\n}\nHere, the class HeadR inherits from PluginInterop.R.MatrixProcessing, which is the method for managing the matrix and parameter transfer between C# and the R script.\n4. Override methods in the class.",
    "PluginInterop.R.MatrixProcessing is a template for generating a C# plugin that can connect to R. For applying it to a user-specific project, some methods and variables need to be overridden.\n         \npublic class HeadR : PluginInterop.R.MatrixProcessing\n{\n public override string Heading => \"Tutorial\";\n public override string Name => \"Head with R\";\n public override string Description => \"extract the header of the matrix\";\n protected override bool TryGetCodeFile(Parameters param, out string\n codeFile)\n {\n   byte[] code = (byte[])Resources.ResourceManager.GetObject(\"head_c_sharpR\");\n   codeFile = Path.GetTempFileName();\n   File.WriteAllText(codeFile, Encoding.UTF8.GetString(code));\n   return true;\n }\n protected override string GetCommandLineArguments(Parameters param)\n {\n   var tempFile = Path.GetTempFileName();\n   param.ToFile(tempFile);\n   return tempFile;\n }\n protected override Parameter[] SpecificParameters(IMatrixData mdata, ref string errString)\n {\n   if (mdata.ColumnCount < 3)\n   {\n   errString = \"Please add at least 3 main columns to the matrix.\";\n   return null;\n  }\n  return new Parameter[]\n  {\n   new IntParam(\"Number of rows\", 15)\n   {\n   Help = \"The number of rows for the header needs to be kept.\"\n   }\n  };\n }\n}\nHeading, Name and Description should be changed to match the needs of the project (the details of these methods were mentioned at step 4 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005]). TryGetCodeFile() is for getting the R script from the project resources. The only thing that needs to be edited here is the name of the R script in (byte[])Resources.ResourceManager.GetObject(), omitting the file extension (head_c_sharpR). GetCommandLineArguments() will convert the parameters specified at SpecificParameters() and filled in by the user to a temporary file which can be read inside the R script. This method definition does not require further editing. SpecificParameters() is similar to GetParameters(), which was introduced at step 5 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005]. It needs to return an array of parameter definitions, which will be used to generate the interface. For definition of several parameters please refer to Support Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0007], which shows a more advanced example.",
    "5. Generate R script for data processing.\nAt this point, the C# side of the interface has been established. Next, the R code for the actual data processing is added. The code is very similar to the script presented in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0002]. The only difference is that the additional parameters are transferred as one file from the C# interface, rather than as individual arguments. The order of the command line arguments is now parameter file, input file and output file.\n         \nargs = commandArgs(trailingOnly = TRUE)\nparamFile <- args[1]\ninFile <- args[2]\noutFile <- args[3]\nAfterwards, the user input has to be extracted by a function called “parseParameters” and several type-specific functions like intParamValue(), or boolParamValue(). Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-tbl-0001] summarizes the most commonly used functions and their C# counterparts. In this demonstration, the type of the parameter is integer and the name is “Number of rows.”\n         \nparameters <- parseParameters(paramFile)\nnum_row <- intParamValue(parameters, `Number of rows')\nThe remainder of the R script is the same as in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0002].\n6. Store R script to resource folder.\nAs mentioned in steps 2 and 3, the R script needs to be placed in the resource folder of the C# project. To do so follow these steps:\n         \nRight-click “Properties” under the project (PluginTutorial) in Visual Studio.\nClick “Resources.”\nClick “Add Resource” and navigate to the target R script (head_c_sharpR.R). Then save it.\n7. Build the solution and place the required files to the bin folder of Perseus.",
    "Just as with a C#-only plugin, the code needs to be compiled and moved to the Perseus bin folder. Please refer to step 7 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005] for this. The only difference is that the .pdb file also has to be transferred, as it contains the R script. Thus, PluginTutorial.dll and PluginTutorial.pdb need to be copied. The plugins can be used after re-starting Perseus (Fig. 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0001]).",
    "UMAP (Becht et al., 2019[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0002]; McInnes, Healy, & Melville, 2018[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0011]) is a powerful dimensionality-reduction algorithm that is widely used for many different studies. It will be extremely useful to add UMAP to Perseus. This section will take UMAP as an advanced example to demonstrate how powerful the new Perseus plugin interface is for data analysis. The C# script can be found at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/UmapAnalysis_with_r.cs[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/UmapAnalysis_with_r.cs], and the R script is saved at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/Umap_R.R[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/Umap_R.R].\nNecessary Resources\nAll of the resources listed in Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006]\nUMAP: a dimensionality-reduction method. The R version of UMAP can be found at CRAN (https://cran.r-project.org/web/packages/umap/index.html[href=https://cran.r-project.org/web/packages/umap/index.html])\nInput files\nThe samples for the example of UMAP analysis can be downloaded at PRIDE (PXD003710) (Bailey, McDevitt, Westphall, Pagliarini, & Coon, 2014[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0001]). Additionally, the MaxQuant (Cox & Mann, 2008[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0005]; Sinitcyn, Rudolph, & Cox, 2018[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0017]; Tyanova, Temu, & Cox, 2016[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0020]; Yu, Kiriakidou, & Cox, 2020[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0023]) proteinGroup table of this dataset is also provided at https://github.com/JurgenCox/perseus-plugin-programming/tree/master/dataset[href=https://github.com/JurgenCox/perseus-plugin-programming/tree/master/dataset]. The values are normalized and transformed by logarithm, and the unreliable protein groups (reversed, only identified by site, contaminant, containing more than 30% missing values) are all removed from the table. Moreover, the data is well annotated by experimental design. This table can be directly used for the advanced example.\n1. Create a C# project.\nPlease see step 1 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005].\n2. Add the dependencies.\nPlease see step 2 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n3. Import packages and define namespace with a class.\nPlease see step 3 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n4. Override methods in the class.\nIn general, the practical procedures are the same as in step 4 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006]. The only requirement is to modify several methods and variables to match this example. First, the Head, Name, and Description need to be changed.\n         \npublic override string Heading => \"Tutorial\";",
    "public override string Name => \"Umap analysis with R\";\npublic override string Description => \"Applying Umap to cluster the data\";\nSecondly, the R script of UMAP analysis has to be assigned properly.\n         \nbyte[] code = (byte[])Resources.ResourceManager.GetObject(\"Umap_R\");\nThird, all the parameters should be added to SpecificParameters() one by one with their corresponding data type.\n         \nprotected override Parameter[] SpecificParameters(IMatrixData mdata, ref string errString)\n{\n if (mdata.ColumnCount < 3)\n {\n  errString = \"Please add at least 3 main data columns to the matrix.\";\n  return null;\n  }\n return new Parameter[]\n {\n  new IntParam(\"Number of neighbors\", 15)\n  {\n      Help = \"The number of neighbors.\"\n  },\n  new IntParam(\"Number of components\", 2)\n  {\n      Help = \"The number of components.\"\n  },\n  new IntParam(\"Random state\", 1)\n  {\n      Help = \"Set seed for reproducibility.\"\n  },\n  new DoubleParam(\"Minimum distance\", 0.1)\n  {\n      Help = \"Set minimum distance between the data point.\"\n  },\n  new SingleChoiceParam(\"Metric\")\n  {\n      Values= new[] { \"euclidean\", \"manhattan\", \"cosine\", \"pearson\",\"pearson2\"},\n      Help = \"The method of metric for doing clustering.\"\n  }\n };\n}\nThe structure of SingleChoiceParam() is different from IntParam() or DoubleParam(). SingleChoiceParam() has to contain an array called Values to store all the options for the users. The first element of Values is the default one, which will appear on the dropdown list of the Perseus plugin.\n5. Generate R script for data processing.\nThe basic rules for generating an R script are the same as in step 5 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006]. Hence, the most important thing is to obtain the information of parameters from C#. The other parts of the R script can be done like normal R programming and are not shown here.\n         \nargs = commandArgs(trailingOnly = TRUE)\nparamFile <- args[1]\ninFile <- args[2]\noutFile <- args[3]\nparameters <- parseParameters(paramFile)\nn_neighbor <- intParamValue(parameters, \"Number of neighbors\")\nn_component <- intParamValue(parameters, \"Number of components\")",
    "seed <- intParamValue(parameters, \"Random state\")\nmetric <- singleChoiceParamValue(parameters, \"Metric\")\nm_dist <- intParamValue(parameters, \"Minimum distance\")\nintParamValue() can also be used to receive the value with the double-precision data type because R can handle the conversion at the first assignment of the variables.\n6. Store R script to resource folder.\nPlease see step 6 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n7. Build the solution and place the required files to the bin folder of Perseus\nPlease see step 7 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n8. Run UMAP and plot the result.\nIn this section, the dataset from Bailey, D. J., et al. will be applied to test the newly developed plugin of UMAP (Bailey et al., 2014[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0001]).\n         \nOpen Perseus and load proteinGroup.txt.\nSince proteinGroup.txt is already pre-processed and grouped, it can be directly loaded into Perseus by clicking the green icon of arrow in the block of “Load.”\nRun R plugin of UMAP.\nClick “Tutorial” −> “Umap analysis with R” to specify the parameters and run the plugin (Fig. 2A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0002] and 2B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0002]). After running the plugin of UMAP, the matrix will be transposed and the main values will be changed to components.\nPlot the result of UMAP.\nUse scatter plot (with columns) to view the result of the UMAP analysis. The outcome shows that the data points are clustered based on cell types (Fig. 2C[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0002]).\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/77385475-46ea-4a8e-a862-73bdb5fc5ca4/cpbi105-fig-0002-m.jpg</p>\nFigure 2\nC# + R plugin for running UMAP analysis. (A) Menu item for running UMAP plugin. The pop-up window with the arguments of the plugin is presented in (B). (C) Shows the results of UMAP analysis in a scatter plot in Perseus.",
    "This protocol will continue to demonstrate how to generate Python plugins with C# interface using the same examples as Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006]. The C# script of the basic example can be found at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_with_py.cs[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Head_with_py.cs], and the Python code can be found at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/head_c_sharpPy.py[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/head_c_sharpPy.py].\nNecessary Resources\nAll requirements of Basic Protocols 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0003] and 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005]\nAdditionally, the C# package PluginInterop is required: this can also be installed by using “Manage NuGet Packages” in a Visual Studio project as described in step 2\n1. Create a C# project.\nPlease see step 1 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005].\n2. Add the dependencies.\nPlease see step 2 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n3. Import packages and define namespace with a class.\nThe only difference between this step and step 3 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006] is that the inheritance has to be edited for connecting Python instead of R to C#.\n         \npublic class HeadPy : PluginInterop.Python.MatrixProcessing\nLike PluginInterop.R.MatrixProcessing, PluginInterop.Python.MatrixProcessing is for managing the matrix of Perseus and the communication between Python and C#. Of course, the name of the class can be changed as well (from HeadR to HeadPy).\n4. Override methods in the class.\nThe majority of the code is the same as step 4 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006]. Only several commands need to be modified to match the needs of integrating the Python script.\n         \npublic override string Heading => \"Tutorial\";\npublic override string Name => \"Head with Python\";\npublic override string Description => \"extract the header of the matrix\";\nprotected override bool TryGetCodeFile(Parameters param, out string codeFile)\n{\n byte[] code = (byte[])Resources.ResourceManager.GetObject(\n          \"head_c_sharpPy\");\n codeFile = Path.GetTempFileName();\n File.WriteAllText(codeFile, Encoding.UTF8.GetString(code));\n return true;\n}\nBased on the above code, Heading, Name and Description were changed from R to Python. Additionally, the name of Python script was assigned to (byte[])Resources.ResourceManager.GetObject().\n5. Generate Python script of data processing.",
    "For the basic principles of generating Python plugins, please refer to Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0003]. In order to gain the information about the parameters assigned through the C# interface, a variable needs to be created for receiving the file storing the parameter values.\n         \n_, paramfile, infile, outfile = sys.argv\nparse_parameters() is a function for parsing the parameters from the parameter file. Based on different data types, all the values of parameters can be used for the Python script by applying corresponding functions like intParam(). Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-tbl-0001] summarizes the most commonly used functions and their C# counterparts.\n         \nparameters = parse_parameters(paramfile)\nhead = intParam(parameters, \"Number of rows\")\n6. Store Python script to resource folder.\nPlease see step 6 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n7. Build the solution and place the required files to the bin folder of Perseus\nPlease see step 7 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\nIf all the procedures are done, the plugin will be shown in Perseus (Fig. 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0003])\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/cf3c6bda-6ba6-4143-9a93-3014d4e63a2e/cpbi105-fig-0003-m.jpg</p>\nFigure 3\nC# + Python plugin in Perseus. (A) Menu item for running C# + Python plugin. The pop-up window containing the parameters of the plugin is shown in (B).",
    "Since UMAP is also available in Python, the same analysis can be used as an advanced example to show the power of Perseus Plugins for data analysis. The C# and Python scripts are listed at https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/UmapAnalysis_with_py.cs[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/UmapAnalysis_with_py.cs], and https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/Umap_Py.py[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/PluginTutorial/Resources/Umap_Py.py], respectively.\nNecessary Resources\nAll of the requirements listed in Basic Protocol 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0008].\nUMAP: a dimensionality-reduction method. The Python version of UMAP can be found at PyPI (https://pypi.org/project/umap-learn/[href=https://pypi.org/project/umap-learn/]).\nInput files\nSame as Support Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0007]\n1. Create a C# project.\nPlease see step 1 of Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0005].\n2. Add the dependencies.\nPlease see step 2 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n3. Import packages and define namespace with a class.\nPlease see step 3 of Basic Protocol 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0008].\n4. Override methods in the class.\nThe most important thing is to specify the correct names of plugin and Python script.\n         \npublic override string Heading => \"Tutorial\";\npublic override string Name => \"Umap analysis with Python\";\npublic override string Description => \"Applying Umap to cluster the data\";\nprotected override bool TryGetCodeFile(Parameters param, out string codeFile)\n{\n byte[] code = (byte[])Resources.ResourceManager.GetObject(\"Umap_Py\");\n codeFile = Path.GetTempFileName();\n File.WriteAllText(codeFile, Encoding.UTF8.GetString(code));\n return true;\n}\n5. Generate Python script for data processing.\nSince this part of data processing will be done in Python script, all the parameters need to be transferred to Python variables.\n         \nn_neighbor = intParam(parameters, \"Number of neighbors\")\nn_component = intParam(parameters, \"Number of components\")\nseed = intParam(parameters, \"Random state\")\nm_dist = doubleParam(parameters, \"Minimum distance\")\nmetric = singleChoiceParam(parameters, \"Metric\")",
    "As in step 5 of Support Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0007], intParam() can be used for handling the double-precision data type because Python can automatically adjust for the conversion. Additionally, the Perseus matrix has to be transposed due to the input format of UMAP. Therefore, the category rows need to be extracted for the modification as well. Similar to annotRows in PerseusR, read_annotation can return a matrix containing all category rows.\n         \nannotations = read_annotations(infile)\nFurthermore, Perseuspy has a function called main_df(), which is similar to main() in PerseusR, for extracting the main matrix in Perseus. Based on this, only the values of the main matrix will be used for the UMAP analysis, which is not shown here.\n         \nnewDF1 = main_df(infile, df)\n6. Store Python script to resource folder.\nPlease see step 6 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n7. Build the solution and place the required files in the bin folder of Perseus\nPlease see step 6 of Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0006].\n8. Run UMAP and plot the results.\nPlease see step 8 of Support Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0007]. Figure 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0004] shows the outcome of the plugin and the results of UMAP with the data points grouped based on cell types.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/eddc7107-4b73-494e-b773-c872c8d4e312/cpbi105-fig-0004-m.jpg</p>\nFigure 4\nC# + Python plugin for running UMAP analysis. (A) Highlights the menu item for running the UMAP plugin. The pop-up window including the arguments of the plugin is presented in (B). (C) Shows the results of UMAP analysis in a scatter plot.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/746bd63a-1767-412f-80e9-a66466d9a6a1/cpbi105-fig-0005-m.jpg</p>\nFigure 5\nR plugin in Perseus. (A) The labeled menu item is for running an R plugin from an external script. (B) Popup window for specifying the path of the script and additional parameters of the plugin.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/3d232650-b7f7-44f3-a474-e0cc41c559b2/cpbi105-fig-0006-m.jpg</p>\nFigure 6",
    "Python plugin in Perseus. (A) The labeled menu item is for running a Python plugin from an external script. (B) Popup window for specifying the path of the script and additional parameters of the plugin.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/d301a265-5bbd-4b58-bb71-0d47427554fb/cpbi105-fig-0007-m.jpg</p>\nFigure 7\nC# plugin in Perseus. (A) The labeled menu item is for running a C# plugin. The description specified in the C# code is shown when the mouse hovers over it. (B) The popup window for specifying the values of parameters. The explanation specified in the script is displayed when hovering with the mouse. For adding plugins in Perseus, the selected files in (C) (the folder of $PROJECT_NAME/bin/Debug) need to be copied to the folder in (D) (Perseus/bin).",
    "Based on the above protocols, Perseus plugins can be generated according to the user's needs. In order to demonstrate the benefits that Perseus can offer for data analysis, a basic workflow for the analysis of label-free quantification (LFQ) will be presented in this section. The UMAP plugin generated via Support Protocols 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0007] and 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0009] can be applied to this analysis. The samples are from a part of the dataset in a Proteome Informatics Research Group (iPRG) 2015 Study (Choi et al., 2017[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-bib-0003]). The proteinGroup table used for this example can be downloaded from https://github.com/JurgenCox/perseus-plugin-programming/blob/master/dataset/proteinGroups_LFQ.txt[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/dataset/proteinGroups_LFQ.txt].\nNecessary Resources\nAll of the requirements listed in Basic Protocol 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0008] and Support Protocol 5[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-prot-0009]\nInput files\nproteinGroups_LFQ.txt from https://github.com/JurgenCox/perseus-plugin-programming/blob/master/dataset/proteinGroups_LFQ.txt[href=https://github.com/JurgenCox/perseus-plugin-programming/blob/master/dataset/proteinGroups_LFQ.txt]. This dataset contains three samples named as 1, 2, and 3. Moreover, each sample has three technical replicates labeled as A, B, and C.\nThe workflow, plugins, and settings for the basic analysis are shown in Figure 8[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0008]. The results of most commonly used statistics methods–differential expression analysis (ANOVA test is used) and dimensionality reduction (UMAP is applied) are presented in Figure 9[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0009] and 10[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpbi.105#cpbi105-fig-0010]. This example only demonstrates a basic workflow. Perseus contains numerous useful plugins and parameters. The user can change the settings based on different requirements.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/eb71ed74-7715-4724-a23e-946f79cd71c5/cpbi105-fig-0008-m.jpg</p>\nFigure 8\nWorkflow and settings of a basic analysis. The rectangle blocks represent the steps for the analysis. The blue paths are the plugins used for the steps. The green statements are the settings that need to be changed and results of the plugins; the rest of the parameters can remain as the default.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/72514129-032f-4cec-9187-e92e08fd4f4e/cpbi105-fig-0009-m.jpg</p>\nFigure 9\nVolcano plots of the example LFQ dataset. (A, B, and C) show the volcano plots of sample 1 versus 2, sample 1 versus 3, and sample 2 versus 3, respectively. The red squares represent the differential expressed proteins.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/ed6b1761-8d91-4e96-a3bd-19970388e7bb/cpbi105-fig-0010-m.jpg</p>",
    "Figure 10\nUMAP plot of the example LFQ dataset. The blue, red, and green squares represent the sample 1, 2, and 3, respectively."
  ],
  "subjectAreas": [
    "Bioinformatics"
  ],
  "bigAreas": [
    "Bioinformatics & Computational Biology"
  ]
}