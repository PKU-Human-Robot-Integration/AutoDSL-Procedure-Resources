{
  "id": 4117,
  "origin_website": "Cell",
  "title": "Protocol for executing and benchmarking eight computational doublet-detection methods in single-cell RNA sequencing data analysis",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nInstall DoubletCollection\nTiming: 20–30 min\nInstall the DoubletDetection package in R\nDoubletCollection is an R package that integrates the installation, execution, and benchmark of eight doublet-detection methods. The source code and documentation of DoubletDetection are available at https://github.com/xnnba1984/DoubletCollection[href=https://github.com/xnnba1984/DoubletCollection]. To install DoubletDetection, execute the following R code.\nif(!require(devtools)){\n  install.packages(\"devtools\")\n}\ndevtools::install_github(\"xnnba1984/DoubletCollection\")\nNote: DoubletCollection automatically installs eight doublet-detection methods: Scrublet (Wolock, Lopez, and Klein 2019[href=https://www.wicell.org#bib17]), doubletCells (Lun, McCarthy, and Marioni 2016[href=https://www.wicell.org#bib13]), scds (Bais and Kostka 2019[href=https://www.wicell.org#bib1]) (including cxds, bcds, and hybrid), DoubletDetection (Gayoso and Shor 2019[href=https://www.wicell.org#bib7]), DoubletFinder (McGinnis, Murrow, and Gartner 2019[href=https://www.wicell.org#bib15]), and scDblFinder (Germain, Sonrel, and Robinson 2020[href=https://www.wicell.org#bib8]). It also installs other packages required for downstream analysis and visualization.\nOptional: Solo (Bernstein et al., 2020[href=https://www.wicell.org#bib2]) is a doublet-detection method implemented as a Linux command-line tool. DoubletCollection does not include this method. The installation and execution of Solo are available at https://github.com/calico/solo[href=https://github.com/calico/solo].\nDoublet detection accuracy on real scRNA-seq datasets\nTiming: 6–8 h\nThis section illustrates how to apply DoubletCollection to 16 real scRNA-seq datasets, calculate the detection accuracy, and visualize the result.\nCalculate doublet scores\nEvery doublet-detection method in DoubletCollection outputs a doublet score for each droplet in the dataset. The larger the doublet score is, the more likely the droplet is a doublet. The following R code calculates doublet scores of user-specified methods on 16 real datasets.\nlibrary(DoubletCollection)\n# read 16 datasets in the directory specified by the path parameter\n    data.list <- ReadData(path = \"directory/real_datasets\") # Do not directly\n    # copy this line (“directory” is where “real_datasets.zip” is downloaded\n    # and uncompressed)\n    count.list <- data.list$count\n# transform doublet annotations to 0/1\n    label.list <- lapply(data.list$label, FUN = function(label){\n    ifelse(label == 'doublet', 1, 0)\n  })\n    methods <- c('doubletCells','cxds','bcds','hybrid','scDblFinder', 'Scrublet','DoubletDetection','DoubletFinder')\n    # calculate doublet scores\n    score.list.all <- FindScores.All(count.list, methods)",
    "Note: In function ReadData, users need to set the path parameter to the directory where they save datasets. Suppose that the local directory of 16 real datasets is “F:\\Dropbox\\doublet\\package\\real_datasets” on a Windows machine (Figure 2[href=https://www.wicell.org#fig2]A). To read these datasets, users need to execute\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/882-Fig2.jpg\nFigure 2. The illustration of using the function ReadDate\n(A) The local directory where 16 read datasets are located.\n(B) The R list with 16 real datasets after executing the function ReadData.\ndata.list <- ReadData(path = \"F:/Dropbox/doublet/package/real_datasets\")\n(If users need to find the directory path, they may drag the directory folder to the R console, and the path will show up.) After execution, data.list will be a list that contains 16 datasets (Figure 2[href=https://www.wicell.org#fig2]B). Users do not necessarily need to download all 16 datasets to run the test. Instead, users can save a subset of those datasets in a directory and just set the path parameter to the path of that directory. Users can also choose doublet-detection methods by modifying the methods vector.\nIf methods includes 'DoubletFinder', a plot (about hyperparameter search) would be automatically generated by the DoubletFinder method.\nCalculate the area under the precision-recall curve (AUPRC) and the area under the receiver operating characteristic curve (AUROC)\nDoublet detection is essentially a binary classification problem. Therefore, AUPRC and AUROC are appropriate for evaluating the overall doublet-detection accuracy. The following R code calculates AUPRC and AUROC based on the doublet scores.\nauprc.list.all <- FindAUC.All(score.list.all, label.list, 'AUPRC')\nauroc.list.all <- FindAUC.All(score.list.all, label.list, 'AUROC')\nVisualize overall doublet-detection accuracy\nWe used boxplots to visualize the distributions of AUPRC and AUROC values of every doublet-detection method on the 16 real scRNA-seq datasets. The following R code outputs Figure 3[href=https://www.wicell.org#fig3]A.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/882-Fig3.jpg\nFigure 3. Evaluation of doublet-detection methods using 16 real scRNA-seq datasets",
    "(A) AUPRC and AUROC values of each method applied to 16 datasets.\n(B) Precision, recall, and TNR values of each method under the 10% identification rate. Methods are ordered by their average performance measurement across 16 datasets (low to high).\n# transform the output of FindAUC.All to a data frame for visualization\nresult.auprc <- ListToDataframe(auprc.list.all, 'boxplot')\nresult.auroc <- ListToDataframe(auroc.list.all, 'boxplot')\nNote: Users can save data frames result.auprc and result.auroc to compare the AUPRC and AUROC values of doublet-detection methods.\n# visualize AUPRC and AUROC by boxplots\n# save each plot to a file in the current working directory\nPlot_Boxplot(result.auprc, 'AUPRC', save=T, name = 'AUPRC_real.png', path = getwd())\nPlot_Boxplot(result.auroc, 'AUROC', save=T, name = 'AUROC_real.png', path = getwd())\nNote: Users can save each plot to the local directory by setting the save parameter to “T.”\nCalculate precision, recall, and true negative rate (TNR) under specific identification rates\nIn practice, doublets are identified based on a single threshold. To accommodate this scenario, we examined the detection accuracy of doublet-detection methods under a specific identification rate x%. For each method and each dataset, we identified the top x% droplets with the highest doublet scores as doublets. Then we calculated the corresponding precision, recall, and TNR. The following R code calculates precision, recall, and TNR under a 10% identification rate.\n# call doublets based on a 10% doublet rate\n  doublet.list.all <- FindDoublets.All(score.list.all, rate=0.1)\n# calculate precision, recall, and TNR of identified doublets\n  precision.list.all <- FindACC.All(doublet.list.all, label.list, 'precision')\n  recall.list.all <- FindACC.All(doublet.list.all, label.list, 'recall')\n  tnr.list.all <- FindACC.All(doublet.list.all, label.list, 'TNR')\nOptional: Users can calculate the precision, recall, and TNR under varying doublet rates to conduct a more comprehensive comparison of doublet-detection methods.\nVisualize precision, recall, and TNR under specific identification rates",
    "Again, we used boxplots to visualize the distributions of precision, recall, and TNR values of each method under specific identification rates. The following R code outputs Figure 3[href=https://www.wicell.org#fig3]B.\n# transform the output of FindACC.All to a data frame for visualization\nresult.precision <- ListToDataframe(precision.list.all, 'boxplot')\nresult.recall <- ListToDataframe(recall.list.all, 'boxplot')\nresult.tnr <- ListToDataframe(tnr.list.all, 'boxplot')\nNote: Users can save data frames result.precision, result.recall, and result.tnr to compare the precision, recall, and TNR values of doublet-detection methods.\n# visualize precision, recall, and TNR by boxplots\n  # save each plot to a file in the current working directory\n  Plot_Boxplot(result.precision, 'Precision', save=T, name = 'precision.png', path = getwd())\n  Plot_Boxplot(result.recall, 'Recall', save=T, name = 'recall.png', path = getwd())\n  Plot_Boxplot(result.tnr, 'TNR', save=T, name = 'TNR.png', path = getwd())\nNote: Users can save each plot to the local directory by setting the save parameter to T.\nHyperparameter tuning for doublet-detection methods\nTiming: 3–4 h\nThe previous R code sets the hyperparameters of doublet-detection methods to their recommended or default values. This section explains how to use DoubletCollection to search for the hyperparameters that may potentially improve the doublet-detection methods’ performance.\nSearch for optimal hyperparameters\nWe set up a series of hyperparameter values and use DoubletCollection to conduct a grid search. DoubletCollection returns a combination of hyperparameters that optimizes a user-specified accuracy measure on a dataset. The following R code searches for optimal hyperparameters in terms of AUPRC for the methods Scrublet, DoubletFinder, and scDblFinder on the dataset pbmc-1A-dm.\n# read dataset\n    count <- count.list$`pbmc-1A-dm`\n    label <- label.list$`pbmc-1A-dm`\n    set.seed(2021)\n# search for optimal hyperparameters of Scrublet\n    result.parameter.Scrublet <- FindParameters(count, label, method = 'Scrublet', type = 'AUPRC', n_neighbors = c(29, 30, 31), n_prin_comps = c(30, 35, 40), min_gene_variability_pctl = c(60, 65, 70))\n# print optimal hyperparameters\n    result.parameter.Scrublet\n# search for optimal hyperparameters of DoubletFinder",
    "result.parameter.DoubletFinder <- FindParameters(count, label, method = 'DoubletFinder', type = 'AUPRC', nfeatures = c(1000, 1500, 2000), PCs = c(10, 15, 20))\n# print optimal hyperparameters\n      result.parameter.DoubletFinder\n# search for optimal hyperparameters of scDblFinder\n    result.parameter.scDblFinder <- FindParameters(count, label, method = 'scDblFinder', type = 'AUPRC', nf=c(500, 1000, 1500), includePCs=c(5, 6, 7), max_depth=c(4, 5, 6))\n# print optimal hyperparametersresult.parameter.scDblFinder\nNote: The optimal hyperparameter found by scDblFinder is stored in result.parameter.scDblFinder. For the purpose of testing the code, users may reduce the number of candidate values for each parameter. Users can search for optimal hyperparameters of other doublet-detection methods on any datasets. The searchable hyperparameters of a doublet-detection method can be shown by executing ?FindParameters.\nAdjust hyperparameters for doublet-detection methods\nThe optimal hyperparameters found from a representative dataset provide guidance for applying a doublet-detection method to similar datasets. The following R code sets the hyperparameters of three doublet-detection methods, which are to be applied to the dataset pbmc-1B-dm, to their optimal values found from the dataset pbmc-1A-dm. These two datasets share the same cell types and experimental protocol.\nscore.list <- FindScores(count = count.list$`pbmc-1B-dm`, methods = c('Scrublet','DoubletFinder','scDblFinder'), n_neighbors=29, min_gene_variability_pctl=60, n_prin_comps=40, nfeatures=1000, PCs=10, nf=500, includePCs=6, max_depth=4)\nNote: All adjustable hyperparameters can be found by executing ?FindScores or ?FindScores.All. Users can also adjust hyperparameters based on their prior knowledge. The R code in the following sections uses the recommended or default hyperparameter values of doublet-detection methods.\nDoublet detection accuracy on synthetic scRNA-seq datasets under various experimental settings and biological conditions\nTiming: 8–10 h\nThis section illustrates how to apply DoubletCollection to synthetic scRNA-seq datasets under a wide range of experimental settings and biological conditions, calculate the detection accuracy of doublet-detection methods, and visualize the result.\nCalculate doublet scores",
    "As in the previous section, we first calculated doublet scores on synthetic datasets. The following R code calculates doublet scores on the dataset sim_rate with various doublet rates.\n# specify your directory of dataset sim_rate\n  data.list.sim <- readRDS(\"directory/synthetic_datasets/sim_rate.rds\")\n# Do not directly copy this line (“directory” is where “synthetic_datasets.zip” is downloaded and uncompressed)\n    count.list.sim <- data.list.sim$count\n    label.list.sim <- lapply(data.list.sim$label, FUN = function(label){\n      ifelse(label == 'doublet', 1, 0)\n    })\n    score.list.all.sim <- FindScores.All(count.list.sim, methods)\nNote: In function readRDS, users need to set the directory to the parent folder of synthetic_datasets. Users can read datasets sim_depth.rds, sim_type.rds, or sim_hetero.rds to calculate doublet scores under various sequencing depths, numbers of cell types, or levels of between-cell-type heterogeneity. The code in the following sections can be applied to those datasets without modification.\nCalculate AUPRC and AUROC\nSimilar to real datasets, we used AUPRC and AUROC to measure the overall detection accuracy on synthetic datasets. The following R code calculates AUPRC and AUROC based on the doublet scores obtained from the previous step.\nauprc.list.all.sim <- FindAUC.All(score.list.all.sim, label.list.sim, 'AUPRC')\nauroc.list.all.sim <- FindAUC.All(score.list.all.sim, label.list.sim, 'AUROC')\nVisualize doublet-detection accuracy under various experimental settings and biological conditions\nWe used line plots to show how the performance of each doublet-detection method changes when we varied the experimental settings and biological conditions. The following R code draws line plots for AUPRC and AUROC under varying doublet rates. Figure 4[href=https://www.wicell.org#fig4]A shows the AUPRC and AUROC values of different doublet-detection methods under different doublet rates, sequencing depths, numbers of cell types, and heterogeneity between cell types.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/882-Fig4.jpg\nFigure 4. Evaluation of doublet-detection methods using four simulation studies, and the effects of doublet detection on DE gene analysis",
    "(A) AUPRC of each method in four simulation settings: varying doublet rates (from 2% to 40% with a step size of 2%), varying sequencing depths (from 500 to 10,000 UMI counts per cell, with a step size of 500 counts), varying numbers of cell types (from 2 to 20 with a step size of 1), and 20 heterogeneity levels, which specify the extent to which genes are differentiated between two cell types.\n(B) Precision, recall, and TNR by each of three DE methods: Wilcoxon rank-sum test (wilcox), MAST, and likelihood-ratio test (bimod) after each doublet-detection method is applied to a simulated dataset; for negative and positive controls, we included the DE accuracies on the contaminated data with 40% doublets and the clean data without doublets.\n# transform the output of FindAUC.All to a data frame for visualization\n  result.auprc.sim <- ListToDataframe(auprc.list.all.sim, 'lineplot')\n  result.auroc.sim <- ListToDataframe(auroc.list.all.sim, 'lineplot')\n# visualize AUPRC and AUROC by line plots\n    # save each plot to a file in the current working directory\n    Plot_Lineplot(result.auprc.sim, 'Doublet Rate', 'AUPRC', save=T, name = 'auprc_rate.png', path = getwd())\n    Plot_Lineplot(result.auroc.sim, 'Doublet Rate', 'AUROC', save=T, name = 'auroc_rate.png', path = getwd())\nEffects of doublet detection on DE gene analysis\nTiming: 45–60 min\nThis section illustrates how to use DoubletCollection to conduct differentially expressed (DE) gene analysis. We compared the results of DE gene analysis on the contaminated dataset (with 40% doublets), the clean dataset (without doublets), and the dataset after each doublet-detection method is applied.\nDetect and remove doublets from datasets\nWe first read in the dataset sim_DE that includes the ground-truth DE genes and 40% doublets. Then we applied doublet-detection methods to obtain doublet scores. Finally, we removed the top 40% droplets that receive the highest doublet scores from each method.\n# specify your directory of dataset sim_DE",
    "data.de <- readRDS('directory/synthetic_datasets/sim_DE.rds') # Do not directly copy this line (“directory” is where “synthetic_datasets.zip” is downloaded and uncompressed)\n  score.list.de <- FindScores(data.de$count, methods)\n  doublet.list.de <- FindDoublets(score.list.de, rate=0.4)\n# add the clean data matrix to the data list\n    doublet.list.de[['Clean Data']] <- data.de$label.doublet\n# remove identified doublets\n    data.removal.list.de <- RemoveDoublets.Method(data.de$count, data.de$label.cluster, doublet.list.de)\n# add original contaminated data to the data list\n    data.removal.list.de[['Contaminated Data']] <- list(count=data.de$count, label=data.de$label.cluster)\nIdentify DE genes\nWe used the Wilcoxon rank-sum test (Fay and Proschan 2010[href=https://www.wicell.org#bib5]), MAST (Finak et al., 2015[href=https://www.wicell.org#bib6]), and likelihood-ratio test (bimod) (McDavid et al., 2013[href=https://www.wicell.org#bib14]) to identify DE genes between two cell types. The accuracy of DE gene identification is measured by precision, recall, and TNR.\n# create a data frame to save result for visualization\n  table.DE.all <- data.frame()\n# use three DE methods\n    for(DE.method in c('MAST', 'wilcox', 'bimod'))\n# identify DE genes\n    DE.list <- FindDE(data.removal.list.de, DE.method)\n# calculate precision, recall, and TNR of identified DE genes\n    DE.acc.list <- FindDEACC(DE.list, data.de$gene.de, rownames(data.de$count))\n# transform to a data frame for visualization\n    table.DE <- ListToDataframe(DE.acc.list, 'barplot')\n    table.DE[['DE_method']] <- DE.method\n    table.DE.all <- rbind(table.DE.all, table.DE)\n    }\n    \nNote: Users can choose from seven DE methods by specifying the second parameter of the function FindDE, including ‘wilcox’, ‘bimod’, ‘t’, ‘poisson’, ‘negbinom’, ‘LR’, and ‘MAST’. A detailed demonstration of those methods is available at\nhttps://satijalab.org/seurat/articles/de_vignette.html[href=https://satijalab.org/seurat/articles/de_vignette.html].\nVisualize the effects of doublet detection on DE gene analysis\nWe used barplots to compare the results of DE gene analysis on the contaminated dataset (negative control), the clean dataset (positive control), and post-doublet-detection datasets. The following R code outputs barplots that compare the precision, recall, and TNR in Figure 4[href=https://www.wicell.org#fig4]B. Each barplot stacks the results of three DE methods: Wilcoxon rank-sum test, MAST, and likelihood-ratio test (bimod).\n# save each plot to a file in the current working directory",
    "Plot_Barplot(table.DE.all[table.DE.all$measurement=='precision',], 'Precision', save=T, name = 'precision_DE.png', path = getwd())\n  Plot_Barplot(table.DE.all[table.DE.all$measurement=='recall',], 'Recall', save=T, name = 'recall_DE.png', path = getwd())\n  Plot_Barplot(table.DE.all[table.DE.all$measurement=='tnr',], 'TNR', save=T, name = 'TNR_DE.png', path = getwd())\nEffects of doublet detection on cell clustering\nTiming: 4–6 h\nThis section illustrates how to use DoubletCollection to evaluate the effects of doublet-detection methods on cell clustering. First, we examined the efficacy of doublet-detection methods for removing spurious cell clusters formed by doublets. Second, we compared the proportion of singlets in the correctly identified cell clusters after each doublet-detection method is applied.\nDetect and remove doublets from datasets\nWe first read the dataset sim_clustering that includes three datasets with four, six, and eight cell types and 20% doublets. Then we applied doublet-detection methods to obtain doublet scores and remove doublets based on various doublet rates.\n# specify your directory of dataset sim_clustering\n  data.list.cluster <-\n  readRDS(\"directory/synthetic_datasets/sim_clustering.rds\") # Do not directly copy this line (“directory” is where “synthetic_datasets.zip” is downloaded and uncompressed)\n  count.list.cluster <- data.list.cluster$count\n  label.list.cluster <- lapply(data.list.cluster$label, FUN = function(label){\n    ifelse(label == 'doublet', 1, 0)\n  })\n  score.list.all.cluster <- FindScores.All(count.list.cluster, methods)\n# call doublets based on doublet rates from 0.01 to 0.25\n    doublet.list.all.rate.cluster <-\n      FindDoublets.All.Rate(score.list.all.cluster, rates = seq(0.01, 0.25, 0.01))\n# remove identified doublets under different doublet rates\n      data.removal.all.rate.cluster <-\n        RemoveDoublets.All.Rate(count.list.cluster, label.list.cluster, doublet.list.all.rate.cluster)\nPerform cell clustering after doublet detection\nWe applied Louvain clustering (Blondel et al., 2008[href=https://www.wicell.org#bib3]) to the post-doublet-removal datasets to identify cell clusters.\nresult.cluster.all.rate <-\n    Clustering.All.Rate(data.removal.all.rate.cluster)\nVisualize the effects of doublet detection on the removal of spurious cell clusters\nWe used heatmaps to compare the efficacy of doublet-detection methods for removing spurious cell clusters. The following R code outputs heatmaps of clustering results on datasets with four, six, and eight cell clusters under various doublet rates (Figure 5[href=https://www.wicell.org#fig5]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/882-Fig5.jpg\nFigure 5. The effects of doublet detection on cell clustering",
    "(A) Cell clustering results by the Louvain algorithm after each doublet-detection method is applied to remove a varying percentage of droplets as the identified doublets (y-axis, from 1% to 25% with a step size of 1%); the true numbers of cell clusters are four, six, and eight under three simulation settings, each containing 20% true doublets; the yellow color indicates that the correct number of clusters was identified, while the red color indicates otherwise.\n(B) Under the same three simulation settings as in (A), the distributions of the singlet proportions are shown after doublet removal by each method, if the remaining droplets lead to the correct number of cell clusters in (A); some methods are not shown because they do not lead to the correct number of cell clusters in (A). Methods are ordered by their average performance measurement across 16 datasets (low to high).\n# transform the output of Clustering.All.Rate to a data frame for\n  # visualization\n  table.cluster <- ListToDataframe(result.cluster.all.rate, type='heatmap')\n# draw heatmaps of clustering results\n    # save each plot to a file in the current working directory\n    Plot_Heatmap(table.cluster, cluster = 4, save=T, name = 'clustering_4.png', path = getwd())\n    Plot_Heatmap(table.cluster, cluster = 6, save=T, name = 'clustering_6.png', path = getwd())\n    Plot_Heatmap(table.cluster, cluster = 8, save=T, name = 'clustering_8.png', path = getwd())\nCalculate singlet proportions after doublet detection\nHomotypic doublets tend to cluster together with singlets and thus do not form spurious clusters. To evaluate the efficacy of doublet-detection methods for eliminating homotypic doublets, we calculated the proportion of singlets in each identified cell cluster when the number of cell clusters matches the number of cell types.\ntable.cluster.quality <- Clustering.Quality(table.cluster, result.cluster.all.rate, data.removal.all.rate.cluster)\nVisualize the singlet proportions in cell clusters",
    "We used boxplots to visualize the singlet proportions within clusters after applying doublet-detection methods, if the remaining droplets lead to the correct number of cell clusters (Figure 5[href=https://www.wicell.org#fig5]B).\n# save each plot to a file in the current working directory\n  Plot_Boxplot(table.cluster.quality[table.cluster.quality$correct=='4',], 'Singlet Rates (Four Clusters)', save=T, name = 'cluster_quality_4.png', path = getwd())\n  Plot_Boxplot(table.cluster.quality[table.cluster.quality$correct=='6',], 'Singlet Rates (Six Clusters)', save=T, name = 'cluster_quality_6.png', path = getwd())\n  Plot_Boxplot(table.cluster.quality[table.cluster.quality$correct=='8',], 'Singlet Rates (Eight Clusters)', save=T, name = 'cluster_quality_8.png', path = getwd())\nEffects of doublet detection on cell trajectory inference\nTiming: 2–3 h\nThis section illustrates how to use DoubletCollection to evaluate the effects of doublet-detection methods on cell trajectory inference. First, we examined the efficacy of doublet-detection methods for removing spurious cell branches formed by doublets. Second, we compared the accuracy of temporally DE gene identification after doublet-detection methods are applied.\nPerform and visualize cell trajectory inference on the contaminated dataset\nWe used Slingshot (Street et al., 2018[href=https://www.wicell.org#bib16]) to infer the cell trajectories on the dataset sim_trajectory. It contains two cell branches mixed with 20% doublets (contaminated dataset). The following R code shows a two-dimensional visualization of the inference result. It contains three cell trajectories instead of two, and the intermediate trajectory is formed by doublets (Figure 6[href=https://www.wicell.org#fig6]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/882-Fig6.jpg\nFigure 6. Effects of doublet detection on cell trajectory inference and the detection accuracy under distributed computing\n(A) Cell trajectories constructed by Slingshot.\n(B) Precision, recall, and TNR of temporally DE genes inferred by the GAM. Both (A) and (B) are performed on contaminated, clean, and post-doublet-detection datasets.\n(C) AUPRC of each doublet-detection method on the real dataset pbmc-ch under distributed computing.\n# specify your directory of dataset sim_trajectory\n  data.trajectory <-\n  readRDS('directory/synthetic_datasets/sim_trajectory.rds') # Do not directly copy this line (“directory” is where “synthetic_datasets.zip” is downloaded and uncompressed)\n  count <- data.trajectory$count\n  label <- data.trajectory$label",
    "# cell trajectory inference by Slingshot and visualization\n    # the trajectory plot is saved in the current working directory\n    FindTrajectory(count, label, title='Contaminated Data')\nPerform and visualize cell trajectory inference on the clean dataset\nWe used Slingshot to infer the cell trajectories on the dataset sim_trajectory after removing all 20% doublets (clean dataset). The following R code shows a two-dimensional visualization of the inference result with two correct cell trajectories (Figure 6[href=https://www.wicell.org#fig6]A).\n# remove all doublets\n  count.clean <- count[,which(label==0)]\n  label.clean <- label[which(label==0)]\n# cell trajectory inference by Slingshot and visualization\n    # the trajectory plot is saved in the current working directory\n    FindTrajectory(count.clean, label.clean, title='Clean Data')\nPerform and visualize cell trajectory inference on the post-doublet-detection datasets\nWe first performed doublet detection on the dataset sim_trajectory to obtain doublet scores. Then for each method, we removed the top 20% droplets that receive the highest doublet scores. Finally, we inferred and visualized cell trajectories on each post-doublet-removal dataset to examine if the corresponding doublet-detection method removes the spurious cell branches formed by doublets (Figure 6[href=https://www.wicell.org#fig6]A).\nscore.list.trajectory <- FindScores(count, methods)\n  doublet.list.trajectory <- FindDoublets(score.list.trajectory, rate = .2)\n  data.removal.list.trajectory <-\n    RemoveDoublets.Method(count, label, doublet.list.trajectory)\n# infer trajectory on each post-doublet-removal dataset\n    for(method in methods){\n      FindTrajectory(data.removal.list.trajectory[[method]]$count, data.removal.list.trajectory[[method]]$label, title = method)}\nInfer temporally DE genes\nWe first used Slingshot to infer the cell pseudotime on the dataset sim_temporally_DE (contaminated dataset). It contains a single cell lineage with 250 temporally DE genes out of 750 genes, mixed with 20% doublets. Second, we used a general additive model (GAM) (Hastie, Tibshirani, and Friedman 2009[href=https://www.wicell.org#bib9]) to regress each gene’s expression levels on the inferred pseudotime. Finally, we calculated the precision, recall, and TNR of the inferred temporally DE genes identified using the Bonferroni-corrected p-value threshold of 0.05. We repeated the same analysis on the clean dataset (without doublets) and each post-doublet-removal dataset.",
    "# specify your directory of dataset sim_temporally_DE\n  data.temp <-\n  readRDS('directory/synthetic_datasets/sim_temporally_DE.rds') # Do not directly copy this line (“directory” is where “synthetic_datasets.zip” is downloaded and uncompressed)\n  count <- data.temp$count\n  label <- data.temp$label\n# ground-truth temporally DE genes\n    gene.de <- data.temp$gene.de\n# calculate precision, recall, and TNR of temporally DE genes for\n      # contaminated data\n      de.temp.list <- FindTempDE(count, gene.de)\n# calculate doublet scores and remove doublets\n    score.list.temp <- FindScores(count, methods)\n    count.clean.temp <- count[,which(label==0)]\n    label.clean.temp <- label[which(label==0)]\n    doublet.list.temp <- FindDoublets(score.list.temp, rate=0.2)\n    data.removal.list.temp <-\n    RemoveDoublets.Method(count, label, doublet.list.temp)\n# add clean data\n    data.removal.list.temp[['Clean Data']] <- list(count=count.clean.temp, label=label.clean.temp)\n# calculate precision, recall, and TNR of temporal DE genes for\n    # post-doublet-removal data\n    de.temp.result.all <- FindTempDE.All(data.removal.list.temp, gene.de)\n# add the result of contaminated data\n    de.temp.result.all[['Contaminated Data']] <- de.temp.list\nVisualize the effects of doublet detection on the inference of temporally DE genes\nWe used barplots to compare the results of temporally DE gene identification on the contaminated dataset, the clean dataset, and the post-doublet-removal datasets (Figure 6[href=https://www.wicell.org#fig6]B). The barplot stacks the results of precision, recall, and TNR for different doublet-detection methods.\n# transform to data frame for visualization\n  table.DE.temp <- ListToDataframe(de.temp.result.all, type='barplot')\n# draw barplot\n# save the plot to a file in the current working directory\n    Plot_Barplot_temp(table.DE.temp, title='Temporally DE Genes', save=T, name = 'temporally DE gene.png', path = getwd())\nPerformance of doublet-detection methods under distributed computing\nTiming: 8–10 h\nThis section illustrates how to use DoubletCollection to evaluate the accuracy of doublet-detection methods under distributed computing. This benchmark simulates the scenario when the large scRNA-seq dataset is beyond the capacity of a single computer so that the dataset must be divided into subsets to be analyzed in parallel.\nCalculate detection accuracy under distributed computing",
    "First, we randomly split the dataset pbmc-ch into two to ten equal-sized batches. Second, for each batch number, we executed every doublet-detection method on each batch separately and concatenate the resulting doublet scores across batches. Finally, we calculated the distributed AUPRC based on the concatenated doublet scores.\n# read dataset pbmc-ch\n      count <- data.list$count$`pbmc-ch`\n      label <- data.list$label$`pbmc-ch`\n      label <- ifelse(label == 'doublet', 1, 0)\n# calculate distributed AUPRC for different methods\n        auc.list.batch <- FindDistributedAUC.All(count, label, methods, >batches=2:10, type='AUPRC')\nVisualize detection accuracy under distributed computing\nWe used line plots to show how the detection accuracy of each method changes as the number of batches increases. The following R code places the batch numbers on the x-axis and connects AUPRC values to show the trend of each method (Figure 6[href=https://www.wicell.org#fig6]C).\n# transform the output of FindDistributedAUC.All to a data frame for\n      # visualization\n      table.batch <- ListToDataframe(auc.list.batch, type='distributed')\n# draw line plots\n        # save the plot to the local directory specified by the path parameter\n        Plot_Lineplot_Distributed(table.batch, data='pbmc-ch', measurement='AUPRC', save=T, name = 'distributed.png', path = getwd())\nOptional: Users can apply the same pipeline to evaluate the detection accuracy of doublet-detection methods under distributed computing on any other real dataset.\nComputational aspects of doublet-detection methods\nTiming: 8–10 h",
    "The benchmark of computational aspects of doublet-detection methods includes but is not limited to efficiency, scalability, stability, and software implementation. First, we can summarize the running time of doublet-detection methods on the 16 real scRNA-seq datasets. The result can be visualized by boxplots similar to Figure 3[href=https://www.wicell.org#fig3]A to compare the computational efficiency of doublet-detection methods. Second, we can examine how fast each method’s running time increases as the number of droplets grows. The result can be visualized by line plots similar to Figure 4[href=https://www.wicell.org#fig4]A to examine the scalability of doublet-detection methods. Third, we can evaluate how much each method’s AUPRC and AUROC values vary across subsets of droplets and genes. The result can be visualized by violin plots to compare the statistical stability of doublet-detection methods. Finally, we can qualitatively evaluate the software implementation of doublet-detection methods from the aspects of user-friendliness, software quality, and active maintenance. The complete visualization details are available in (Xi and Li, 2020[href=https://www.wicell.org#bib19])."
  ],
  "subjectAreas": [
    "Molecular Biology",
    "Rnaseq",
    "Sequencing",
    "Bioinformatics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}