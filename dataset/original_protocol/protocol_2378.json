{
  "id": 2506,
  "origin_website": "Cell",
  "title": "Reconstructing cancer phylogenies using Pairtree, a clone tree reconstruction algorithm",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nThe following step-by-step method details sections describe how to run Pairtree and its utilities using a set of example files as inputs, comprising methods.ssm and methods.params.json. These data files are simulated data meant to demonstrate the use of our protocol. The same steps can be used to run Pairtree with other data.\nCritical: Your data are unique. The utilities included along with Pairtree can perform statistical checks and can flag potentially erroneous fields. These methods are inherently limited to identifying clear issues; more subtle errors may escape these automated checks.\nClone our repository and install requirements\nTiming:  < 10 min\nPrior to beginning our experiment, we need to clone the Pairtree repository and install dependencies. We describe in this section how to clone our repository using different package managers and install necessary dependencies.\nClone repository and install dependencies. Installation can be performed using mamba[href=https://mamba.readthedocs.io/en/latest/index.html], conda[href=https://docs.conda.io/en/latest/], or pip[href=https://pypi.org/project/pip/].\nClone the repository from GitHub and move into the Pairtree directory.\n>git clone https://github.com/morrislab/pairtree[href=https://github.com/morrislab/pairtree]\n>cd pairtree\nThen, you can install the dependencies using mamba, which is an accelerated version of conda.\n>mamba create --name pairtree --file requirements.txt\n>conda activate pairtree\nAlternatively, you can install the dependencies using conda.\n>conda install --list requirements.txt\n>conda activate pairtree\nA third alternative is to install the dependencies using pip.\n>pip install -r requirements.txt\nDownload and build the modified projectppm library that fits subclonal frequencies to candidate clone trees. The following terminal commands assume you are currently in the /pairtree directory.\nNavigate to /pairtree/lib directory and clone the projectppm repository.\n>cd lib\n>git clone https://github.com/jwintersinger/projectppm[href=https://github.com/jwintersinger/projectppm]\nNavigate to the /pairtree/lib/projectppm directory and build the projectppm library.\n>cd projectppm\n>bash make.sh",
    "Critical: Ensure that the projectppm repository is in the /pairtree/lib/ directory. The pairtree executable will look for the compiled projectppm in /pairtree/lib/projectppm. If this step is not done properly, pairtree will not be able to use the projection algorithm to fit subclonal frequencies to the tree.\nFixing incorrect ploidy\nTiming:  < 5 min (when using data containing 3 samples and 30 subclones)\nIncorrect ploidy may occur when the wrong var_read_prob is assigned for a mutation in a given sample. These situations may arise due to uncalled loss of heterozygosity (LOH) or other missed copy number aberrations (CNAs). Uncalled LOH events may be simple to detect manually with a small dataset, however, verifying each var_read_prob in larger dataset may be more cumbersome. For uncalled LOH, we provide a script, fix_bad_var_read_prob.py, which attempts to detect uncalled LOH events and correct the var_read_prob.\nInspecting the methods.ssm file.\nWhen inspecting methods.ssm, we can see that the total read count (total_reads) across all mutations/samples is 1,000. We can also see that the var_read_prob is set to 0.5 across all mutations/samples, meaning we would expect to obtain a variant read about half of the time.",
    "For example, the mutation with the id of s14 has var_reads 269, 328, and 427 across the three samples resulting in VAFs of 269/1,000 = 0.269, 328/1,000 = 0.328, 427/1,000 = 0.427. With a var_read_prob of 0.5, we can then calculate the data-implied subclonal frequency for mutation s14 across the three samples as 0.269/0.5 = 0.538, 0.328/0.5 = 0.656, 0.427/0.5 = 0.854. These are noisy estimates for the percentage of cells in each sample bearing mutation s14. However, if we look at mutation s10 and perform the same calculations, we can see that in each of the 3 samples we have VAFs of 0.879, 0.698, 0.994. When calculating the data-implied subclonal frequencies for mutation s10, we obtain 0.879/0.5 = 1.758, 0.698/0.5 = 1.396, 0.994/0.5 = 1.988. These data-implied subclonal frequencies do not make sense, as we cannot have more than 100% of the cells in a sample bearing mutation s10. In this case, the data implies that we should have a var_read_prob of 1 across all samples for mutation s10, as there may have been an uncalled LOH event which resulted in the cells having only the variant allele. Although we can detect and correct this manually for our example data, we provide the fix_bad_var_read_prob.py script to perform this task automatically.\nProperly configure the parameters for fix_bad_var_read_prob.py.\nThere are a few notable command line arguments for the fix_bad_var_read_prob.py script that we may want to modify.\nIn our case, we will use the –action argument which tells the script what to do if it finds a mutation that likely had an uncalled LOH event. We will pass the value of modify_var_read_prob to –action, which tells the program to update the var_read_prob value for any mutation that may have had an uncalled LOH or CNA event.",
    "We can change the value that the var_read_prob gets updated to by passing a numeric value to the argument –var-read-prob-alt. The default value for –var-read-prob-alt is 1. We do not need to modify this value for our example.\nIf during the protocol some id values have been added to the list of garbage mutations and the user does not want them to appear in the results from running fix_bad_var_read_prob.py, then the flag –ignore-existing-garbage should be used to exclude these mutations from the analysis.\nPlease see the Pairtree GitHub[href=https://github.com/morrislab/pairtree] for further information about the command line arguments for this script.\nRun fix_bad_var_read_prob.py.\nWe can now run the script using the following command.\n> python3 util/fix_bad_var_read_prob.py star_methods/methods.ssm star_methods/methods.params.json star_methods/methods.ssm star_methods/methods.params.json --action modify_var_read_prob\nThe output from running this script should be as follows:\nnum_bad_ssms=1\nbad_ssms=['s10']\nbad_samp_prop=0.033\nbad_ssm_prop=0.033\nWe’ll briefly explain each line outputted by this script. The first line num_bad_ssms=1 states how many mutations from the .ssm file may have an incorrect var_read_prob. The second line bad_ssms=['s10'] lists the mutations that were found to have an incorrect var_read_prob. The third line bad_samp_prop=0.033 states the proportion of read count data that may have an incorrect var_read_prob. The fourth line bad_ssm_prop=0.033 states the proportion of mutations that have at least one sample with an incorrect var_read_prob.\nFinally, we can verify that the fix_bad_var_read_prob.py script adjusted the var_read_prob for s10 to 1 by checking the methods.ssm file. The line for mutation s10 should look as follows:\ns10 S_10 879,698,994 1000,1000,1000 1.0,1.0,1.0\nOptional: Create a directory to store your results from running fix_bad_var_read_prob.py. See the run_pipeline.sh script in the Pairtree source tree[href=https://github.com/morrislab/pairtree] for an example of how to design a pipeline using multiple Pairtree components.\nIdentifying garbage mutations\nTiming:  < 5 min (when using data containing 3 samples and 30 subclones)",
    "Erroneous read count data can lead Pairtree to construct incorrect clone trees. Pairtree assumes a simple inheritance pattern for the mutations included in its clone trees. In most cases, the vast majority of point mutations in an individual cancer satisfy this simple pattern called the infinite sites assumption (ISA), such that each mutation occurs only once during the evolution of the cancer and does not revert to the reference allele (Singer et al., 2018[href=https://www.wicell.org#bib11]). The Pairtree software package includes the removegarbage script to detect mutations with potential complex inheritance patterns where, e.g., they have a missed CNA call, suffered an ISA violation, or their variant read counts are corrupted with technical noise. We deem mutations affected thus as garbage mutations. We remove these garbage mutations because Pairtree cannot identify the correct evolutionary relationship they should have with respect to other mutations, so including them in the analysis can lead to incorrect trees. The removegarbage script provides an automated method for detecting and adding these mutations to the list of garbage mutations in the .params.json file.\nProperly configure the parameters for removegarbage.\nThere are several command-line arguments for removegarbage that may need to be set depending on prior knowledge and the data. In our example, we can use the default parameters.\nIf there is reason to believe the data is particularly noisy, then the –prior parameter can be increased as it sets a prior probability on each pair of mutations having a garbage relationship. The default –prior is 0.2, reflecting a uniform prior with respect to the five possible pairwise relationship types (see Wintersinger et al. (2022)[href=https://www.wicell.org#bib13] for more detail).",
    "If during the protocol some id values have been added to the list of garbage mutations and the user does not want them to appear in the results from running removegarbage, then the flag –ignore-existing-garbage should be used to exclude these mutations from the analysis.\nRun removegarbage.\nWe can run this script using the following command\n> python3 bin/removegarbage star_methods/methods.ssm star_methods/methods.params.json star_methods/methods.params.json\nThe command may take a few seconds to run.\nThe result of this script will be a modified garbage list in the methods.params.json. Specifically, the mutation with id s20 should have been placed into the garbage list, and the methods.params.json file should appear as follows:\n{\n“samples”: [\"Sample 1″, “Sample 2″, “Sample 3\"],\n“clusters”: [],\n“garbage”: [\"s20\"]\n}\nMutation s20 is labeled as garbage because the data in each sample imply conflicting pairwise relationships with other mutations. In Sample 1, s20 has a high VAF, making it a likely candidate to be ancestral to most other mutations. In Sample 2, it has a similar VAF to most other mutations. In Sample 3, it has a very low VAF, making it likely to be a descendant of many other mutations. Because of these conflicting pairwise relationships, it’s likely that s20 is a garbage mutation.\nNote: This script may take much longer to run if the data used has many samples/and or mutations.\nClustering mutations into subclones\nTiming:  < 10 min (when using data containing 3 samples and 30 subclones)\nIn order to run Pairtree, mutations must first be clustered into subclones in the .params.json file. There are several approaches for generating these clusters.",
    "First, instead of building a clone tree, a mutation tree could be built. In this case, each mutation that appears in the .ssm file would be listed as a separate cluster in the .params.json file. The tree will then show the evolutionary relationships between mutations instead of between subclones. We recommend this approach if the data being used has 30 or fewer mutations.\nAlternatively, the clustervars script can be used to generate the subclones. We will not go into detail on the different ways to configure the parameters for clustervars, as there are many possible configurations that require consideration. Please see the documentation in the Pairtree source tree[href=https://github.com/morrislab/pairtree] for more information.\nRun clustervars.\nWe can run this script using the command.\n> python3 bin/clustervars star_methods/methods.ssm star_methods/methods.params.json star_methods/methods.params.json.\nThis command may take up 30 s to run.\nThe result of this script will be a modified clusters list in the methods.params.json. Specifically, the script will generate a list of lists containing four different clusters. The methods.params.json file should now appear as follows:\n{\n“clusters”: [[\"s10\"], [\"s2″, “s4″, “s5″, “s6″, “s8″, “s9″, “s11″, “s12″, “s13″, “s14″, “s19″, “s21″, “s22″, “s23″, “s24″, “s25″, “s27\"], [\"s0″, “s3″, “s7″, “s15″, “s16″, “s17″, “s28\"], [\"s1″, “s18″, “s26″, “s29\"]], “garbage”: [\"s20\"],\n“samples”: [\"Sample 1″, “Sample 2″, “Sample 3\"]\n}",
    "After clustering mutations into subclones, it’s important to verify that these groupings make sense. Generally, these verifications involve ensuring that the VAFs are similar, although in some special cases they could be performed by ensuring that clusters do not contain mutually exclusive driver mutations. We can perform a manual check by looking at the groupings of mutations in each cluster in the methods.params.json file, then using the data in methods.ssm to verify that the mutations have VAFs which, when adjusted for ploidy, appear to reflect the same underlying subclonal frequency. The first cluster consists only of mutation s10, which is likely because there are no other mutations that had such high read counts across all 3 samples. The second cluster has quite a few different mutations s2, s4, s5, …. All these mutations have a var_read_prob of 0.5 and the same total_reads, so we can check whether their variant read counts are approximately the same to determine if they reflect the same subclonal frequency. All mutations in the second cluster are clearly present in all three samples, as their variant read counts are approximately 200 in the first sample, 300 in the second sample, and 400 in the third sample. We cannot necessarily use this information to conclude that all these mutations should definitely be placed in the same cluster i.e., two mutations with the same apparent subclonal frequency may not necessarily have arisen in the same cells, but may instead belong to distinct subpopulations with similar subclonal frequencies. Nevertheless, we have no reason to conclude that the mutations should be separated, given their similar read counts across all samples. The third cluster consists of mutations s0, s3, s7, ...",
    ", which all seem to have near-zero variant read counts in Sample 1 and are present in the other two samples. This is different than cluster 1 or cluster 2, both of which had non-zero variant read counts in all three samples. Finally, cluster 4 consists of mutations s1, s18, s26, and s29, all of which have near-zero variant read counts across all three samples. Although it’s difficult to say whether this clustering is correct by checking it manually, it does allow us to see that there are no obvious errors that will compromise Pairtree’s ability to construct clone trees.",
    "Note: Other non-Pairtree methods can be used to cluster mutation into subclones, such as PyClone (Roth et al., 2014[href=https://www.wicell.org#bib9]), PyCloneVI (Gillis and Roth, 2020[href=https://www.wicell.org#bib3]), and SciClone (Miller et al., 2014[href=https://www.wicell.org#bib6]). If clustering is performed via another method, the results must be converted into the .params.json format Pairtree uses.\nRun pairtree\nTiming:  < 10 min (when using data containing 3 samples and 30 subclones)\nAll the work done in previous steps prepared our data for running the pairtree executable that builds clone trees. Properly configuring pairtree depends heavily on both prior knowledge and the data. This section will discuss some of the ways one can configure pairtree.\nProperly configure the parameters for pairtree.\nIn order to obtain the same exact output shown in this procedure when using the example data, we must pass the parameter –seed=5555 to pairtree. The argument passed to the seed parameter can be any non-negative integer less than or equal to 232 – 1. The underlying randomness of the method used to search for clone trees will produce slightly different results on each execution of pairtree. Setting the seed parameter to the same value across multiple executions of pairtree will produce the same set of clone trees, assuming all other parameters and inputs are also held fixed.\nBesides setting the seed parameter, we will use the default parameters for pairtree when using the example data for this protocol. However, there are several other key parameters that could be modified when using different data.\nPairtree offers two different methods for fitting subclonal frequencies to trees, termed projection and rprop.",
    "By default, pairtree uses the “Efficient Projection onto the Perfect Phylogeny Model” algorithm developed in Jia et al. (2018)[href=https://www.wicell.org#bib4]. This can be specified explicitly by passing –phi-fitter=projection to pairtree. This method maximizes the binomial likelihood for subclonal frequencies using a Gaussian approximation. It is fast to compute and produces fairly accurate results, making it generally a good choice for both small and large datasets. However, we find that sometimes the Gaussian approximation can lead to inaccurate results on larger datasets.\nThe alternative model is rprop, which is a gradient-based method that directly optimizes the binomial objective. This can be specified using the option –phi-fitter=rprop. This method typically produces more accurate results than projection but is more computationally intensive. By default, the rprop algorithm runs for 10,000 iterations. To manually set the number of iterations to some integer N, pass –phi-iterations=N to pairtree. If pairtree is producing poor results using projection, try switching to rprop. It is important to note that rprop may be computationally infeasible for more than 30 subclones, depending on how many cancer samples the data has and how powerful the available computing hardware is.",
    "Running pairtree with the example data and parameters provided in this protocol will obtain the same exact results using either rprop or projection. This is because our example data is relatively simple and has had complex mutations withheld from the analysis (see the step-by-step method details[href=https://www.wicell.org#step-by-step-method-details] section identifying garbage mutations[href=https://www.wicell.org#sec3.3]). For data that is not so simple, it’s possible to obtain different sets of candidate clone trees when running pairtree using rprop versus projection. This can be particularly problematic when the data are well-fit by many possible clone tree configurations. The different results from the two algorithms may also be due to a poor approximation by the projection algorithm, or because rprop does not converge quickly enough.\npairtree samples candidate clone trees using Markov Chain Monte Carlo (MCMC). To find high-quality trees, multiple MCMC chains are run, each of which sample a fixed number of trees. Two parameters related to MCMC can be modified to potentially improve results.\nBy default, pairtree samples 3,000 trees with each MCMC chain. To set the number of trees sampled by each MCMC chain to some non-negative integer N, pass the argument –trees-per-chain=N to pairtree.\nNote: Pairtree’s runtime will scale linearly with the number of trees sampled by each MCMC chain.\nEach MCMC chain discards a fraction of the total number of trees it samples at the beginning of its search to avoid including poor-quality trees in the results. By default, pairtree discards the first 1/3 of all trees sampled by each chain. This can be set manually to some proportion F (where F is between 0 and 1) by passing the argument –burnin=F to pairtree.\nRun pairtree.\nWe can run this script using the following command.\n> python3 bin/pairtree --params star_methods/methods.params.json star_methods/methods.ssm star_methods/methods.npz --seed=5555.",
    "Note: if the file methods.npz already exists and includes complete results from a previous execution of pairtree, then pairtree will halt so as to not overwrite these results.\nThe result of this script is the creation of methods.npz, which is a zip archive. It includes the sampled clone tree structures, subclonal frequencies, tree likelihoods, and other data. This .npz file is then used in the next two steps to visualize the candidate trees.\nRunning summposterior and interpreting the results\nTiming:  < 10 min\nNow that we’ve run pairtree and generated an .npz file containing candidate trees, we can visualize these trees to determine which best fit our data. The tree representations shown here consists of nodes (or vertices), with arrows (or directed edges) connecting the nodes. An arrow starting at Node 0 and ending at Node 1 implies that Node 0 is the parent (i.e., the immediate ancestor) of Node 1 or equivalently that Node 1 is a child (i.e., an immediate descendant) of Node 0.\nProperly configure the parameters for summposterior.\nThe only recommended argument to alter for summposterior is –runid <run_name> where <run_name> is some string that describes the experiment. This label will be used within the HTML results file.\nRun summposterior.\nWe can run this script using the follow command.\n> python3 bin/summposterior --runid methods star_methods/methods.ssm star_methods/methods.params.json star_methods/methods.npz star_methods/methods.summposterior.html\nThis script generates the methods.summposterior.html file, which contains a list of candidate trees and some basic information about them.\nPlease note that if pairtree is run without setting the seed parameter to the exact value we did in the previous section titled run pairtree[href=https://www.wicell.org#sec3.5], then the file obtained after running summposterior may not match the images shown here.\nInterpreting the results from summposterior.",
    "The summposterior file has three sections that we will first summarize. Then, we will discuss the results we obtained for each of these sections after running summposterior with the example data.\nConsensus Graph: provides an overview of the distributions of evolutionary relationships between subclones across all sampled trees. In a tree, each subclone only has one parent; in the consensus graph, subclones can have multiple parents corresponding to the parents of that subclone in at least one of the trees being summarized. This graph shows the user the full spectrum of possible relationships that are supported by the data. Each edge, i.e., parent-child relationship, between subclones is assigned a probability weight according to the data likelihoods of the trees in which that edge was present. This weight can be interpreted as the probability that a head node is the parent of the tail node, as such the weights of the incoming edges to a subclone sum to one. By changing the interactive Edge threshold, the user can filter out less certain relationships to show only those most supported by the data. The minimum spanning-tree threshold is the minimum value across the nodes of the maximum parent probability for that node; in other words, raising the edge threshold above this value would result in the graph becoming disconnected.",
    "Trees: provides an overview of the most likely candidate trees, ordered by descending posterior probability. This section is detailed below. In the Trees section of the summposterior output, the top candidate trees are rendered. As shown in Figure 4[href=https://www.wicell.org#fig4], the methods.summposterior.html file will have three candidate trees, each with different branching patterns. The Posterior column lists the posterior probability for each tree. The nLgLh column lists the normalized negative log-likelihood for each tree. The Count column lists the number of times each tree was found during MCMC. The Structure column shows a visualization of the candidate clone tree. For each tree shown in the methods.summposterior.html file, pairtree computed the same negative log-likelihood (nLgLh), indicating that each is equally supported by the data. The nLgLh is normalized relative to the number of cancer samples and mutations, effectively indicating the likelihood “cost” in bits per mutation per sample that the tree incurred. Lower values reflect trees that better fit the data. Since the hardware this procedure was run on has 4 cores, each core had an MCMC chain that sampled 3,000 trees, which gives us a total of 12,000 trees. Since our –burnin when running pairtree was set to the default of 1/3, there were a total of 12,000/3 = 4,000 samples discarded. Therefore, the sum of all the rows for Count should add up to 8,000 (since 12,000–4,000 = 8,000). In the Structure column, we can see the visualizations for each of our three candidate clone trees. All trees have as their root Node 0, representing the non-cancerous population that is ancestral to all cancer populations. Each subsequent tree node represents a cancerous subclone whose mutations are given by the clusters specified in the .params.json file. For example, in our methods.params.",
    "json file, the first cluster contains only the s10 mutation, and corresponds to Node 1 in every candidate tree. Observe that the mutation clusters are constant across all sampled trees, but the tree structures and subclonal frequencies (and thus the computed data likelihoods) differ. The next section titled running plottree and interpreting the results[href=https://www.wicell.org#sec3.7] focuses on interpreting the first tree, listed with tree index 0.",
    "Note: Often, multiple clone trees fit the data equally well. In these cases, the choice of clone trees could be based on assumptions about the dynamics of tumor evolution (Sottoriva et al., 2011[href=https://www.wicell.org#bib12]), metastatic spread (El-Kebir et al., 2018[href=https://www.wicell.org#bib2]), or spatial spread. Though, in general, we recommend examining the consensus graph (Figure 3[href=https://www.wicell.org#fig3]) to distinguish parts of the clone tree that are well-supported by the data and those that are unconstrained by the data; and potentially collecting data from more samples to resolve uncertainties.\nDiversity indices: shows three different measures that depict how heterogeneous the subclonal composition of each cancer sample is. For further information, please refer to the Pairtree documentation[href=https://github.com/morrislab/pairtree].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2013-Fig3.jpg\nFigure 3. Consensus graph from methods.summposterior.html\nRunning plottree and interpreting the results\nTiming:  < 10 min\nNow that we’ve run pairtree and generated an .npz file containing candidate trees, we will visualize and interpret the results for the candidate clone tree with the highest posterior probability.\nConfigure the parameters for plottree.\nThere are two parameters for the plottree script that are often set by the user.\nThe file produced by plottree can be labeled by passing the argument –runid=<run_name>, where <run_name> is some string that describes the experiment and the selected clone tree.\nA specific tree shown in the summposterior file can be plotted by passing the argument –tree-index=N, where N is the tree index. By default, plottree uses index 0, corresponding to the tree with the highest posterior probability. Examining other trees, as well as the consensus graph from summposterior, can illustrate plausible alternative trees that should be considered before making conclusions about the data.\nRun plottree.\nWe can run this script using the follow command.\n> python3 bin/plottree --runid methods star_methods/methods.ssm star_methods/methods.params.json star_methods/methods.npz star_methods/methods.plottree.html",
    "This script generates the methods.plottree.html file, which contains detailed information about a specific tree and how the input data relates to it.\nInterpreting the results from plottree.\nInterpreting trees can be difficult because of the wealth of information that accompanies them. We will illustrate how to interpret one candidate tree found by pairtree during this procedure.\nThe candidate tree we will interpret is shown in Figure 5[href=https://www.wicell.org#fig5], which was assigned index 0 in the methods.summposterior.html file output after running summposterior. We will analyze the placement of each subclone in this candidate tree, and use information from the tables in the methods.plottree.html file to understand why pairtree found this structure.\nNode 0 represents the non-cancerous cell population from which all cancerous subclones descended, as described in the previous section running summposterior and interpreting the results[href=https://www.wicell.org#sec3.6].\nNode 1 represents the cluster containing only mutation s10. During this protocol, we corrected this mutation’s var_read_prob to 1.0, as its read counts suggested it originated from a haploid locus. The corrected var_read_prob still results in high estimated subclonal frequencies (near 1.0) for this subclone across all samples. Since the estimated subclonal frequencies of the other subclones (represented by Nodes 2–4) are much lower, Node 1 cannot be positioned such that it is a descendant of anything but the non-cancerous population (Node 0). Therefore, Pairtree’s placement of Node 1 as ancestral to all other subclones in the tree is reasonable.",
    "Node 2 corresponds to a mutation cluster whose read counts yield data-implied subclonal frequencies well above zero across all three samples. Because these data-implied subclonal frequencies across all three samples are approximately 0.5, this node is unlikely to be a descendent of either Node 3 or Node 4, which are both absent from one or more samples. Suppose we placed Node 2 as a descendant of Node 3. The data-implied subclonal frequency for Node 2 in Sample 1 is 0.47, while the data-implied subclonal frequency for Node 3 in Sample 1 is 0.10. The tree constraints implied by the Infinite Sites Assumption require that each subclone’s frequency is at least as high as the sum of all its children’s frequencies across each sample, given that the mutations of a subclone are inherited by all its children. This would imply that the true subclonal frequency of Node 3 in Sample 1 must be at least 0.47, resulting in a severe mismatch relative to the 0.10 subclonal frequency implied by the data before considering tree structure constraints. As a result, either Node 3’s frequency would have to be much higher than implied by the data, or Node 2’s frequency would have to be much lower. Either case would incur a large amount of error between our data implied subclonal frequencies, and the tree-constrained subclonal frequencies. Moreover, we would have to adjust the tree-constrained subclonal frequency similarly for Sample 2 and Sample 3. To avoid this, we can place Node 2 in the tree such that it’s ancestral to Node 3 and Node 4, which does not impose any deviation from the data-implied frequencies. Consequently, it is reasonable for pairtree to prefer this relationship.",
    "Node 3 represents the cluster containing mutations whose read counts suggest they are absent from Sample 1, but present in Sample 2 and Sample 3. Although this subclone is present in Sample 2 and Sample 3, its data-implied subclonal frequencies in these samples are around 0.4, making it less prevalent than Node 1 and Node 2. Therefore, it is plausible that Node 3 is a descendant of both Node 1 and Node 2.\nNode 4 represents the cluster containing mutations whose data-implied subclonal frequencies are near zero in all three samples. Pairtree placed it on another branch relative to Node 2 and Node 3, making it a direct descendant of Node 1. The placement of this node demonstrates the difficulties of deciding which candidate tree is likely to be correct. Placing this node on a separate branch incurs no error, but neither does making a linear branching pattern (see Figure 4[href=https://www.wicell.org#fig4], tree with index 2). Similarly, there is zero error incurred when Node 4 is a direct descendant of Node 2 (see Figure 4[href=https://www.wicell.org#fig4], tree with index 1).\nNote: With more cancer samples, pairtree can better resolve ambiguities like this. Without providing more samples, it’s possible to use other knowledge (such as a prior belief about how common branching vs. linear relationships are in a particular cancer type) to favor one tree over another, even if they have similar posterior probabilities.\nTo evaluate the error rate between the tree-constrained subclonal frequencies and the data-implied subclonal frequencies, refer to the Interleaved subclonal frequencies table in the HTML file produced by plottree. Consider each triplet of rows. The first shows the tree-constrained frequencies fit to the tree; the second shows the data-implied frequencies, independent of any tree constraints; and the third shows the absolute difference between these, termed the tree error.",
    "To inspect the data-implied frequencies for each mutation within the mutation clusters, refer to the VAFs (corrected) table in the HTML file outputted by plottree.\nAlthough the trees depicted here are simple, the procedure we used to evaluate and interpret them can be applied to more complex trees constructed by pairtree.\nNote: For further information on the tables in the HTML file produced by plottree, please refer to the Pairtree documentation[href=https://github.com/morrislab/pairtree]."
  ],
  "subjectAreas": [
    "Computer Sciences",
    "Genetics",
    "Cancer"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics"
  ]
}