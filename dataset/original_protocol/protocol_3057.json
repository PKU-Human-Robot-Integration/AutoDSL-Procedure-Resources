{
  "id": 3235,
  "origin_website": "Cell",
  "title": "Protocol for refining metagenomic binning with BinSPreader",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nAssemble short reads into metagenomic contigs\nTiming: 22 h\n      This protocol assumes that the metagenome sequencing data is composed of\n      short Illumina paired-end reads generated from whole metagenome shotgun\n      sequencing and stored in FASTQ files (however, BinSPreader itself could be\n      used on the assembly graphs generated from e.g., 3rd generation sequencing\n      data). Below we briefly outline the process of assembling metagenomes,\n      which has been extensively described earlier (for example, refer to Thomas\n      et al.,18[href=https://www.wicell.org#bib18] Prjibelski et al.19[href=https://www.wicell.org#bib19]).\n    \nTrim adapter sequences and poor-quality bases using bbduk:\n> bbduk.sh in1=SRR3656745_1.fastq in2=SRR3656745_2.fastq\n          out1=SRR3656745_1.trimm.fastq out2=SRR3656745_2.trimm.fastq\n          ref=adapters.fa ktrim=r k=23 mink=11 hdist=1 tpe tbo qtrim=rl\n          trimq=17\nNote: Here, “ref” option is used to\n      provide a reference fasta file with adapter sequences to remove. “ktrim =\n      r” specifies that sequence matching to ref will be trimmed together with\n      all the bases to the right side of a read, leaving only the bases to the\n      left. “k”, “mink” and “hdist” set k-mer size, minimal size of a kmer to\n      look for, and hamming distance (allowed number of mismatches),\n      respectively. “tbo” means running in a mode when adapters are trimmed not\n      only based on a kmer match, but also on pair overlap detection using\n      BBMerge. “tpe” specifies trimming of both reads to the same length.\n      “trimq = 17” means quality-trimming to Q17 using the Phred algorithm,\n      “qtrim = rl” makes bbduk to trim the both sides of a read.\n    \nCritical: Depending on the data source\n      additional preprocessing steps might be needed (for example, exclusion of\n      host-derived reads). Adapt the protocol according to the context of your\n      research.\n    \nRun metaSPAdes assembler with read error correction:\n> metaspades.py -1 SRR3656745_1.trimm.fastq -2\n          SRR3656745_2.trimm.fastq -o assembly -t 10\nNote: The assembly may take quite a long\n      time. After it is finished, the assembly graph, scaffolds, contigs and",
    "intermediate files will be saved to the assembly directory. You may need\n      to adapt the command line (e.g., number of used CPU threads specified via\n      “-t” option) depending on the available computation resources. Refer to\n      Prjibelski et al.19[href=https://www.wicell.org#bib19] and SPAdes manual (https://cab.spbu.ru/files/release3.15.5/manual.html#sec3.1[href=https://cab.spbu.ru/files/release3.15.5/manual.html]) for more information.\n    \nAlternatives: Preassembled\n      metagenome is available from the assembly folder of Figshare dataset.\n    \n        Run QUAST6[href=https://www.wicell.org#bib6] to assess contiguity of\n        generated assembly. Option “--fast” prompts QUAST to output only main\n        statistics of the assembly in a plain text form.\n      \n> quast.py --fast -o quast assembly/scaffolds.fasta\nNote: The results of downstream metagenome\n      analysis depend directly on the assembly quality, and thus their\n      evaluation allows one to make assumptions about further binning outcomes.\n      By using this command one can obtain standard assembly statistics such as\n      total length, N50 and contigs counts by length.\n    \nQUAST report can be viewed by using the following command.\n> less quast/report.txt\nTable 1[href=https://www.wicell.org#tbl1] shows the example report generated by this\n      step.\n    \ntable:files/protocols_protocol_2802_1.csv\nPerform initial binning by using MetaBAT2\nTiming: 3 h\n      This protocol uses MetaBAT2 to obtain a preliminary binning, although any\n      other binner or binning pipeline (such as MetaWRAP20[href=https://www.wicell.org#bib20]) of your choice can be used. Apart from characteristics computed from\n      contig sequences, MetaBAT2 can use contig coverages to distinguish\n      original organisms by their variable abundance in the source microbial\n      community. Contig coverage improves binning accuracy, so despite the fact\n      that MetaBAT2 can bin without input abundances, we strongly recommend to\n      map reads and create abundance profiles in advance.\n    \nAlternatives: Considering that the\n      read mapping step is rather time-consuming, pre-made abundance profiles\n      are available from FigShare (see\n      key resources table[href=https://www.wicell.org#key-resources-table]).\n    \nMap trimmed reads to the assembly:\n> minimap2 -t 10 -a -x sr assembly/scaffolds.fasta\n          SRR3656745_1.trimm.fastq SRR3656745_2.trimm.fastq | samtools view -F\n          3584 -b -o - | samtools sort -@ 10 -o mbarc.bam",
    "Note: This one-liner performs mapping,\n      filtering and sorting of the alignment in the BAM format without producing\n      intermediate files. The “-x” argument tells minimap2 which preset to use,\n      here it is one for mapping of short reads to genome assembly (“sr”);\n      option “-a” sets output file format to SAM. “-F 3584” filters out\n      alignments that are unmapped, are secondary or supplemental alignments, or\n      have a low mapping quality. The number 3584 is the bitwise flag for these\n      alignment states. The resulting bam file is sorted and saved to mbarc.bam.\n      “-@” specifies the number of threads to be used during the sorting step.\n    \n        Compute abundance profiles of contigs using the script that comes with\n        MetaBAT2:\n      \n> jgi_summarize_bam_contig_depths --outputDepth abundances.tsv\n          mbarc.bam\n        Bin contigs using MetaBAT2:\n        \n            Create output directory for MetaBAT2:\n            \n> mkdir -p metabat2/bins\n            Run the binner:\n            \n> metabat2 -i assembly/scaffolds.fasta -o\n                  metabat2/bins/bin -a abundances.tsv --numThreads 10 --seed\n                  42\nNote: Calculated abundance\n              profiles are specified using “-a” option. Option “--seed” is used\n              to fix random value seed to guarantee the reproducibility of the\n              binning result. MetaBAT2 produced 35 bins in this example case;\n              they will appear in metabat2/bins/ directory as individual FASTA\n              files.\n            \nRefine bins with BinSPreader\nTiming: 5 min\n      This section of the protocol provides a detailed description of input\n      files requirements of BinSPreader, and introduces different run modes and\n      options available. Finally, there are example commands and thorough\n      instructions on how to run BinSPreader depending on your data conditions.\n    \n        Prepare the input data for BinSPreader:\n        \n            Assembly graph.\n            \nNote: Unlike contig sequences\n              alone, an assembly graph accumulates complete information about\n              the assembly. It is constructed of edges that are the maximal\n              nonbranching DNA sequences (unitigs), resulting from merger of\n              k-mers from unambiguous paths, and links between edges, inferred\n              from read overlaps. After the assembler resolves repeat paths",
    "across the assembly graph, it outputs non-branching paths as\n              contigs. This results in the loss of a wealth of information about\n              the connectivity of DNA sequences that can be beneficial for\n              downstream analysis. Therefore the use of assembly graph for\n              downstream analysis (instead of contig / scaffold sequences) might\n              provide better results as important link information is preserved\n              and can be utilized by graph-aware tools.\n            \n            Most often assembly graphs are represented in GFA file format (http://gfa-spec.github.io/GFA-spec/GFA1.html[href=http://gfa-spec.github.io/GFA-spec/GFA1.html]). It is a tab-separated format with each line corresponding to a\n            single record. Most usually there are three types of them: segment,\n            link or path, and record type is set in the first column with\n            capital “S”, “L” or “P”, respectively. Segment record describes\n            nucleotide sequence and its unique name. Link record characterizes\n            overlap between two sequences represented by their names,\n            orientation of these sequences, and overlap length. Path record\n            describes a scaffold as an ordered list of oriented segments,\n            supported by link records.\n          \n            Assembly.\n            \nNote: metaSPAdes outputs assembled\n              contigs as contigs.fasta. File scaffolds.fasta contains assembled\n              scaffolds and metaSPAdes-produced assembly graph encodes scaffold\n              paths in path records. Therefore we recommend using scaffolds for\n              metagenome binning and further downstream analysis. If there is a\n              specific demand to use contigs.fasta, their paths though the\n              assembly graph should be additionally specified. metaSPAdes\n              provides contigs paths in the separate contigs.paths file that\n              could be provided to BinSPreader with the “-paths” option. Should\n              the “-paths” option be specified, BinSPreader will process contig\n              paths described in the path file instead of scaffold paths\n              embedded in the assembly graph. In any case, the binned sequences\n              must correspond to the paths in the assembly graph.\n            \n            Initial binning. BinSPreader takes input binning in a tab-separated\n            format with the first column containing sequence (scaffold) name and",
    "second being a unique bin identifier. To generate the appropriate\n            file based on a directory with FASTA files of individual bins one\n            can use convert_fasta_bins_to_tsv_format.py script from Figshare.\n            Before running it, ensure that bin files are named akin to\n            “bin_∗.fasta” format.\n            \n                Rename bins named “bin.∗.fa” created by MetaBAT2 using the\n                command below:\n                \n> for file in metabat2/bins/bin.∗.fa; do mv\n                      \"$file\" \"${file/bin./bin_}\"sta;\n                      done\n                After file name format is normalized, run the script:\n                \n> python scripts/convert_fasta_bins_to_tsv_format.py\n                      --o metabat2/binning.tsv metabat2/bins/∗\n            Additional linkage information (optional).\nNote: BinSPreader can map\n              paired-end reads to obtain additional linkage evidence from\n              original sequencing reads or HiC data. It can be useful to\n              compensate for the fragmentation of the graph and obtain\n              connections between detached edges. However, it can produce\n              spurious connections between similar sequences originating from\n              distinct genomes and cause their co-clustering. Also in this case\n              refining will take more time because read mapping might be time\n              consuming. To use a paired-end library one should provide its\n              description in YAML format via the “--dataset” option. For\n              example, corresponding file for MBARC26 will be:\n            \n[\n  {\n  orientation: \"fr\",\n  type: \"paired-end\",\n  right reads:\n                  [\"SRR3656745_1.trimm.fastq\"],\n  left reads:\n                  [\"SRR3656745_2.trimm.fastq\"]\n  }\n]\n            For detailed information on specifying input data with YAML dataset\n            file, please, refer to SPAdes manual (https://cab.spbu.ru/files/release3.15.5/manual.html#sec3.1[href=https://cab.spbu.ru/files/release3.15.5/manual.html]).\n          \n        Select run mode:\n        \n            Refining types: Correction vs. Propagation\n            \nNote: BinSPreader can perform two\n              types of refining: propagate input binning to unbinned edges of\n              the assembly graph without any revision of initially binned edges,\n              or try to correct initial binning using the graph contiguity\n              information. Propagation or correction modes can be chosen via\n              “-Rprop” or “-Rcorr” options, respectively. Propagation mode is\n              much more conservative and essentially will not influence any\n              scaffold assignments made by a binner, only unbinned sequences\n              will be assigned to their (in terms of assembly graph) neighboring",
    "bins. Correction mode on one hand could correct some incorrect\n              sequence assignment (especially if such contigs are relatively\n              short), but on the other hand might possibly increase possible\n              contamination especially if the initial binning was not quite\n              pure. We recommend using propagation mode on relatively pure\n              binning when the goal is to complete the binning via assigning of\n              short unbinned scaffolds to relevant bins, and correction mode\n              otherwise.\n            \n            Running mode types: Default vs. Sparse\n            \nNote: In addition to the default\n              launch modes, BinSPreader can work in a special mode designed to\n              refine sparse binning, which assumes that the total length of the\n              binned contigs is much lower than the total length of the\n              assembly. In this mode binning propagation from initially binned\n              edges is limited by constant graph distance threshold. To enable\n              sparse mode use “--sparse-propagation” option. Usually sparse mode\n              is required when the initial binning undergoes additional\n              filtering / processing (e.g., by tools such as MetaWRAP20[href=https://www.wicell.org#bib20]\n              or DAS_Tool21[href=https://www.wicell.org#bib21]) or there are lots of unbinned sequences.\n            \n            Binning types: Single vs. Multiple\n            \nNote: BinSPreader supports\n              multiple assignment of bins, which means that a contig may be\n              included into several independent bins after refining. This might\n              be helpful to append highly conservative sequences encoding\n              house-keeping genes, such as rRNA, to recovered MAGs. Use “-m”\n              option to toggle this mode. Unlike other modes, which output\n              resulting binning in a tab-separated file binning.tsv containing\n              two columns (“tall” format), in multiple assignment mode by\n              default the output file has several columns (“wide” format). A\n              dedicated “--tall-multi” flag could be used to control this\n              behavior and switch output from wide to tall format.\n            \n        Run BinSPreader: Below there are example commands to run BinSPreader\n        with different options. It is also recommended to use tee command to\n        save log information.\n        \n            Correction mode (other options as default):",
    "> bin-refine assembly/assembly_graph_with_scaffolds.gfa\n                  metabat2/binning.tsv binspreader-Rcorr -t 10 -Rcorr | tee\n                  binspreader-Rcorr.log\n            Propagation mode (other options as default):\n            \n> bin-refine assembly/assembly_graph_with_scaffolds.gfa\n                  metabat2/binning.tsv binspreader-Rprop -t 10 -Rprop | tee\n                  binspreader-Rprop.log\n            Correction mode with multiple assignment:\n            \n> bin-refine assembly/assembly_graph_with_scaffolds.gfa\n                  metabat2/binning.tsv binspreader-Rcorr-Pmax -t 10 -Rcorr\n                  --tall-multi -m | tee binspreader-Rcorr-Pmax.log.\n            Correction mode with sparse propagation:\n            \n> bin-refine assembly/assembly_graph_with_scaffolds.gfa\n                  metabat2/binning.tsv binspreader-Rcorr-sparse -t 10 -Rcorr\n                  --sparse-propagation | tee binspreader-Rcorr-sparse.log.\nCaution: Pay attention to the edge degree value that is\n            calculated during BinSPreader execution. For the given MBARC26\n            assembly the edge degree is equal to 1.26 (it can be slightly\n            different in your case), which roughly can be interpreted as on\n            average each edge of the graph has more than one neighbor.\n            BinSPreader relies on connectivity information provided by the\n            assembly graph, so edge degree less than 1 usually indicates\n            fragmented assembly graph where refining may have no effect. You can\n            pull the required line from the BinSPreader log by executing the\n            following.\n            \n> less binspreader-Rprop.log | grep \"edge\n                  degree\"\n            A possible solution for a disconnected assembly graph with an edge\n            degree below 1 is to provide BinSPreader with an additional\n            paired-end linkage information (“--dataset” option, described above)\n            that increases graph connectivity and facilitates refining. Note\n            that fragmented assembly graph often is an indicator of upstream\n            problems, e.g., issues with sequencing library preparation,\n            insufficient sequencing depth, elevated error rates, etc. and might\n            suggest QC of the assembly input data.\n            \nOptional: Sometimes binners\n              split a single genome into two or more bins, which overall tend to\n              be very pure but otherwise not complete. Such bins usually overlap\n              in an assembly graph, and great extent of the overlap could\n              potentially be a signal to merge such bins. Apart from that, bins\n              overlap could measure shared genome content for bins that\n              represent closely-related species.",
    "To expose this information, BinSPreader can optionally compute\n            refined bins pairwise similarity matrix based on their overlap in an\n            assembly graph (controlled by “--bin-dist” flag). Refer to\n            Tolstoganov et al.1[href=https://www.wicell.org#bib1] for details on\n            the graph overlap similarity function definition. You can visualize\n            hierarchical clustering of bin distance values calculated as (1 –\n            bin similarity) using script visualize_bin_dist.py.\n            Replace <folder_name> with a real path.\n            \n> python scripts/visualize_bin_dist.py -i\n                  <folder_name>/bin_dist.tsv -o\n                  figures/dendrogram.png\nFigure 1[href=https://www.wicell.org#fig1] shows a clustering tree calculated from\n            MBARC26 bins obtained with MetaBAT2 and refined with BinSPreader in\n            correction mode. Branch color indicates taxonomic assignment of bins\n            determined using reference genomes that are available for MBARC26\n            mock dataset. As expected, bins representing the same species, as\n            well as closely related species, typically cluster together.\n          \nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2802-Fig1.jpg\n          Figure 1. Hierarchical clustering of bin distances calculated for\n          MetaBAT2 bins refined with BinSPreader in correction mode (MBARC26\n          dataset)\n        \nEvaluate results\nTiming: 4 h\n      Most often the quality of bacterial MAGs is assessed by CheckM tool (Parks\n      et al., 2015), which scans bins for a determined set of single-copy genes\n      to estimate their completeness and contamination. This section describes\n      how to visualize results of binning before and after refining for\n      comparison.\n    \n        Prepare input bins as FASTA files. To create bins in fasta format\n        required by CheckM use extract_fasta_bins.py script:\n      \n> for FOLDER in binspreader-Rcorr binspreader-Rprop\n          binspreader-Rcorr-Pmax binspreader-Rcorr-sparse ; do python\n          scripts/extract_fasta_bins.py -b $FOLDER/binning.tsv -i\n          assembly/scaffolds.fasta -o $FOLDER/bins/ ; done\nNote: this script assumes that the input\n      binning file is tab-separated and contains two columns (“long” format). If\n      it has many columns (“wide” format), conversion should be done using\n      wide2long.py script:\n    \n> python scripts/wide2long.py\n          <binning_wide.tsv> > <binning_long.tsv>\nFor example.\n> python scripts/wide2long.py\n          binspreader-Rcorr-Pmax/binning.tsv > binspreader-Rcorr-Pmax/binning_long.tsv\n        Run CheckM on original and refined bins. This command will sequentially\n        run CheckM on five sets of bins:",
    "> for FOLDER in metabat2 binspreader-Rcorr binspreader-Rprop\n          binspreader-Rcorr-Pmax binspreader-Rcorr-sparse ; do checkm lineage_wf\n          -t 10 -x fasta --tab_table -f $FOLDER/checkm_result.tsv $FOLDER/bins\n          $FOLDER/checkm ; done\nNote: “lineage_wf” states for CheckM\n      workflow in which quality is estimated with lineage-specific markers\n      identified individually for each bin. Argument “-x” is used to specify\n      non-default file extension of binning files. Option “--tab_table” is used\n      to write a report in tab-separated format to a file specified via the “-f”\n      flag.\n    \n        Inspect text reports and visualize results with script\n        draw_binning_stats.py:\n      \n> python scripts/draw_binning_stats.py --stats\n          metabat2/checkm/storage/bin_stats_ext.tsv,binspreader-Rcorr/checkm/storage/bin_stats_ext.tsv,binspreader-Rprop/checkm/storage/bin_stats_ext.tsv,binspreader-Rcorr-Pmax/checkm/storage/bin_stats_ext.tsv,binspreader-Rcorr-sparse/checkm/storage/bin_stats_ext.tsv\n          --checkm --output figures --name MBARC26 --labels\n          MetaBAT2,BinSPreader-Rcorr,BinSPreader-Rprop,BinSPreader-Rcorr-Pmaх,BinSPreader-Rcorr-sparse\nNote: The script will output plots that\n      demonstrate completeness, contamination and F1 score for each binning\n      assessed with CheckM.\n    \nHere we estimate F1 as.\n(Completeness + Contamination) / (Completeness ∗ Contamination)\n      to reflect overall balance between these two metrics. After execution of\n      this command six figures called <metrics_name>_rank_index.png and\n      <metrics_name>_total_length.png will appear in directory figures/."
  ],
  "subjectAreas": [
    "Genomics",
    "Sequence Analysis",
    "Sequencing",
    "Bioinformatics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}