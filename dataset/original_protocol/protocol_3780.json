{
  "id": 3983,
  "origin_website": "Cell",
  "title": "Protocol for the processing and downstream analysis of phosphoproteomic data with PhosR",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nStep 1: Installing PhosR\nTiming: 5 min\nFull installation of PhosR includes downloading the PhosR package from GitHub or BioConductor. To use the latest developmental version of PhosR, install from GitHub. An example of how to perform all steps of this protocol using real data is available on the project GitHub at https://pyanglab.github.io/PhosR/articles/web/PhosR_STAR_protocols.html[href=https://pyanglab.github.io/PhosR/articles/web/PhosR_STAR_protocols.html].\nInstall PhosR by running the following code:\n> if(!require(devtools)){\n> install.packages(\"devtools\") # If not already installed\n> }\n> devtools::install_github(\"PYangLab/PhosR\",\nbuild_opts = c(\"--no-resave-data\", \"--no-manual\"),\nbuild_vignettes = TRUE,\ndependencies = TRUE)\n> library(PhosR)\nTo access the vignette directly from R console, run the following code after installation:\n> browseVignettes(\"PhosR\")\nCritical: To install all dependencies, you will need to update to the recommended R version (4.0.3 or above).\nNote: Note that all the necessary data needed to reproduce the code can be downloaded from https://github.com/PYangLab/PhosR_STAR_Protocols[href=https://github.com/PYangLab/PhosR_STAR_Protocols].\nStep 2: Creating a PhosphoExperiment object from a MaxQuant output\nTiming: 10 min\nTo increase the usability of PhosR functions, we implement a “PhosphoExperiment” (ppe) object based on the “SummarizedExperiment” class. To create the PhosphoExperiment object, you will be required to provide a quantification matrix where columns refer to samples and rows refer to phosphosites. Additional annotation labels for phosphosites should be provided alongside the matrix, including the phosphosite residue and position, “sequence window” that captures the amino acids flanking the phosphorylation sites, and the official gene symbol of the host protein in capital letters.\nHere, we will show the basic steps for generating a PhosphoExperiment object for an exemplar MaxQuant-processed phosphoproteomic data from two liver cell lines, FL83B and Hepa 1-6 cells (Humphrey et al., 2015[href=https://www.wicell.org#bib6]). This dataset contains the phosphoproteomic quantifications of mouse hepatocyte cell lines that were treated with either PBS (mock) or insulin. Each condition includes six biological replicates.",
    "Load the txt output file to an R environment\n> phospho_hepatocyte_raw <- read.delim(\"Data/PXD001792_raw_hepatocyte.txt\", header = TRUE)\nClean and process the raw txt files to extract quantifications.\nTo delete reverse matches and potential contaminants.\n> del <- which(phospho_hepatocyte_raw[,\"Reverse\"]==\"+\" | phospho_hepatocyte_raw[,\"Potential.contaminant\"]==\"+\")\n> phospho_hepatocyte_clean <- phospho_hepatocyte_raw[-del,]\nWe subset the raw data to select columns with “Intensity” values.\n> PXD001792_raw_hepatocyte <- phospho_hepatocyte_clean[,grep(\"Intensity\", colnames(phospho_hepatocyte_clean))]\nCreate the PhosphoExperiment Object\nCreating the base PhosphoExperiment object\n> ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(PXD001792_raw_hepatocyte)))\nAdd site annotations to the object\n> GeneSymbol <- toupper(sapply(strsplit(as.character(phospho_hepatocyte_clean[,\"Gene.names\"]), \";\"), function(x){x[1]}))\n> Residue <- as.character(phospho_hepatocyte_clean [,\"Amino.acid\"])\n> Site <- as.numeric(phospho_hepatocyte_clean [,\"Position\"]) >\nSequence <- sapply(strsplit(as.character(phospho_hepatocyte_clean[,\"Sequence.window\"]), \";\"), function(x){x[1]})\n> ### add these annotations to respective ppe slots > ppe@GeneSymbol <- GeneSymbol\n> ppe@Residue <- Residue\n> ppe@Site <- Site\n> ppe@Sequence <- Sequence\nAlternatively, we can create PhosphoExperiment object as following\n> ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(PXD001792_raw_hepatocyte)), Site = Site, GeneSymbol = GeneSymbol, Residue = Residue, Sequence = Sequence)\nLastly add colData information\n> sample_name <- strsplit(gsub(\"ˆIntensity.\", \"\", colnames(ppe)), \"_\")\n> df <- S4Vectors::DataFrame(\n> cellline = sapply(sample_name, \"[[\", 1),\n> condition = sapply(sample_name, \"[[\", 2),\n> replicate = sapply(sample_name, \"[[\", 3)\n> )\n> rownames(df) <- colnames(ppe)\n> SummarizedExperiment::colData(ppe) <- df\nHave a quick glance of the object\n> ppe\n> dim(ppe)\nAdditional arguments\nUniprotID: Uniprot ID of the protein which has the phosphosite\nLocalization: localization reliability of the phosphosite\nThe final output of “Step 2: Creating a PhosphoExperiment object from a MaxQuant output[href=https://www.wicell.org#sec3.2]” is a PhosphoExperiment object containing the quantification matrix and site annotations of all phosphosites.\nCritical: Different preprocessing software may output the key data fields required for the PhosphoExperiment in different ways. Please ensure that the format used conform to the requirements in PhosR. The specific requirements are outlined below.\nRequirements of the basic phosphosite features",
    "Position of the phosphosite: An integer vector denoting the position of the phosphosite within the protein\nResidue of the phosphosite: A character vector denoting the residue of the phosphosite as a single letter (“S”, “Y”, or “T”)\nGene symbol: A character vector containing gene symbols in upper case\nSequence window: A character vector denoting the sequence window, typically of 15–31 in length. The residues in the sequence window should be capitalized. Note that the predicted phosphosite should reside in the middle of the window. Any phosphosites that are found near the N or C terminus of the protein will require a placeholder (i.e., add “_” to either side of the flanking sequence) to position the phosphosite in concern at the middle of the sequence window (Most processing software will do this for you automatically).\nStep 3: Data pre-processing and differential phosphosite identification\nTiming: 10 min\nThe presence of missing values in quantitative phosphoproteomics reduces the completeness of data. Whilst imputation has been widely applied to handle missing values, it remains a major challenge when analyzing phosphoproteomic data and has significant impact on downstream analysis such as normalization. PhosR provides users with greater flexibility for imputation with imputation functions such as ‘scImpute’ and ‘tImpute’. Here, we will go through each function step by step to demonstrate their use in imputing phosphoproteomic data. We will call differentially phosphorylated sites between two cell lines FL83B and Hepa 1-6 to visualize the change in phosphorylation upon insulin simulation.\nLog transformation\nWe perform log2 transformation of the data\n> logmat <- log2(SummarizedExperiment::assay(ppe, \"Quantification\"))\n> # mark any missing values as NA\n> logmat[is.infinite(logmat)] <- NA\n> SummarizedExperiment::assay(ppe, \"Quantification\") <- logmat\nPerform filtering\nWe first extract the grouping information for cell type and condition\n> grps <- paste0(SummarizedExperiment::colData(ppe)$cellline, \"_\", SummarizedExperiment::colData(ppe)$condition)",
    "We filter for sites with at least 50% quantification rate (q ≥ 0.5) in one or more conditions\n> ppe <- selectGrps(ppe, grps, 0.5, n=1)\nCheck the filtering results\n> dim(ppe)\nNote: The ‘Quantification’ assay in PhosphoExperiment object is now filtered of phosphosites with high number of missing values. The user may wish to save the unfiltered matrix, `PXD001792_raw_hepatocyte, for future analysis.\nPerform imputation of missing values\nPhosR enables site- and condition-specific imputation. Here, for each phosphosite in each condition, we impute its missing values in that condition (if any) using site- and condition-specific imputation if the quantification rate within that condition is equal to or greater than a desired percentage (such as ≥ 50% in the example below).\n> set.seed(123)\n> ppe <- scImpute(ppe, 0.5, grps)\n> ppe\nLastly, we can impute the remaining sites using tail-based imputation\n> ppe <- tImpute(ppe, assay = \"imputed\")\nNote: At this stage, the imputed quantification matrix is stored as an assay called ‘imputed’ in the PhosphoExperiment object.\nCentering data across their median\n> ppe <- medianScaling(ppe, scale = FALSE, assay = \"imputed\")\n> ppe\nNote: The scaled quantification matrix can be found as the ‘scaled’ matrix in the PhosphoExperiment object.\nCall differentially phosphorylated sites for the FL83B and Hepa 1-6 insulin stimulation dataset\nWe use limma package for calling for differentially phosphorylated sites between control and insulin-simulated conditions in the two cell types.\n> library(limma)\n> design <- model.matrix(~ grps - 1)\n> fit <- lmFit(ppe@assays@data$scaled, design)\n> contrast.matrix <- makeContrasts(grpsFL83B_Ins-grpsFL83B_Control, grpsHepa1.6_Ins-grpsHepa1.6_Control, levels=design)\n> fit2 <- contrasts.fit(fit, contrast.matrix)\n> fit2 <- eBayes(fit2)\nVisualize differentially phosphorylated sites using a volcano plot (Figure 1[href=https://www.wicell.org#fig1]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/701-Fig1.jpg\nFigure 1. Volcano plots visualizing significantly up- and down-regulated phosphosites",
    "Differential phosphosites can be called using normalized LFQ values and visualized using volcano plots. The above plots show up- (red) and down-regulated (blue) phosphosites in the two liver cell lines, respectively.\n> par(mfrow=c(1,2))\n> FL83B.DE <- topTable(fit2, coef=\"grpsFL83B_Ins - grpsFL83B_Control\", number = Inf)\n> plot(FL83B.DE[,\"logFC\"], -log10(FL83B.DE[,\"adj.P.Val\"]), main=\"FL83B\", xlab=\"Log2 FC\", ylab=\"-Log10(Adjust P)\")\n> sel <- which(FL83B.DE[,\"adj.P.Val\"] < 0.05 & FL83B.DE[,\"logFC\"] > 0)\n> points(FL83B.DE[sel,\"logFC\"], -log10(FL83B.DE[sel,\"adj.P.Val\"]), pch=16, col=\"red\")\n> sel <- which(FL83B.DE[,\"adj.P.Val\"] < 0.05 & FL83B.DE[,\"logFC\"] < 0)\n> points(FL83B.DE[sel,\"logFC\"], -log10(FL83B.DE[sel,\"adj.P.Val\"]), pch=16, col=\"blue\")\n> Hepa1.6.DE <- topTable(fit2, coef=\"grpsHepa1.6_Ins - grpsHepa1.6_Control\", number = Inf)\n> plot(Hepa1.6.DE[,\"logFC\"], -log10(Hepa1.6.DE[,\"adj.P.Val\"]), main=\"Hepa 1-6\", xlab=\"Log2 FC\", ylab=\"-Log10(Adjust P)\")\n> sel <- which(Hepa1.6.DE[,\"adj.P.Val\"] < 0.05 & Hepa1.6.DE[,\"logFC\"] > 0)\n> points(Hepa1.6.a.DE[sel,\"logFC\"], -log10(Hepa1.6.DE[sel,\"adj.P.Val\"]), pch=16, col=\"red\")\n> sel <- which(Hepa1.6.DE[,\"adj.P.Val\"] < 0.05 & Hepa1.6.DE[,\"logFC\"] < 0)\n> points(Hepa1.6.DE[sel,\"logFC\"], -log10(Hepa1.6.DE[sel,\"adj.P.Val\"]), pch=16, col=\"blue\")\nAfter imputation, we calculate the ratio of each value against the mean phosphosite values of the control samples. The ratios were calculated independently for each of the two cell lines (Figure 2[href=https://www.wicell.org#fig2]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/701-Fig2.jpg\nFigure 2. Boxplot of quantifications before and after taking the ratio\nPhosphoproteomic data from label-free quantification (LFQ) are typically converted to ratios against the control samples to generate fold changes (FCs). The boxplots of phosphoproteomic quantifications demonstrate the change in distribution of values before and after conversion for each sample.\n> FL83B.ratio <- SummarizedExperiment::assay(ppe, \"scaled\")[, grep(\"FL83B_\", colnames(ppe))] -\nrowMeans(SummarizedExperiment::assay(ppe, \"scaled\")[,grep(\"FL83B_Control\", colnames(ppe))])\n> Hepa.ratio <- SummarizedExperiment::assay(ppe, \"scaled\")[, grep(\"Hepa1.6_\", colnames(ppe))] -\nrowMeans(SummarizedExperiment::assay(ppe, \"scaled\")[,grep(\"Hepa1.6_Control\", colnames(ppe))])\n> SummarizedExperiment::assay(ppe, \"ratio\")<- cbind(FL83B.ratio, Hepa.ratio)\n> par(mfrow=c(1,2))\n> boxplot(ppe@assays@data$scaled, ylab=\"Log2 LFQ\", main=\"Normalized LFQ data\", las=2, col=factor(rep(1:4, each=6)))\n> boxplot(ppe@assays@data$ratio, ylab=\"Log2 Fold Change\", main=\"Ratio data\", las=2, col=factor(rep(1:4, each=6)))\nLastly, we will save this processed ppe object for later use\n> PXD001792_ppe_hepatocyte <- ppe\n> save(PXD001792_ppe_hepatocyte, file = \"Data/PXD001792_ppe_hepatocyte.RData\")",
    "Critical: After imputation, data from label-free quantification are typically converted to ratios before subsequent analysis. In contrast to label-free data, you do not need to take ratios of phosphoproteomic data derived from SILAC quantification since the values are inherently ratios (typically with respect to the control sample). The tail-based imputation (Beck et al., 2015[href=https://www.wicell.org#bib1]) is designed specifically for label-free data (such as the one used in our example) and is not applicable to SILAC data.\nStep 4: Identifying stably phosphorylated sites\nTiming: 10–30 min\nSeveral commonly used data normalization approaches such as the 'removal of unwanted variation” (RUV) (Gagnon-Bartsch and Speed, 2012[href=https://www.wicell.org#bib3]) require a set of internal standards whose expression are known to be unchanged in the samples measured. This is a challenge for phosphoproteomic data since phosphorylation is a highly dynamic biochemical process. Identifying a set of stably phosphorylated sites (SPSs) is a unique feature of PhosR which enables users to identify context-dependent sets of SPSs. We also included a set of 100 SPSs as a resource, identified from multiple high-quality datasets generated from different cell types and experimental conditions (Kim et al., 2021[href=https://www.wicell.org#bib7]). As an example, we will use three datasets to demonstrate how SPSs can be identified from multiple phosphoproteomic datasets. Users may wish to replace the example datasets with their own collection of datasets.\nLoad and set up datasets\nLoad datasets\n> load(\"Data/PXD010621_ppe_ESC.RData\", verbose = TRUE)\n> load(\"Data/PXD003631_ppe_adipocyte.RData\",\nverbose = TRUE)\n> load(\"Data/phospho_ppe_adipocyte.RData\",\nverbose = TRUE)\nSimplify names of datasets\n> ppe1 <- PXD010621_ppe_ESC\n> ppe2 <- PXD003631_ppe_adipocyte\n> ppe3 <- phospho_ppe_adipocyte\nMake a list of all PhosphoExperiment objects\n> ppe.list <- list(ppe1, ppe2, ppe3)\nMake a list of grouping information of each dataset\n> cond.list <- list(\ngrp1 = gsub(\"_.+\", \"\", colnames(ppe1)),\ngrp2 = gsub(\"_r[0-9]\", \"\", colnames(ppe2)),\ngrp3 = colnames(ppe3))",
    "Note: The regular expression used for defining ‘cond.list’ above is highly specific to the example dataset used in this tutorial. Users should adopt and modify these codes according to the specific experimental design and conditions in their own datasets.\nCritical: If inputs are not PhosphoExperiment objects, please transfer the data format to a PhosphoExperiment object (refer to the instructions in “Step 2: Creating a PhosphoExperiment object from a MaxQuant output[href=https://www.wicell.org#sec3.2]”). Example datasets are processed datasets after filtering, normalization, and ratio converting. Please refer to “Step 4: Identifying stably phosphorylated sites[href=https://www.wicell.org#sec3.4]” for data normalization guidance.\nIdentify SPSs by calling getSPS()\n> generate a vector of the selected assays in each of the PhosphoExperiment objects\n> assays <- \"Quantification\"\n> inhouse_SPSs <- getSPS(phosData = ppe.list,\nassays = assays,\nconds = cond.list, num = 100)\nNote: Please note that presence of sufficient overlapped phosphosites identified from the input datasets is critical to identify SPSs. You will receive an error if the number of overlapped sites is fewer than 200 in at least two datasets or fewer than 1,000 across all input datasets.\nRequired parameters:\nphosData: a list of users' PhosphoExperiment objects from which generate SPSs. For creating PhosphoExperiment objects, please refer to “Step 2: Creating a PhosphoExperiment object from a MaxQuant output[href=https://www.wicell.org#sec3.2]”. Please note that the datasets in the list require to be processed.\nconds: a list of vectors contains the conditions or time-course labels of each sample in the phosphoExperiment objects.\nassays: a vector indicating the assay to select, by default is “Quantification”.\nnum: the number of SPSs to identify, by default is 100.\nThe output of “Step 4: Identifying stably phosphorylated sites[href=https://www.wicell.org#sec3.4]” will be a set of stably phosphorylated sites identified across the input datasets that users provide. The SPSs will be used to perform batch correction.",
    "Step 5: Normalization and batch correction of data sets\nTiming: 10 min\nA common but critical step in phosphoproteomic data analysis is to correct for batch effect. Without batch effect correction, it is often not possible to analyze datasets in an integrative manner. To perform data integration and batch effect correction, we utilize a set of stably phosphorylated sites (SPSs) across a panel of phosphoproteomic datasets (defined from “Step 4: Identifying stably phosphorylated sites[href=https://www.wicell.org#sec3.4]”) and implement normalization using RUV-III (Molania et al., 2019[href=https://www.wicell.org#bib8]). To demonstrate batch effect correction, we will perform RUVphospho to normalize a SILAC data from L6 myotubes treated with two factors: 1) AICAR, an analog of adenosine monophosphate (AMP) that stimulates AMPK activity and/or 2) insulin.\nCritical: RUV-III requires a complete data matrix. If you have not followed through the steps above, you will need to perform imputation of the missing values. The imputed values are removed by default after normalization but can be retained for downstream analysis if the users wish to use the imputed matrix.\nLoad PhosphoExperiment objects\n> load(\"Data/PXD019127_ratio_myoblast.RData\",\nverbose = TRUE)\n> ppe <- PhosphoExperiment(assays = list(Quantification = as.matrix(PXD019127_ratio_myoblast)))\nAdd site annotations to PhosphoExperiment object\n> rowNames <- strsplit(rownames(ppe), \"~\")\n> ppe@GeneSymbol <- toupper(sapply(rowNames, \"[[\", 2))\n> ppe@Residue <- gsub(\"[0-9]\",\"\", sapply(rowNames, \"[[\", 3))\n> ppe@Site <- as.numeric(gsub(\"[A-Z]\",\"\", sapply(rowNames, \"[[\", 3)))\n> ppe@Sequence <- sapply(rowNames, \"[[\", 4)\nAdd colData information\n> sample_name <- strsplit(colnames(ppe), \"_\")\n>\n> df <- S4Vectors::DataFrame(\n> condition = sapply(sample_name, \"[[\", 1),\n> replicate = gsub(\"exp\", \"\", sapply(sample_name, \"[[\", 2))\n> )\n> rownames(df) <- colnames(ppe)\n> SummarizedExperiment::colData(ppe) <- df\nDiagnosing batch effect\nHierarchical clustering\n> plotQC(SummarizedExperiment::assay(ppe, \"Quantification\"), panel = \"dendrogram\",\ngrps = SummarizedExperiment::colData(ppe)$condition,\nlabels = colnames(ppe)) + ggplot2::ggtitle(\"before batch correction\")\nPCA plot\n> plotQC(SummarizedExperiment::assay(ppe, \"Quantification\"), panel = \"pca\",\ngrps = SummarizedExperiment::colData(ppe)$condition,\nlabels = colnames(ppe)) + ggplot2::ggtitle(\"before batch correction\")",
    "Correcting batch effect\nConstruct a design matrix by condition\n> design <- model.matrix(~ SummarizedExperiment::colData(ppe)$condition - 1)\n> head(design) # observe first 6 rows of the design matrix\nDefine negative controls sites\n> # Given that the rownames of a matrix ppe is in a format 'GENESYMBOL;RESIDUE;SITE;'\n> sites <- paste(\nsapply(ppe@GeneSymbol, function(x)x),\n\";\",\nsapply(ppe@Residue, function(x)x),\nsapply(ppe@Site, function(x)x),\n\";\",\nsep = \"\")\n> data(SPSs)\n> ctl <- which(sites %in% SPSs)\nRun RUVphospho\n> ppe <- RUVphospho(ppe, M = design, k = 3, ctl = ctl)\nQuality control to assess the removal of batch effect\nHierarchical clustering\n# plot before and after batch correction\n> p1 <- plotQC(SummarizedExperiment::assay(ppe,\"Quantification\"),\ngrps= SummarizedExperiment::colData(ppe)$condition,\nlabels = colnames(ppe),\npanel = \"dendrogram\")\n> p2 <- plotQC(SummarizedExperiment::assay(ppe,\"normalized\"),\ngrps= SummarizedExperiment::colData(ppe)$condition,\nlabels = colnames(ppe),\npanel=\"dendrogram\")\n> ggpubr::ggarrange(p1, p2, nrow = 1)\nPCA\n# plot before and after batch correction\n> p1 <- plotQC(SummarizedExperiment::assay(ppe,\"Quantification\"),\ngrps= SummarizedExperiment::colData(ppe)$condition,\nlabels = colnames(ppe),\npanel = \"pca\")\n> p2 <- plotQC(SummarizedExperiment::assay(ppe,\"normalized\"),\ngrps= SummarizedExperiment::colData(ppe)$condition,\nlabels = colnames(ppe),\npanel=\"pca\")\n> ggpubr::ggarrange(p1, p2, nrow = 1)\nWe can now save the final processed data for future use\n> PXD019127_ppe_myoblast = ppe\n> save(PXD019127_ppe_myoblast,\nfile = \"Data/PXD019127_ppe_myoblast.RData\")\nPause Point: This is an ideal pause point as we have generated a fully processed data. By now, you should have a good idea of the data quality and have performed the necessary processing to filter any suboptimal sites, imputed missing values (if present) and diagnosed and corrected any batch effect present in the data.\nStep 6: Predicting kinase substrates\nTiming: 15 min",
    "A key end-goal of phosphoproteomic data analysis is to identify kinases that are responsible for the phosphorylation of specific sites. The basic computational approach to annotate kinases to their substrates or phosphosites is to find consensus amino acid sequences around the phosphorylation site. We can go beyond this approach by considering cell type and/or treatment (perturbation) specificity of phosphorylation. PhosR implements a multi-step framework that contains two major components including (i) a kinaseSubstrateScore function which scores a given phosphosite using kinase recognition motif and phosphoproteomic dynamics, and (ii) a kinaseSubstratePred function which synthesize the scores generated from (i) for predicting kinase-substrate relationships using an adaptive sampling-based positive-unlabeled learning method (Yang et al., 2018[href=https://www.wicell.org#bib11]).\nIn the original PhosR publication, we demonstrate the application of the scoring method to the myotube phosphoproteome and uncover potential kinase-substrate pairs and global relationships between kinases. We confirm well established substrates of AMPK in our publication: ACACA S79, AKAP1 S103, SMCR8 S488 (Hoffman et al., 2015[href=https://www.wicell.org#bib4]) and MTFR1L S100 (Schaffer et al., 2015[href=https://www.wicell.org#bib10]). Importantly, PhosR generates a list of potential candidates not included in the PhosphoSitePlus database for validation.\nPrepare inputs\nLoad the PhosphoExperiment object\n> load(\"Data/PXD019127_ppe_myoblast.RData\",\nverbose = TRUE)\n> ppe <- PXD019127_ppe_myoblast\n> mat <- SummarizedExperiment::assay(ppe, \"normalized\")\nCritical: If you have not processed your data, please go through Steps 1–5 to perform the necessary processing prior to performing the downstream analysis in Steps 6 and 7.\nFilter for up-regulated phosphosites\n> # filter for up-regulated phosphosites\n> mat.mean <- meanAbundance(mat,\ngrps = SummarizedExperiment::colData(ppe)$condition)\n> aov <- matANOVA(mat=mat,\ngrps = SummarizedExperiment::colData(ppe)$condition)\n> idx <- (aov < 0.05) & (rowSums(mat.mean > 0.5) > 0)\n> mat.reg <- mat[idx, ,drop = FALSE]\nStandardize the matrix\n> mat.std <- standardize(mat.reg)\n> rownames(mat.std) <- sapply(strsplit(rownames(mat.std), \"~\"), function(x){gsub(\" \", \"\", paste(toupper(x[2]), x[3], \"\", sep=\";\"))})",
    "Critical: To calculate the profile matching score, we rely on the z-score transformed matrix to compare the profiles of phosphosites. Thus, the standardization step is critical.\nKinase substrate scoring step integrates information from both kinase recognition motif (i.e., motif matching score) and experimental perturbation (i.e., profile matching score) for prioritizing kinases that may be regulating the phosphorylation level of each site quantified in the dataset.\nThe kinase-substrate prediction step requires the following specific inputs:\n‘substrate.list’ denotes an object that contains all kinases and their substrate peptide sequences from the PhosphoSitePlus database. This is used to compute the position-specific motif matching score.\n> data('KinaseMotifs')\n> head(PhosphoSite.mouse)\n‘mat’ denotes the standardized matrix. PhosR uses a pre-defined number of substrates to compare the dynamic phosphorylation profiles of the substrate against that of their known kinases. Next, the profile matching scores of each phosphosite quantified in ‘mat’ are calculated by using Pearson’s correlation with respect to the averaged profiles of known substrates of each of all kinases.\n> head(mat.std)\n‘seqs’ denotes a vector containing all the phosphosites detected in the phosphoproteomic dataset at hand. Note that if any filtering was performed in the previous step, we must perform the same filtering here.\n> seqs <- ppe@Sequence[idx]\n> head(seqs)\nRun PhosR kinase-substrate prediction with the default parameters. PhosR generates the final combined scores of the motif matching score and the profile matching score by taking into account the number of sequences and substrates used for calculating the motif and profile of the kinase.\n> kssMat <- kinaseSubstrateScore(substrate.list = PhosphoSite.mouse,\nmat = mat.std,\nseqs = seqs,\nnumMotif = 5,\nnumSub = 1)\nThere are two arguments that are set to default in ‘kinaseSubstrateScore’\n‘numMotif’ denotes the minimum number of sequences used for compiling the motif for each kinase. The default value is set to 5.",
    "‘numSub’ denotes the minimum number of phosphosites used for compiling the phosphorylation profile. The default value is set to 1.\nNote: Please ensure that there are no duplicate phosphosites by removing or aggregating them before running the kinase-substrate prediction (for a workaround please refer to Problem 5 in Troubleshooting).\nNote: Please be patient, as this step may take several minutes.\nAs the second and last step of kinase-substrate prediction, PhosR uses the ‘kinaseSubstratePred’ function to synthesize the scores generated from ‘kinaseSubstrateScore’ to predict the kinase-substrate relationships using an adaptive sampling-based positive-unlabeled learning method (Yang et al., 2018[href=https://www.wicell.org#bib11]). This step prioritizes the kinases that are most likely to regulate a phosphosite.\nUse the out of ‘kinaseSubstrateScore’ to run kinase substrate prediction\n> set.seed(1)\n> predMat <- kinaseSubstratePred(kssMat, top = 30)\nNote: While the default values in ‘kinaseSubstratePred’ provide reliable performance of PhosR, the user may wish to optimize the parameters for each phosphoproteomic dataset. Listed below are the parameters to choose with default values and tips for each selection provided.\nSelection of Additional Parameters\n‘ensembleSize’ denotes the number of the support vector machine (SVM) classifiers to be used in an ensemble. The default value is set to 10. Decreasing the number may speed up the process but may compromise the accuracy.\n‘top’ denotes the top number of kinase substrates to select. The top kinase substrates are selected based on the combined scores. They are used as positive examples for training SVMs for predicting substrates of that kinase. The default value is 50.",
    "‘cs’ denotes the score threshold. The default value is 0.8. This argument is used to filter any of the top kinases that do not meet a certain threshold. This argument would override the ‘top’ argument in that any substrates among the top 50 that do not meet the score threshold are excluded.\n‘inclusion’ denotes the minimal number of substrates required for a kinase to be selected. The default value is 20. Decreasing this number would increase the total number of kinases for which we generate kinase-substrate scores, and vice versa.\n‘iter’ denotes the number of iterations for adaSampling. AdaSampling procedure is used to update the SVM training examples based on the model confidence on each phosphosite. The default value is 5.\n‘verbose’ is set to TRUE by default, allowing the tracking of the analysis progress.\nPause Point: Once the desired parameters are used to successfully run the kinase-substrate prediction, you may find this to be a good place to pause and save the results before proceeding with the visualization steps.\nStep 7: Constructing signaling networks (signalomes)\nTiming: 10 min\nConstructing signaling networks referred to as “Signalomes” is a useful feature in PhosR that allows the users to obtain a global view of kinase regulation and to establish distinct modules of proteins that demonstrate similar kinase and dynamic regulation upon perturbation or across a time-course.",
    "An important feature of PhosR signalomes is that the resultant signaling modules denote a set of proteins and not phosphosites. Proteins are frequently phosphorylated at multiple sites and these sites may not necessarily be targeted by the same kinases. Site- and protein-centric analyses of phosphoproteomic data lie at opposite ends of the spectrum, with the former treating phosphosites on the same protein independently and ignoring the host protein information, and the latter focusing on a specific protein, losing information from individual phosphosites. Using our global kinase-substrate scoring of phosphosites, we generate signalomes wherein dynamic changes in phosphorylation within and across proteins are conjointly analyzed, allowing us to detect proteins that are co-regulated across multiple phosphosites.\nSignalome construction The signalome construction uses the outputs of ‘kinaseSubstrateScore’ and ‘kinaseSubstratePred’ functions for the generation of a visualization of the kinase regulation of discrete regulatory protein modules present in our phosphoproteomic data (Figure 3[href=https://www.wicell.org#fig3]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/701-Fig3.jpg\nFigure 3. Visualizations of global kinase-substrate relationships and signalomes\n(A) A heatmap of global kinase-substrate relationship scores. A clustered heatmap of the combined score from kinase-substrate scoring function for the top three phosphosites of all kinases evaluated in this study. A higher combined score denotes a better fit to a kinase motif and kinase-substrate phosphorylation profile of a phosphosite. Kinases are annotated to which kinase group they belong.\n(B) Signalomes identified from the phosphoproteomic data. The branching nodes denote the kinases for which substrates have been predicted, and the stem nodes denote the protein modules that they regulate. Edges between nodes connect kinases to the protein modules they regulate.\nPrepare inputs\n‘KSR’ denotes the output of the kinase-substrate relationship scoring function.\n‘predMatrix’ denotes the output of the ‘kinaseSubstratePred’ function.",
    "‘exprsMat’ denotes the matrix with rows corresponding to phosphosites and columns corresponding to samples. Users may wish to perform various processing steps such as filtering, imputations, and normalization.\n‘KOI’ denotes a vector containing kinases of interest for which the expanded signalomes will be generated. The Signalomes function also outputs signalomes associated to any kinase of interest (referred to as extended signalome of a kinase). To facilitate assessment of proteins and phosphosites that are under similar regulation, the extended signalome of a kinase of interest combines cognate signalomes from other kinases that share a high degree of similarity in substrate regulation.\nThen to generate the signalomes, run:\n> kinaseOI = c(\"AKT1\")\n> signalomesRes <- Signalomes(KSR = kssMat,\npredMatrix = predMat,\nexprsMat = mat.std,\nmodule_res = 6,\nKOI = kinaseOI)\nThere are a number of important arguments in the ‘Signalomes’ function.\n‘module_res’ denotes the argument to control the number of final modules.\n‘threskinaseNetwork’ denotes the threshold used to select interconnected kinases for the expanded signalomes.\n‘signalomeCutoff’ refers to the cutoff used to filter kinase-substrate relationships based on scores from the ‘kinaseSubstratePred’ function. A cutoff of 0.5 is used as default. By increasing the threshold, you can reduce the number of phosphosites used to generate the signalomes by selecting high confidence phosphosites only.\n‘filter’ requires a Boolean argument. When set to TRUE, the function filters modules with fewer than 10 proteins.\nVisualization of the Signalome as a Balloon Plot\nWe can visualize the signalomes as a balloon plot. Using the resulting visualization, we are better able to compare the differences in kinase regulation of the modules and the varying proportions of regulation. In the balloon plot, the size of the balloons denotes the percentage magnitude of kinase regulation in each module.\nThe code to generate the balloon plot is:\n> ### generate palette",
    "> my_color_palette <- grDevices::colorRampPalette(RColorBrewer::brewer.pal(8, \"Accent\"))\n> kinase_all_color <- my_color_palette(ncol(kssMat$combinedScoreMatrix))\n> names(kinase_all_color) <- colnames(kssMat$combinedScoreMatrix)\n> kinase_signalome_color <- kinase_all_color[colnames(predMat)]\n> plotSignalomeMap(signalomes = signalomesRes, color = kinase_signalome_color)\nConstruction of the Kinase Network\nFinally, we can also plot the signalome network that illustrates the connectivity between kinase signalome networks.\n> plotKinaseNetwork(KSR = kssMat,\npredMatrix = predMat,\nthreshold = 0.95,\ncolor = kinase_all_color)\nThe edges refer to the Pearson’s correlation of kinase regulation between the two nodes linked by the edge. The wider the link, the stronger the correlation. You can control the links shown in the visualization by changing the ‘threshold’. Decreasing this value, which is set to a default of ‘0.9’, would reveal more links."
  ],
  "subjectAreas": [
    "Proteomics",
    "Bioinformatics",
    "Systems Biology"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}