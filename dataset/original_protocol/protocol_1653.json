{
  "id": 1759,
  "origin_website": "Cell",
  "title": "FunGraph: A statistical protocol to reconstruct omnigenic multilayer interactome networks for complex traits",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nData preparation\nTiming: [4 h]\nBefore running FunGraph, user need to provide genotypic and phenotypic datasets, and they should be cleaned and merged to exactly the same format of the example data. Phenotypic dataset contains control group and the treatment group, each with same sample id as row names and same column number to represent the times phenotypic data were measured. Genotypic data have sample id as columns and SNP id as row names, and two additional columns “Linkage” and “Genetic_Distances(cM)” represent which linkage groups a certain SNP belongs and the position of SNPs in linkage groups (in centimorgan) respectively, while lacking of them did not affect the following calculation.\nOrganize the phenotypic data.\nRemove or replace missing values in the data.\nLog-transformed the phenotypic data by command log() if the number in the data vary widely is recommended, such as numbers differ by more than five order of magnitude.\nOrganize the genotype data.\nFunGraph only accept numeric value for calculation, SNP genotype data should be converted into 0,1,2 matrix.\nReplace missing value as 9.\nMatch the phenotypic and genotype data according to the same sample name. User can check the example genotypic and phenotypic datasets by following command:\n>View(geno)\n>View(pheno)\nFunctional mapping\nTiming: [hours to days; computing resources and data size affect the overall timing]\nBivariate Functional mapping (biFunMap) is crucial to this model, for it excavates how specific QTLs determines the complex trait expressed in various environments. The mean vector and covariance structure should be modeled according to the design of the experiment, and general steps are described as follows:\nFirst plot mean curve to check initial parameters by type command: Troubleshooting 2[href=https://www.wicell.org#sec6.3]\n>get_mean_curve_plot(\n  pheno_df = pheno,\n  times = 1:14,\n  init_sd_par = c(0.95, 12, 1.02, 8))",
    "pheno_df is phenotypic data, times is a vector of time point and init_sd_par is the initial parameters for biSAD covariance matrix\nFunGraph already wrapped the mean curve modelling, covariance matrix modelling and likelihood ratio calculation into a function, use get_biFunMap_result to store these calculation results to an object named as “result1” or anything user prefer: Troubleshooting 3[href=https://www.wicell.org#sec6.5]\n>result1 <- get_biFunMap_result(\n  geno_df = geno[,-1:-2],\n  pheno_df = pheno,\n  times = 1:14)\nthe input are the phenotypic and genotypic datasets, vector of time points and initial parameters for biSAD covariance matrix\nThe key of FunMap is modelling mean curve vector and covariance matrix by following two commands: Troubleshooting 4[href=https://www.wicell.org#sec6.7]\nModel the mean vector of the growth curve.\n>get_mu(mu_par, times)\nmu_par is a vector with five number corresponding to the unknown parameters in modified logistic growth curve, and times is a vector of time point\nModel the covariance structure using command:\n>get_biSAD1(par, n)\nwhere par is the parameters to input, in this case par equal to init_sd_par we checked in previous step, and n is column number of the matrix.\nAfter calculation is finished, visualization is carried out by following two functions:\nThe manhattan plot.\n>get_manh_plot(geno_df = geno, LR = result1$LR)\nthe input is genotypic data with additional information and LR values which was calculated and stored in “result1”\nThe genetic effect curve plot.\n>get_genetic_effect_plot(\n  genetic_effect = result1$genetic_effect,\n  number = 10)\nthe input is calculated genetic effect data and the number of sub-plots for demonstration\nOptional: Permutation tests can be used to determine the genome-wide critical threshold by command get_permutation, but it is extremely time-consuming.\nNote: the mean vector of example script is modeled by modified logistic growth equation, and covariance structure by biSAD(1).\nCritical: Always uses get_mean_curve_plot to check the initial parameters are sound for optimization before running the whole FunMap step.",
    "Functional clustering\nTiming: [hours to days; computing resources and data size affect the overall timing]\nAccording to modularity theory (Melo et al., 2016[href=https://www.wicell.org#bib9]), bivariate functional clustering (biFunClu) was introduced to cluster genetic effects into different functional modules (Wang et al., 2012[href=https://www.wicell.org#bib14]). A hybrid of the EM and simplex algorithms were implanted to obtain the functional modules.\nBy default, after running previous step, a file named “genetic_effect.csv” would be generated and shall be used in this step. Calculated genetic effect dataset is already stored in FunGraph, users can view this dataset by command: genetic_effect.\nPerform bifunctional clustering, i.e., clustering SNPs based on their temporal genetic effects in two different environments\nCheck the dataset for calculation, user can use dataset from previous step or manually provide it.\n>genetic_effect <- result1$genetic_effect\n>View(genetic_effect)\nPrepare all initial parameters for functional clustering.\n>input <- get_init_par(\n  data = genetic_effect,\n  k = 5,\n  legendre_order = 4,\n  times = 1:14,\n  init_SAD_par = c(1.06,0.25, 1.15, 0.18))\ndata is the dataset for cluster computation, and k is the number of clusters wanted, legendre_order is the order of Legendre Polynomials, times is time points and init_SAD_par is initial parameters for biSAD covariance matrix\nPerform functional clustering by command: Troubleshooting 3[href=https://www.wicell.org#sec6.5]\n>c1<-get_cluster(input = input, itermax = 100)\ninput is result from 8.a, and itermax control the maximum number of iteration in EM algorithm\nTake a look at classification result:\n>get_cluster_base_plot(\n  clustered_data = c1$clustered_data[[1]])\nthe input clustered_data directly from the get_cluster result\nSince we do not know the optimal number of clusters (k), we need to perform the above command for different values of k. For instance, by varying k from 1 to 10 clusters. The criteria of optimal k number was determined by BIC value, user can check it by command: Troubleshooting 5[href=https://www.wicell.org#sec6.9]\n>print(c1$BIC)",
    "Note: The mean vector of example script is modeled by Legendre Polynomials of order 4, and covariance structure by biSAD(1).\nCritical: When the Log-likelihood value changed drastically (e.g. from −20000 to −1000) in Functional Clustering using function get_cluster, an early stop for iteration should be made to prevent incorrect parameters estimation by setting “Delta” parameter in get_cluster function.\nLASSO-based variable selection\nTiming: [10 min]\nBy viewing all genes that function as a dynamic system, any one gene may interact with other genes. However, it is impossible that each gene interacts with every other gene to form a fully interconnected network because this does not assure the system to be robust in response to environmental change. FunGraph implements a LASSO-based procedure to choose a small set of the most significant genes that links with a given gene across time points.\nLasso-based variable selection to select the most significant relevant Modules/SNPs from Modules/SNPs for Module i/SNPs i.\nFirst calculate the relationship between modules.\n>get_interaction(data, col, reduction = FALSE)\nthe input data is the genetic effect data of modules, col is the number of rows, and reduction = FALSE means usually dimensionality reduction is not needed in performing variable selection between modules.\nThen the variable selection is performed within modules.\n>get_interaction(data, col, reduction = TRUE)\nthe input data is the genetic effect data of SNPs in a certain module\nOptional: The reduction = TRUE option can be FALSE in 10.b if there are no need for dimensionality reduction (e.g. the number of SNPs with in module is almost as same as the number of modules, usually less than 100).\nODE solving\nTiming: [hours to days; computing resources and data size affect the overall timing]",
    "A system of nLV ODEs are formulated according to evolutionary game theory (Wang et al., 2021[href=https://www.wicell.org#bib12]), with the independent part describing the inner genetic effect of SNP i and the dependent part describing the influential genetic effect of other SNPs. Thereafter, the genetic network could be reconstructed through the decomposition of net genetic effect of each SNP.\nGenetic network reconstructed for modules.\nPrepare genetic effect dataset for modules\n>module_data <- get_module_data(\n  data_par = c1$curve_par,\n  times = 1:14)\nwhere data_par is the parameters of Legendre Polynomials to model mean genetic effect curve, and times is the time points\nSolve ODE between modules. Troubleshooting 6[href=https://www.wicell.org#sec6.11]\n>module_ode1 <- get_ode_par(\n  data = module_data[[1]],\n  times = 1:14,\n  order = 3,\n  reduction = FALSE,\n  parallel = FALSE)\nthe input data is genetic effect matrix, times is time points, order is Legendre Polynomials order used in genetic effect decomposition, reduction is whether to use dimensionality reduction, and parallel is whether to use parallel calculation\nThe result from 11.b need to be further processed.\n>module_net1 <- get_all_net(module_ode1)\nthe input is the result from 11.b\nNow the ODE result can be plotted as decomposition of genetic effect curve: Troubleshooting 7[href=https://www.wicell.org#sec6.13]\n>get_decomposition_plot(\n  input1 = module_ode1, input2 = module_net1,\n  i = 1)\nthis function needs 11.b and 11.c result, the third parameters i indicates which module used in plot\nCalculate maximum effect to control color used in network plot:\n>max_effect <- cbind(\n  get_max_effect(module_net1),\n  get_max_effect(module_net1))\nget_max_effect use the result of get_all_net to calculate the maximum genetic effect value\nFinally, network can be reconstructed by command:\n>network_plot(\n  k = module_net1,\n  title = 'CK',\n  max_effect = max_effect,\n  save_plot = FALSE)\nk is the result of get_all_net, title indicate what plot title user want, max_effect directly from previous step and save_plot control whether to save PDF file.",
    "Genetic network reconstructed for SNPs is very similar to previous step.\nExtract genetic effect data of a module.\n>m1_ck <- get_subset_data(\n  data = c1$clustered_data[[1]],\n  cluster = 1 )\nget_subset_data function selects the subset cluster by input the functional clustering result.\nFollow every step in 11.b-f, remember to use “<-“ to assign result for SNPs to a different new name.\nOptional: get_net_output can be used to export network attributes for Cytoscape visualization.\nReconstructing multilayer interactome networks\nTiming: [hours to days; computing resources and data size affect the overall timing]\nThe salient feature of FunGraph is to organize hundreds of thousands or thousands of thousands of SNPs in a GWAS into a multilayer interaction network by classifying these SNPs into distinct modules. At the first layer is the interaction network among modules, reconstructed from the mean genetic effect curve of all SNPs within modules. The second-layer network is reconstructed from genetic effects curves of individual SNPs from a module. SNP networks, nested within a module, can map the fine-grained (microscopic) architecture of genetic interactions. In practice, if the size of a module is still too large for reconstructing its SNP network, we can further classify it into its submodules. Similarly, we classify a submodule into its multiple sub-submodules, and this procedure is repeated until the size of a unit is maneuverable.\nGenerally, a module that contains more than 500 SNPs is difficult for network visualization and should be further classified, user can check number of SNPs with in module by command:\n>table(table(c1$clustered_data[[1]]$cluster) )\nFor a target module, classification and ODE solving can be easily done through abovementioned approaches.\nSelect a module for further FunMap process.\n>m1_ck <- get_subset_data(\n  data = c1$clustered_data[[1]],\n  cluster = 1 )\n>input2 <- get_init_par(\n  data = m1_ck,\n  k = 3,\n  legendre_order = 4,\n  times = 1:14)",
    ">c2 <- get_cluster(input = input2)\nSolve the ODE and reconstruct network for submodules.\n>submodule1_data <- get_module_data(\n  data_par = c2$curve_par,\n  times = 1:14)\n>submodule1_ode1 <- get_ode_par(\n  data = submodule1_data [[1]],\n  times = 1:14,\n  order = 3)\n>submodule1_net1 <- get_all_net(submodule1_ode1)\n>max_effect1 <- cbind(\n  get_max_effect(submodule1_net1),\n  get_max_effect(submodule1_net1))\n>network_plot(\n  k = submodule1_net1,\n  title = “Submodule1_CK”,\n  max_effect = max_effect1)\nSimilarly, the SNP network can be reconstruction by the same functions."
  ],
  "subjectAreas": [
    "Computer Sciences",
    "Systems Biology",
    "Bioinformatics",
    "Genetics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}