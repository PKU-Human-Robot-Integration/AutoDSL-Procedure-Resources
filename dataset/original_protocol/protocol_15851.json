{
  "id": 19677,
  "origin_website": "Wiley",
  "title": "ntEdit+Sealer: Efficient Targeted Error Resolution and Automated Finishing of Long-Read Genome Assemblies",
  "procedures": [
    "This Basic Protocol[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-prot-0001] describes how to run ntEdit+Sealer with the protocol Makefile to polish and correct errors in a long-read genome assembly using short reads. The protocol involves populating several Bloom filters with short-read k-mers for ntEdit and Sealer using several k-mer sizes. After the Bloom filters are created, ntEdit is run iteratively with long to short k values to correct base errors and flag unfixable and problematic regions in the assembly by soft-masking them. Unmasked sequences that are shorter than the lowest k value and flanked by soft-masked regions are further soft-masked after the ntEdit runs. Finally, Sealer is run with the same decreasing k values to fill in the erroneous soft-masked regions and existing assembly gaps by traversing an implicit Bloom filter de Bruijn graph.\nThe pipeline is invoked with a single Makefile command. We illustrate the steps with an E. coli strain NDM5 dataset consisting of a long-read Shasta (Shafin et al., 2020[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-bib-0012]) assembly generated from ONT MinION reads and paired-end Illumina MiSeq reads for assembly finishing. Additionally, we demonstrate how to analyze the draft and finished assemblies with QUAST (Gurevich, Saveliev, Vyahhi, & Tesler, 2013[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-bib-0005]).\nNecessary Resources\nHardware\nA server or machine running a 64-bit Linux or Mac operating system with a sufficient amount of disk space and RAM (see Support Protocol[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-prot-0002] for more details).\nSoftware\nThe following packages and their dependencies must be installed and be referenced to in your PATH environment variable:\n         \nsra-tools v2.9.1+ (https://github.com/ncbi/sra-tools[href=https://github.com/ncbi/sra-tools])\nntHits v0.0.1+ (https://github.com/bcgsc/nthits[href=https://github.com/bcgsc/nthits])\nntEdit v1.3.5+ (https://github.com/bcgsc/ntEdit[href=https://github.com/bcgsc/ntEdit])\nABySS v2.3.2+ (https://github.com/bcgsc/abyss[href=https://github.com/bcgsc/abyss])\nntEdit+Sealer protocol v1.0.0+ (https://github.com/bcgsc/ntedit_sealer_protocol[href=https://github.com/bcgsc/ntedit_sealer_protocol])\nQUAST v5.0.0+ (https://github.com/ablab/quast[href=https://github.com/ablab/quast])\nFiles\nShort sequencing reads (paired- or single-end) can be provided in compressed or uncompressed FASTQ format. Paired-end reads do not need to be interleaved. The long-read draft genome assembly can be provided as either a multi- or single-line FASTA file.\nSample data",
    "The example E. coli strain NDM5 draft genome assembly is included in the ntEdit+Sealer Protocol Github Repository under the “demo” subdirectory (https://github.com/bcgsc/ntedit_sealer_protocol/blob/main/demo/ecoli_shasta.fa[href=https://github.com/bcgsc/ntedit_sealer_protocol/blob/main/demo/ecoli_shasta.fa]). The corresponding Illumina short reads will be used as demonstration for polishing and can be obtained from the NCBI Sequencing Read Archive (Accession: SRX12150405). Additionally, we will use the E. coli strain K-12 substr. MG1655 reference genome assembly (Accession: GCF_000005845.2) to assess the assemblies with QUAST.\nProtocol steps\n1. Install ntHits, ntEdit, ABySS, and the ntEdit+Sealer repository as outlined in the Strategic Planning section and add all binaries to your PATH environment variable.\n2. Install protocol-specific dependencies fasterq-dump (part of sra-tools) and QUAST via Conda or manually. Ensure sra-tools v2.9.1 or newer is installed in order to obtain fasterq-dump, a more performant, multi-threaded version of fastq-dump. If the correct version cannot be installed, fastq-dump can be used as a replacement (see step 3 below for details). If installing the tools manually, the executables must be added to your PATH environment variable.\nOption A: Installation using the Conda package manager\nIf Option A of the Strategic Planning section was used to install ntHits, ntEdit, and ABySS, dependencies may be installed into the same environment. Otherwise, a new Conda environment should be created. The Conda environment must be activated (using conda activate <env name>) prior to installing the tools.\nconda install -c bioconda \"sra-tools>=2.9.1\" \"quast>=5.0.0\"\nOption B: Manual installation\nsra-tools\nIdentify the correct version of the SRA Toolkit for your operating system from https://github.com/ncbi/sra-tools/wiki/01.-Downloading-SRA-Toolkit[href=https://github.com/ncbi/sra-tools/wiki/01.-Downloading-SRA-Toolkit], and replace the URL if necessary.\nwget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/3.0.0/sratoolkit.3.0.0-centos_linux64.tar.gz\ntar -xzf sratoolkit.3.0.0-centos_linux64.tar.gz\nexport PATH=/path/to/sratoolkit.3.0.0-centos_linux64/bin:$PATH\nQUAST\nwget https://github.com/ablab/quast/releases/download/quast_5.0.2/quast-5.0.2.tar.gz\ntar -xzf quast-5.0.2.tar.gz\nexport PATH=/path/to/quast:$PATH\n3. Create a new directory for running the ntEdit+Sealer protocol. Enter the new directory, soft-link the draft genome assembly from the ntEdit+Sealer repository and download the reference genome assembly and short reads.\n         \nmkdir ecoli_demo",
    "cd ecoli_demo\nln -s /path/to/ntedit_sealer_protocol/demo/ecoli_shasta.fa\nwget https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/005/845/GCF_000005845.2_ASM584v2/GCF_000005845.2_ASM584v2_genomic.fna.gz\nfasterq-dump SRR15859208\nThe fasterq-dump command will download the short reads into two separate FASTQ files. These files are named according the SRA run accession number (i.e., SRR15859208_1.fastq and SRR15859208_2.fastq for the forward and reverse reads, respectively). If, for some reason, the correct version of sra-tools and fasterq-dump cannot be installed, fastq-dump may be used instead with the following command: fastq-dump SRR15859208 --split-3 --skip-technical.\n4. Run the ntEdit+Sealer Makefile with the “finish” command to polish and fill the draft assembly ecoli_shasta.fa with the two reads files SRR15859208_1.fastq and SRR15859208_2.fastq. Specify k-mer lengths of 80, 65 and 50 with the k parameter, and a Bloom filter size of 200 MB with the b parameter. The protocol should take approximately 5 min to complete and requires under 550 MB of RAM, so can easily be run on a modern laptop or desktop computer.\n         \nntedit-sealer finish seqs=ecoli_shasta.fa \\\nreads=\"SRR15859208_1.fastq SRR15859208_2.fastq\" \\\nk=\"80 65 50\" b=200M\nEnsure that quotation marks are used to enclose lists of parameter values (i.e., read files and k-mer lengths), and that individual items in lists are space-separated. k-mer lengths must be passed in decreasing order. The command will run (1) ntHits and ABySS-bloom to populate Bloom filters from the short reads, (2) a Bash script to call ntEdit iteratively with decreasing k, (3) a Python script to consolidate (soft-mask) sequences shorter than the lowest k that are flanked by soft-masked regions, and finally (4) Sealer.\n5. Ensure that the ntEdit+Sealer run completes successfully. Successful completion will result in the Makefile reporting “ntEdit and Sealer polishing steps complete! Polished assembly can be found in: ecoli_shasta.ntedit_edited.prepd.sealer_scaffold.fa”.\n6. Run QUAST to analyze the draft and ntEdit+Sealer-finished genome assemblies.\n         \nquast --fast -r GCF_000005845.2_ASM584v2_genomic.fna.gz \\\n-o ecoli_quast ecoli_shasta.fa \\\necoli_shasta.ntedit_edited.prepd.sealer_scaffold.fa",
    "All QUAST output files will be printed to the ecoli_quast directory, specified by the -o parameter. A summary report will be printed in tab-separated format to a file named report.tsv, where each column describes one of the input assemblies. The “# mismatches per 100 kbp” metric in this summary describes the base accuracy of the draft and finished assemblies compared to the reference. The “# indels per 100 kbp” metric describes the average proportion of insertions or deletions of either assembly compared to the reference. The expected values for these metrics are shown in Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-tbl-0001]. If QUAST was installed manually, the executable will be quast.py.\nTable 1.\n                Number of Mismatches and Indels per 100 kbp for E. coli Assembly Before and After Finishing with ntEdit+Sealera[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-tbl1-note-0001_22]\ntable:\n﻿Unnamed: 0,Draft assembly,After ntEdit+Sealer\n# mismatches per 100 kbp,371.33,345.86\n# indels per 100 kbp,122.38,7.22\na Running ntEdit+Sealer assembly finishing protocol decreases the proportion of mismatched bases and the proportion of indels in the E. coli genome assembly.",
    "Both ntEdit and Sealer employ a k-sweep approach, iterating from long to short k-mer lengths. This approach is beneficial because different k-mer lengths can provide resolution at different scales. Larger k-mers can disambiguate repeats as they span longer regions, while shorter k-mers are useful when the local read coverage is low and for assemblies with lower base quality. The same sequence of k values is used for both tools. k=40 is the practical lower limit for Sealer, as shorter k values cause its runtime to increase sharply. We find that k=80 generally performs well for a variety of datasets and suggest decreasing in intervals of 10-15. Generally speaking, there is no strict upper limit for k (apart from the read length), so a wide range of k-mer lengths can be used to achieve the best polishing results. Time and memory restrictions will be the limiting factors in these cases.\nntHits will automatically select the optimal Bloom filter size for ntEdit by calculating the k-mer distribution for the input reads, but ABySS-bloom requires the desired Bloom filter size to be specified. This parameter is controlled by the b parameter when invoking the protocol Makefile.\nThe optimal size of a Bloom filter depends on several factors, namely the desired false positive rate (FPR), number of hash functions used for insertion, and number of elements that will be inserted. For large Bloom filters, the FPR can be approximated (Equation 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-disp-0001]):\n         \nformula:\n\\begin{equation} f = {\\left( {1 - {e^{\\frac{{ - hn}}{m}}}} \\right)^h} \\end{equation}",
    "where f is the FPR, m is the size of the filter in bits, h is the number of hash functions, and n is the number of elements (Broder & Mitzenmacher, 2004[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-bib-0003]). By default, ABySS-Bloom uses one hash function for insertion. Using this relationship and asserting h=1, we can approximate the optimal m for a given dataset and desired FPR (Equation 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-disp-0002]):\n         \nformula:\n\\begin{equation} m = Ceil\\left( {\\frac{{ - n}}{{\\ln \\left( {1 - f} \\right)}}} \\right) \\end{equation}\nThe following Bloom filter sizes (RAM) generally perform well for common model organisms:\n         \nHomo sapiens (3 Gbp genome): 100 GB\nCaenorhabditis elegans (100 Mbp genome): 2.5 GB\nEscherichia coli (5 Mbp genome): 200 MB\nThe optimal b value for other genome sizes can be interpolated from these guidelines, or can be estimated using ntCard (Mohamadi, Khan, & Birol, 2017[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-bib-0009]). ntCard is a streaming algorithm for estimating k-mer frequencies in genomic datasets and can be used to determine the number of unique k-mers in a set of short reads. ABySS-Bloom creates a 2-level cascading Bloom filter (Salikhov, Sacomoto, & Kucherov, 2014[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-bib-0011]) from short-read k-mers; this means that only k-mers appearing two or more times are accounted for. Therefore, only k-mers with multiplicity of 2 or more should be considered when estimating optimal Bloom filter size.\nThe following steps in this Support Protocol[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-prot-0002] describe how ntCard should be used to calculate the optimal Bloom filter size for a dataset, ensuring a false positive rate (FPR) of ∼0.005. The same E. coli short reads from the Basic Protocol[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-prot-0001] will be used to demonstrate this protocol.\nNecessary Resources\nHardware\nA server or machine running a 64-bit Linux or Mac operating system capable of running ntCard.\nSoftware\nntCard v1.2.2+ (https://github.com/bcgsc/ntCard[href=https://github.com/bcgsc/ntCard])",
    "ntCard is available on the Conda and Homebrew package managers and can also be cloned and compiled from Github.\nFiles\nThe short sequencing reads that will be used as input to ntEdit+Sealer will be analyzed here. The reads can be provided in compressed or uncompressed FASTQ format and paired-end reads do not need to be interleaved.\n1. Install ntCard.\nOption A: Installation using the Conda package manager\nconda create -n ntcard\nconda activate ntcard\nconda install -c bioconda \"ntcard>=1.2.2\"\nOption B: Installation using the Homebrew package manager\nbrew install brewsci/bio/ntcard\nOption C: Manual installation from Github\ngit clone https://github.com/bcgsc/ntCard.git\n./autogen.sh\n./configure --prefix=/path/to/ntCard\nmake\nmake install\nThe --prefix parameter for the configure script installs ntCard to the provided path. This parameter can be excluded if you have sudo privileges and wish to install the tool into /usr/local. If using Conda, activate the environment that ntCard was installed to with the command conda activate environment_name. If manually installing ntCard to a specific directory, ensure that the path supplied to the --prefix parameter is on your PATH.\n2. Run ntCard on the read files, providing all k values you are planning on using for ntEdit+Sealer. We will use k=80, k=65, and k=50.\n         \nntcard -k80,65,50 -p freq \\\nSRR15859208_1.fastq SRR15859208_2.fastq\nThis command will generate a k-mer distribution histogram for each k provided. Each histogram will be printed to a two-column, tab-separated file with the prefix freq, for example, freq_k80.hist, where the first column represents an Fk metric or multiplicity and the second column contains the number of corresponding k-mers.\n3. Inspect the k-mer frequency histograms. Only the first three lines are necessary for our purposes.\n         \nhead -n 3 freq_k*.hist",
    "The first two lines of each histogram contain Fk metrics, which describe statistics for the input dataset. F0 is the number of distinct k-mers in the reads, and F1 denotes the total number of k-mers in the dataset. The third line contains the number of k-mers appearing once in the reads. See Table 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-tbl-0002] for the expected values of these metrics.\nTable 2.\n                F1, F0 and Number of Multiplicity 1 k-mers for E. coli Illumina Readsa[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-tbl2-note-0001_31]\ntable:\n﻿k,F1,F0,1\n50,322869315,47853592,41155307\n65,300812763,50900032,44179082\n80,278838102,52274328,45577189\na Table values correspond to the first three rows of ntCard output histograms for 50-mer, 65-mer, and 80-mer cardinality estimation of E. coli strain NDM5 Illumina reads.\n4. Estimate the number of k-mers that appear two or more times in the reads. Subtract the number of k-mers that appear only once from F0 with the following one-liner:\n         \nfor k in 80 65 50; do distinct=$(grep “F0” freq_k$k.hist | awk '{print $2}'); once=$(grep “˄1\\b” freq_k$k.hist | awk '{print $2}'); echo k=$k: n=$((${distinct} - ${once})); done\nThis command will calculate and print the number of k-mers appearing two or more times for each k. See Table 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-tbl-0003] for the expected values for each k.\nTable 3.\n                Number of k-mers Appearing at Least Twice in E. coli Illumina Readsa[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-tbl3-note-0001_33]\ntable:\n﻿k,n\n50,6697139\n65,6720950\n80,6698285\na Number of k-mers with multiplicity of 2 or more calculated from ntCard output. For each k, n is equal to the number of unique k-mers in the dataset (F0) minus the number of k-mers with multiplicity of one.",
    "5. Calculate the optimal Bloom filter size from the k-mer distributions using the largest n calculated in step 4 (k=65). This will maximize the number of unique k-mers considered, and therefore produce the lowest FPR for the range of k, a method analogous to that employed by Kmergenie (Chikhi & Medvedev, 2013[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-bib-0004]). Using the relationship between FPR and Bloom filter density, the optimal value of m given an FPR (f) of 0.005 is (Equation 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-disp-0003]):\n         \nformula:\n\\begin{equation} m = Ceil\\left( {\\frac{{ - n}}{{\\ln \\left( {1 - f} \\right)}}}\\right) = Ceil\\left( {\\frac{{ - 6720950}}{{\\ln \\left( {0.995} \\right)}}} \\right) = 1340826718{\\rm{\\;bits}} \\end{equation}\nThis equates to approximately 168 MB. We rounded this estimate up to 200 MB for the example in the Basic Protocol[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.442#cpz1442-prot-0001]."
  ],
  "subjectAreas": [
    "Bioinformatics"
  ],
  "bigAreas": [
    "Bioinformatics & Computational Biology"
  ]
}