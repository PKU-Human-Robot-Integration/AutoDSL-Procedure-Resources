{
  "id": 18022,
  "origin_website": "Jove",
  "title": "Predicting Treatment Response to Image-Guided Therapies Using Machine Learning: An Example for Trans-Arterial Treatment of Hepatocellular Carcinoma",
  "procedures": [
    "1 . Workstation Setup for Machine Learning\nUse a system with the following:\n\tIntel Core 2 Duo or higher CPU at 2.0 GHz\n\t4 GB or more system memory\n\tPOSIX-compliant operating system (Linux or Mac OS) or Microsoft Windows 7\n\tUser permissions for executing programs and saving files\nInstall the following tools:\n\tAnaconda Python3: https://www.anaconda.com/download\n\tDICOM to NIfTI converter (dcm2niix) - https://github.com/rordenlab/dcm2niix\n\tSublime Text Editor: https://www.sublimetext.com/\n\titk-SNAP (optional): http://www.itksnap.org\n\t\nInstall Anaconda Python3, dcm2nii and Sublime Text, visit their respective websites for operating system specific installation steps.\nCreate and activate an Anaconda environment.\n\t\tconda create --name mlenv\n\t\tconda activate mlenv\nInstall Anaconda packages for machine learning.\n\t\tconda install numpy scipy scikit-learn nltk nibabel\n\t\tNOTE: The nltk package is useful for parsing plaintext clinical notes, while the nibabel package provides useful functions for medical image manipulation. itk-SNAP may be installed for segmenting organs and tumors from medical images. It is useful for constraining features to specific regions.\n2 . Feature Extraction from Plaintext Clinical Notes and Structured Clinical Data\nCreate a parent directory for the project and create a folder for each patient within the parent folder. Directory structure should resemble:\n\tProject/\n\tProject/Patient_1/\n\tProject/Patient_2/\n\tProject/Patient_3/\n\t...\nObtain plaintext clinical notes from the electronic medical record (EMR). Retrieve notes manually through the EMR or by means of the hospital information technology (IT) office through a data-dump. Store each patient's notes in their respective folders.\n\tProject/Patient_1/History_and_Physical.txt\n\t​Project/Patient_1/Procedure_Note.txt\n\t\nDecided which clinical features to include in the model. Parse the plaintext clinic notes for these features. The Python Natural Language Toolkit (nltk) library provides useful commands for splitting documents into sentences. Each sentence may be searched for appropriate terms such as jaundice. Store each patient's features in a file with one feature per line.\n\t\tProject/Patient_1/Features.txt:\n\t\tage 67\n\t\tsex male\n\t\talbumin 3.1\n\t\tcirrhotic no\n\t\thepatitis_c no\n\t\t...",
    "For non-binary features, take the median value of each feature across all patients. Binarize each feature as a true(1) or false(0) value based on the median value.\n\t\tProject/Patient_1/Binary_Features.txt:\n\t\tage_over_60 0\n\t\tmale_sex 1\n\t\talbumin_less_than_3.5 1\n\t\tpresence_of_cirrhosis 0\n\t\thepatitis_c 0\n\t\t...\n3 . Feature Extraction from Medical Images\nNOTE: See Step 3 Supplementary Materials for Code Examples.\nDownload pre- and post- therapy magnetic resonance DICOM images from the hospital PACS. Store images in the corresponding patient folders.\n\tProject/\n\tProject/Patient_1/Pre_TACE_MRI_Pre-Contrast.dcm\n\tProject/Patient_1/Pre_TACE_MRI_Arterial.dcm\n\tProject/Patient_1/Post_TACE_MRI_Pre-Constrast.dcm\n\tProject/Patient_1/Post_TACE_MRI_Arterial.dcm\nConvert DICOM images into NIfTI format using the dcm2niix program. The following commands converts all .dcm images in specified folder. Repeat for all patients.\n\tdcm2niix Project/Patient_1/\n\tdcm2niix Project/Patient_2/\nLoad each NIfTI file into Python.\n\timport nibabel\n\t​image = nibabel.load('Project/Patient_1/Pre_TACE_MRI_Pre-Contrast.dcm')\n\t\nCanonicalize the orientation of each image. This ensures that the x, y, and z axes are identical, irrespective of the machine used to acquire the images.\n\t\tcImage = nibabel.as_closest_canonical(image)\nUse itk-SNAP (or an equivalent software package) to segment binary liver and tumor masks for each image.\n\tProject/Patient_1/Pre_TACE_MRI_Pre-Contrast_Liver_Mask.bin\n\tProject/Patient_1/Pre_TACE_MRI_Pre-Contrast_Tumor_Mask.bin\nRead the liver and tumor masks into Python. The code below demonstrates how to correct orientation issues in order to orient the masks along the same canonical axes as the MR images.\n\timport numpy as np\n\twith open(liver_mask_file, 'rb') as f:\n\tliver_mask = f.read()\n\tliver_mask = np.fromstring(liver_mask, dtype='uint8')\n\tliver_mask = np.reshape(liver_mask, diff.shape, order='F')\n\tliver_mask = liver_mask[:,::-1,:]\n\t​liver_mask[liver_mask > 0] = 1\n\t\nUse the liver and tumor masks to isolate voxels containing liver and tumor.\n\t\tliver = np.copy(cImage)\n\t\tliver[liver_mask <= 0] = 0\nCalculate mean liver enhancement feature.\n\t​mean_liver_enhancement = mean(liver)\n\t\nCalculate liver volume feature.\n\t\tpixdim = cImage.header['pixdim']\n\t\tunits = pre.header['xyzt_units']\n\t\tdx, dy, dz = pre_pixdim[1:4]\n\t\tliver_volume = length(liver) * dx * dx * dz\n(Optional) Calculate additional features as desired.\nUpdate patient-specific features file with the image features.\n\tProject/Patient_1/Features.txt:\n\tage 67\n\tsex male",
    "albumin 3.1\n\tcirrhotic no\n\thepatitis_c no\n\tpre_tace_mean_liver_enhancement 78\n\t​pre_tace_liver_volume 10000\n\t\nCalculate median values for each imaging feature and binarize as in Step 2.2.2.\n\t\tProject/Patient_1/Binary_Features.txt:\n\t\tage_over_60 0\n\t\tmale_sex 1\n\t\talbumin_less_than_3.5 1\n\t\tpresence_of_cirrhosis 0\n\t\thepatitis_c 0\n\t\tpre_tace_mean_liver_enhancement 1\n\t\tpre_tace_liver_volume 0\n4. Feature Aggregation and Reduction\nNOTE: See Step 4 Supplementary Materials for Code Examples.\nCombine the Binary_Features.txt files for each patient into a spreadsheet with patients on the y-axis and features on the x-axis.\n\ttable:\n﻿0,1,2,3,4,5,6,7\nPatient,Age > 60,Male Sex,Albumin < 3.5,Presence of Cirrhosis,Hepatitis C Present,mean liver enhancement > 50,liver volume > 20000\n1,0,1,1,0,0,1,0\n2,1,1,1,0,0,0,0\n3,0,1,1,0,1,0,0\nAdd qEASL outcome response labels as the final column.\n\t\ttable:\n﻿0,1,2,3,4,5,6,7,8\nPatient,Age > 60,Male Sex,Albumin < 3.5,Presence of Cirrhosis,Hepatitis C Present,mean liver enhancement > 50,liver volume > 20000,qEASL Responder\n1,0,1,1,0,0,1,0,1\n2,1,1,1,0,0,0,0,1\n3,0,1,1,0,1,0,0,0\nExport the spreadsheet as a tab-delimited file.\n\t\tProject/ML_Matrix.tsv:\n\t\tPatientAge > 60     Male Sex     Albumin < 3.5     Presence of Cirrhosis     Hepatitis C Present     mean liver enhancement > 50     liver volume > 20000     qEASL Responder\n\t\t1   0   1   1   0   0   1   0   1\n\t\t2   1   1   1   0   0   0   0   1\n\t\t3   0   1   1   0   1   0   0   0\nRemove low-variance features from consideration.\n\timport numpy as np\n\tfrom sklearn.feature_selection import VarianceThreshold\n\t# Read in the binary matrix.\n\tfeatures = []\n\tlabels = []\n\tfor i, L in enumerate(sys.stdin):\n\tif i == 0\n\tcontinue\n\tn_fs_L = L.strip().split('\\t')\n\tfeatures.append([float(_) for _ in n_fs_L[1:-1]])\n\tlabels.append(n_fs_L[-1])\n\tX = np.array(features)\n\ty = np.array(labels)\n\t# Compute features appearing in at least 20% of both responders and non-respnders.\n\tmodel = VarianceThreshold(threshold=0.8 * (1 - 0.8))\n\tX_new = model.fit_transform(X, y)\n\tThe male sex, albumin < 3.5, presence of cirrhosis, and liver volume > 2000 features have been removed.\n\ttable:\n﻿0,1,2,3,4\nPatient,Age > 60,Hepatitis C Present,mean liver enhancement > 50,qEASL Responder\n1,0,0,1,1\n2,1,0,0,1\n3,0,1,0,0",
    "Remove features with low univariate-association with the outcome. Filter only those features that passed 4.2. Retain ceil(log2(N)) features, where N is the number patients. Ceil(Log2(3)) = 2.\n\timport math\n\tfrom sklearn.feature_selection import SelectKBest\n\tfrom sklearn.feature_selection import chi2\n\t# Read in the binary matrix as in 4.2.1\n\t...\n\t# Compute top ceil(log2(N)) features by univariate association.\n\tk = math.ceil(log2(length(y)))\n\tmodel = SelectKBest(chi2, k=k)\n\tX_new = model.fit_transform(X, y)\n\tThe male sex age > 60 feature has been removed from the remaining features from 4.2.1.\ntable:\n﻿0,1,2,3\nPatient,Hepatitis C Present,mean liver enhancement > 50,qEASL Responder\n1,0,1,1\n2,0,0,1\n3,1,0,0\n5 . Model Training and Testing\nSee Step 5 Supplementary Materials for Code Examples\nTrain a logistic regression model using the binary features matrix from 4.3.\n\timport math\n\tfrom sklearn.linear_model import LogisticRegression\n\t# Read in the binary matrix as in 4.2 and 4.3.\n\t...\n\t# For each patient, train a model on all other patients.\n\tscore = 0.0\n\tmodels = []\n\tfor patient in len(X):\n\t# Train model on all but one of the patients.\n\ttrain_x = np.array([_ for i, _ in enumerate(X) if i != patient])\n\ttrain_y = np.array([_ for i, _ in enumerate(y) if i != patient])\n\tmodel = LogisticRegression(C=1e15)\n\tmodel.fit(train_x, train_y)\n\t# Test on the left-out patient.\n\ty_prediction = model.predict(X[patient])\n\tif y_prediction == y[patient]:\n\t     score += 1\n\t     models.append(model)\nTrain a random forest model using the binary features matrix from 4.2.2. Steps are identical to 5.2.1, except the model instantiation should be updated as follows:\n\tfrom sklearn.ensemble import RandomForestClassifier\n\t...\n\tmodel = RandomForestClassifier(n_estimators=100)\n\t...\nPrint out score / len(X)for 5.1 and 5.2. This represents the average accuracy of all logistic regression models and all random forest models, respectively. All N models should be applied to new patients with the average classification taken as the prediction outcome",
    "Subscription Required. Please recommend JoVE to your librarian."
  ],
  "subjectAreas": [
    "Medicine"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research"
  ]
}