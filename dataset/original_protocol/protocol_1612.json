{
  "id": 1718,
  "origin_website": "Cell",
  "title": "Backward simulation for inferring hidden biomolecular kinetic profiles",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nBS in general cases\nTiming: 1 h for step 1 and 1 h for step 2\nIn this section, we will describe how to apply the BS to a general system of ODEs where the downstream profile is given.\nFormulate the dynamics as a set of coupled ODEs.\nFor a dynamical system with n variables    [   y 1   ( t )  ,  y 2   ( t )  , ⋯ ,  y n   ( t )   ]  ≡  y →   ( t )    and m parameters    [   p 1   ( t )  ,  p 2   ( t )  , ⋯ ,  p m   ( t )   ]  ≡  p →   ( t )    that can be described by a set of coupled ODEs, we divide the rate processes into two parts, i.e.,\n   (Equation 1)     d  y i   ( t )    d t   =  F i   [   p →   ( t )  ;  y →   ( t )   ]  +  G i   [   p →   ( t )  ;  y →   ( t )  , t  ]  , i = 1,2 , ⋯ , n ,     \nwhere    F i   [   p →   ( t )  ;  y →   ( t )   ]   describes the intermediate or interconversion processes of components satisfying     ∑   i = 1  n   F i   [   p →   ( t )  ;  y →   ( t )   ]  = 0  , and    G i   [   p →   ( t )  ;  y →   ( t )  , t  ]    describes the source/sink-coupled, nonconservative events responsible for the changes in the total pool of yi(t) (i=1,2,⋯,n).\nSumming up the left- and right-hand sides of Equation 1[href=https://www.wicell.org#fd1] over i, all the terms responsible for intermediate processes cancel out, leaving only the source/sink-coupled terms:",
    "d  d t     ∑   i = 1  n   y i   ( t )  =   ∑   i = 1  n   G i   [   p →   ( t )  ;  y →   ( t )  , t  ]  .  \nTake extra care of any fundamental conditions of the variables and terms in the model. For example, if the variables represent molecular concentrations, they should be nonnegative, i.e., yi(t)≥0 for i=1,2,⋯,n. Likewise, a nonnegative net influx of component yj(t) from an external source indicates    G j   [   p →   ( t )  ;  y →   ( t )  , t  ]  ≥ 0  .\nTransform the ODEs to utilize the accessible information on relatively downstream variables in the ODE model.\nIntroduce an observable time-course variable Y(t) as   Y  ( t )  ≡   ∑   i ∈ A    y i   ( t )    where A is the set of components whose sum is of an experimentally available quantity or of theoretical interest.\nFor a particular component j selected among the elements of A, we rewrite yj(t) as\n   (Equation 2)    y j   ( t )  = Y  ( t )  −  ∑  i ∈ A \\  { j }      y i   ( t )   .     \nThen, we define     y →  Y   ( t )    as an alternative form of    y →   ( t )    where yj(t) is replaced by the right-hand side of Equation 2[href=https://www.wicell.org#fd2] and rewrite Equation 1[href=https://www.wicell.org#fd1] for   i ≠ j  :\n   (Equation 3)     d  y i   ( t )    d t   =  F i   [   p →   ( t )  ;   y →  Y   ( t )   ]  +  G i   [   p →   ( t )  ;   y →  Y   ( t )  , t  ]  , i ≠ j .     \nCombining Equations 2[href=https://www.wicell.org#fd2] and 3[href=https://www.wicell.org#fd3] for i=j, we obtain",
    "(Equation 4)    G j   [   p →   ( t )  ;   y →  Y   ( t )  , t  ]  =   d Y  ( t )    d t   −  ∑  k ∈ A \\  { j }       d  y k   ( t )    d t   −  F j   [   p →   ( t )  ;   y →  Y   ( t )   ]  .      \nThe conventional forward simulation numerically solves Equation 1[href=https://www.wicell.org#fd1] to obtain    y →   ( t )   , given the values of    p →   ( t )    and    G i   [   p →   ( t )  ;  y →   ( t )  , t  ]    and the initial condition of    y →   ( t )   . On the other hand, our BS numerically solves Equations 3[href=https://www.wicell.org#fd3] and 4[href=https://www.wicell.org#fd4] to obtain    G j   [   p →   ( t )  ;   y →  Y   ( t )  , t  ]    and     y →  Y   ( t )   , given the values of    p →   ( t )   , Y(t), and    G i   [   p →   ( t )  ;   y →  Y   ( t )  , t  ]    (  i ≠ j  ) and the initial condition of     y →  Y   ( t )   . In other words, using a downstream observable Y(t), BS traces back the upstream processes such as    G j   [   p →   ( t )  ;   y →  Y   ( t )  , t  ]   .",
    "If the computed    G j   [   p →   ( t )  ;   y →  Y   ( t )  , t  ]    or     y →  Y   ( t )    does not satisfy the fundamental conditions imposed by a modeler, they are treated as infeasible solutions. For example, if yi(t) in     y →  Y   ( t )   represents the concentration of each molecular species i, yi(t) should be non-negative for all i’s. Depending on cases, the infeasible solutions may indicate the incompatibility of a simulated parameter set    p →   ( t )    to an observed profile of Y(t).\nApplication of BS to a circadian protein degradation model\nTiming: 1 h for step 3, 1 h for step 4, 1 h for step 5, and 2 h for step 6\nIn this section, we will describe how to apply the BS to a circadian protein degradation model in Lim et al. (2021)[href=https://www.wicell.org#bib1]. Step 3 and 4 show how to modify the set of coupled ODEs of a circadian protein degradation model for the BS. How to write the codes for the BS and how to examine the ODE system are included in step 5 and 6, respectively.\nFormulate the dynamics as a set of coupled ODEs.\nIn our circadian protein degradation model in Lim et al. (2021)[href=https://www.wicell.org#bib1], the time derivatives of the concentrations of several forms of a circadian protein are described as follows (Figure 1[href=https://www.wicell.org#fig1]):\n   (Equation 5)     d  x 0   ( t )    d t   = g  ( t )  −  a 0  u  ( t )   x 0   ( t )  +  a 1   x  E , 0    ( t )  + s  x  H , u b    ( t )  ,",
    "(Equation 6)     d  x  E , 0    ( t )    d t   =  a 0  u  ( t )   x 0   ( t )  −  a 1   x  E , 0    ( t )  − q  x  E , 0    ( t )  ,     \n   (Equation 7)     d  x  E , u b    ( t )    d t   = q  x  E , 0    ( t )  +  a 0  u  ( t )   x  0 , u b    ( t )  −  a 2   x  E , u b    ( t )  −  r 0   x  E , u b    ( t )  ,     \n   (Equation 8)          d  x  0 , u b    ( t )    d t   =  a 2   x  E , u b    ( t )  +  b 1   x  H , u b    ( t )  −  b 0  v  ( t )   x  0 , u b    ( t )         −  a 0  u  ( t )   x  0 , u b    ( t )  −  r 0   x  0 , u b    ( t )  ,         \n   (Equation 9)     d  x  H , u b    ( t )    d t   =  b 0  v  ( t )   x  0 , u b    ( t )  −  b 1   x  H , u b    ( t )  − s  x  H , u b    ( t )  −  r 0   x  H , u b    ( t )      \nwith the following two quantities:\n   (Equation 10)    u ¯  ≡ u  ( t )  +  x  E , 0    ( t )  +  x  E , u b    ( t )  ,     \n   (Equation 11)    v ¯  ≡ v  ( t )  +  x  H , u b    ( t )  .",
    "The variables and rate parameters in Equations 5[href=https://www.wicell.org#fd5], 6[href=https://www.wicell.org#fd6], 7[href=https://www.wicell.org#fd7], 8[href=https://www.wicell.org#fd8], 9[href=https://www.wicell.org#fd9], 10[href=https://www.wicell.org#fd10], and 11[href=https://www.wicell.org#fd11] are defined in Tables 1[href=https://www.wicell.org#tbl1] and 2[href=https://www.wicell.org#tbl2].\nAs a sanity check, sum up Equations 5[href=https://www.wicell.org#fd5], 6[href=https://www.wicell.org#fd6], 7[href=https://www.wicell.org#fd7], 8[href=https://www.wicell.org#fd8], and 9[href=https://www.wicell.org#fd9] and obtain the time derivative of the total protein concentration:\n   (Equation 12)        d  d t    [   x 0   ( t )  +  x  E , 0    ( t )  +  x  E , u b    ( t )  +  x  0 , u b    ( t )  +  x  H , u b    ( t )   ]         = g  ( t )  −  r 0   [   x  E , u b    ( t )  +  x  0 , u b    ( t )  +  x  H , u b    ( t )   ]  .         \nThis result makes sense because g(t) represents the ultimate source of protein production and the variables with a common coefficient r0 are the concentrations of ubiquitinated proteins destined for degradation.\nLet x(t) denote the total protein concentration:\n   (Equation 13)   x  ( t )  ≡  x 0   ( t )  +  x  E , 0    ( t )  +  x  E , u b    ( t )  +  x  0 , u b    ( t )  +  x  H , u b    ( t )  .     \nEquation 12[href=https://www.wicell.org#fd12] is rewritten as\n   (Equation 14)     d x  ( t )    d t   = g  ( t )  − r  ( t )  x  ( t )  ,     \nwhere r(t) is the protein degradation rate given by\n   (Equation 15)   r  ( t )  ≡  r 0   [   x  E , u b    ( t )  +  x  0 , u b    ( t )  +  x  H , u b    ( t )   ]  / x  ( t )  .",
    "Be cautious about the implicit physical or biological constraints on the variables and parameters. In the example of our model, all the molecular concentrations should be nonnegative. That is,\n   (Equation 16)        x 0   ( t )  ≥ 0 ,  x  E , 0    ( t )  ≥ 0 ,  x  E , u b    ( t )  ≥ 0 ,  x  0 , u b    ( t )  ≥ 0 ,  x  H , u b    ( t )  ≥ 0 ,       u  ( t )  ≥ 0 , v  ( t )  ≥ 0 .         \nAdditionally, because the protein synthesis rate cannot be negative, the following inequality should be satisfied:\n   (Equation 17)   g  ( t )  ≥ 0 .     \nTransform the ODEs to utilize the experimentally available information on relatively downstream variables in the ODE model.\nIn the example of our model, the experimentally available data were the total concentration x(t) of a protein rather than those of the individual sub-forms of the protein or the protein synthesis rate at the upstream level. Although the experimental data usually represent the relative, but not absolute, molecular concentrations, the use of the relative concentration for x(t) in our model only changes the “unit” of concentrations without loss of generality. On the other hand, if multiple datasets of their own relative levels are incorporated into the model variables of the same dimensional quantities, the appropriate proportionality coefficients or conversion factors should be introduced for the sake of a unified scale.\nPlug the following relation (from Equation 13[href=https://www.wicell.org#fd13]) in Equations 5[href=https://www.wicell.org#fd5] and 6[href=https://www.wicell.org#fd6]:",
    "(Equation 18)    x 0   ( t )  = x  ( t )  −  [   x  E , 0    ( t )  +  x  E , u b    ( t )  +  x  0 , u b    ( t )  +  x  H , u b    ( t )   ]  .     \ng(t) in Equation 5[href=https://www.wicell.org#fd5] is rewritten as\n   (Equation 19)   g  ( t )  =   d  x 0   ( t )    d t   +  a 0  u  ( t )   x 0   ( t )  −  a 1   x  E , 0    ( t )  − s  x  H , u b    ( t )  ,     \nwhere x0(t) is replaced by the right-hand side in Equation 18[href=https://www.wicell.org#fd18]. We are now ready for the BS of our model, using Equations 6[href=https://www.wicell.org#fd6], 7[href=https://www.wicell.org#fd7], 8[href=https://www.wicell.org#fd8], 9[href=https://www.wicell.org#fd9], 10[href=https://www.wicell.org#fd10], 11[href=https://www.wicell.org#fd11], 18[href=https://www.wicell.org#fd18], and 19[href=https://www.wicell.org#fd19]. Note that, in usual practice, x(t) and other variables are simulated using the profile of g(t); in our BS, g(t) and other variables are reversely simulated using the profile of x(t), through Equations 6[href=https://www.wicell.org#fd6], 7[href=https://www.wicell.org#fd7], 8[href=https://www.wicell.org#fd8], 9[href=https://www.wicell.org#fd9], 10[href=https://www.wicell.org#fd10], 11[href=https://www.wicell.org#fd11], 18[href=https://www.wicell.org#fd18], and 19[href=https://www.wicell.org#fd19].\nWrite the codes for simulation.\nImport Python modules (scipy).\nRead the time-course data of the total protein abundance. If the data do not span more than a single circadian period, expand them by the repetition of the data points to multiple circadian periods. This step is necessary if one wants to simulate the long-term asymptotic behavior of our circadian model, as will be explained later.\nInterpolate the data points of the total protein abundance. This step is necessary for the construction of a continuous trajectory of x(t) for our model simulation, given the discrete nature of time points with available data.\nImport interp1d module from scipy.interpolate.",
    "Implement a cubic interpolation by setting the option “kind = ‘cubic’”. The result is an interpolated curve of x(t), as exemplified by Figure 2[href=https://www.wicell.org#fig2]A.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1175-Fig1.jpg\nFigure 1. The protein degradation model\nThere are a total of five types of substrate proteins, defined in Table 2[href=https://www.wicell.org#tbl2]. Substrate proteins (rounded rectangles, sky blue) are synthesized from mRNA molecules (blue line, top left) in the ribosome (brown, top left) and ubiquitinated by E3 ubiquitin ligases (orange ovals) with ubiquitins (yellow circles). The ubiquitinated proteins are degraded (gray ovals) or deubiquitinated by deubiquitinating enzymes (light green hexagon). The total protein concentration is represented by x(t) with symbol Σ at the center.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1175-Fig2.jpg\nFigure 2. Examining the behaviors of the protein degradation model\n(A) The example, total protein concentration profile used for BS.\n(B and C) Simulated g(t) (B) and r(t) (C) with different initial conditions. Given the protein profile in (A), the simulated g(t) or r(t) rapidly converges at the same trajectory, regardless of its initial conditions.\n(D) The example output of the code “check_physical_constraints.py” to check the feasibility of the BS solution. If the solution does not satisfy its fundamental conditions, the code returns the message in (D).\n(E and F) Simulated profiles of protein sub-states: x0(t) (purple), xE,0(t) (yellow), xE,ub(t) (gray), x0,ub(t) (blue), and xH,ub(t) (red). When    v ¯    is set to zero, xH,ub(t) becomes zero (E). When a0, b0,    u ¯   , and    v ¯    are set as relatively high and a2 and b1 are set as relatively low, x0,ub(t) becomes almost zero (F).\ntable:files/protocols_protocol_1175_1.csv\ntable:files/protocols_protocol_1175_2.csv",
    "Build a Python function that uses time, an array of concentrations, an array of kinetic parameters, an interpolated curve of x(t) as input, and returns an array of the model variables and their time derivatives in Equations 6[href=https://www.wicell.org#fd6], 7[href=https://www.wicell.org#fd7], 8[href=https://www.wicell.org#fd8], 9[href=https://www.wicell.org#fd9], 10[href=https://www.wicell.org#fd10], 11[href=https://www.wicell.org#fd11], 18[href=https://www.wicell.org#fd18], and 19[href=https://www.wicell.org#fd19] as output.\nSolve the ODEs with scipy.solve_ivp module.\nImport solve_ivp module from scipy.integrate.\nSet the parameters “fun”, “t_span”, “t_eval”, and “y0”. Here, “fun” is a Python function of which input is ‘t’ (time) and ‘y’ (an array of the values of variables) and output is an array of the time derivatives of the variables. “t_span” is a tuple containing two time points that indicate the beginning and end of the simulation. “t_eval” is an array of time points at which to store the computed solutions. “y0” is an array of the initial states of the variables.",
    "When solving the system of ODEs numerically, we must take the following into consideration:(1) Selection of time step: When selecting the maximum time step for the simulation, it should be much smaller than the time scale of dynamics. For the circadian proteins, the time scale is ∼24 h. Therefore, it is safe to select the maximum time step much smaller than an hour. Moreover, checking whether the solution does not noticeably change with smaller time steps will assure the selection of an adequate time step. In the scipy.solve_ivp module, changing the “max_step” option would modify the maximum time step to solve the ODEs.(2) Stiffness of the problem: If the ODEs contain stiff terms, the Runge-Kutta method is not recommended. In this case, “LSODA”, “BDF”, or “Radau” methods are recommended. The method to solve the ODEs can be changed by setting the “method” option in the scipy.solve_ivp module.(3) Numerical error tolerance: When solving the system of ODEs, estimated errors can be controlled. “atol” and “rtol” options in the scipy.solve_ivp module can be used to control absolute and relative errors respectively.\nTest the behaviors of the ODE model.\nCheck whether the model output is not too sensitive to the initial conditions, given the profile of the observable (e.g., x(t) in our case) and the parameter values. This step is to determine whether the simulation outcome is essentially unique or not, regardless of particular initial conditions. One method is to randomly sample the initial conditions of each variable within a physiologically-relevant range and then check whether the simulation outcomes converge at similar trajectories. In the case of our model, the code in the following command allows the test of this initial condition dependency:\n> python check_initial_conditions_sensitivity.py",
    "The execution of the code gives the graphs of each variable as the functions of time with different initial conditions. Figures 2[href=https://www.wicell.org#fig2]B and 2[href=https://www.wicell.org#fig2]C demonstrate that g(t) and r(t) in our model converge well respectively, regardless of their initial conditions when x(t) (Figure 2[href=https://www.wicell.org#fig2]A) and parameter values are assigned for the simulation.\nDetermine the minimum simulation length to approach the asymptotic solutions of the ODE model. By running the simulation for a long enough time, i.e., setting the large values for ‘t_span’ and ‘t_eval’ options, check when the ODE solutions exhibit saturated and sustained oscillations in our case. If the simulation does not result in the stable oscillations, try longer simulation lengths. Identify the minimum simulation length to ensure the stable oscillations. The code in the following command allows this test:\n> python check_long_time.py\nExecuting the code gives the graphs of each variable over a long time. Through these graphs, one can determine the minimum simulation length.\nCheck whether the ODE solutions satisfy all the physical and biological constraints and thus can be considered as feasible solutions. Some ODE solutions may not satisfy these constraints, particularly in the case of BS. The reason is that BS does not run in a natural causal direction from upstream to downstream levels, but traces back the upstream states without the prospect of their compatibility with the parameter values. In other words, only the parameter values with the feasible solutions of BS are compatible with the downstream observable, and hence BS can identify those sensible parameter values. In the example of our model, the solutions should satisfy all the constraints in Equations 16[href=https://www.wicell.org#fd16] and 17[href=https://www.wicell.org#fd17]. The code in the following command allows this feasibility test of the model solutions:\n> python check_physical_constraints.py",
    "The code verifies whether the constraints in Equations 16[href=https://www.wicell.org#fd16] and 17[href=https://www.wicell.org#fd17] are satisfied or not (Figure 2[href=https://www.wicell.org#fig2]D).\nDebug the code of the ODE model. By simulating different parameter values, one can check the potential bugs in the code. In the example of our model, if    v ¯    is set to 0, xH,ub(t) should be zero. In Equation 8[href=https://www.wicell.org#fd8], if a0u(t) and b0v(t) are much higher than a2 and b1 by setting a0, b0,    u ¯   , and    v ¯    as relatively high and setting a2 and b1 as relatively low, then x0,ub(t) should become very small (Figures 2[href=https://www.wicell.org#fig2]E and 2[href=https://www.wicell.org#fig2]F). The code in the following command allows these bug tests:\n> python check_debugging.py\nExecuting this code gives the parameter conditions and the graphs of the relevant simulation results.\nSampling of parameter values\nTiming: 1 h to several days (depending on the size of parameter dimension)\nIn this section, we will describe how to sample a large number of parameter values with multiple CPU cores. Utilizing parallel computing would save much of the simulation time.\nGenerate multiple parameter values and run the BS with these parameter values.\nIf the number of the parameter values is too large, the Python modules “multiprocessing” and “mpi4py” can save much of the simulation time.\nHow to use “multiprocessing” module: construct the wrapping module that only takes “parameter_sets”. The “parameter_sets” is a list of N parameter sets, and the wrapper is a wrapping module that takes a single parameter set as input. Parallel computing with a number of CPU cores can be implemented using these modules.\n> import multiprocessing as mp\n> parameter_sets = [parameter_set_1, …, parameter_set_N]\n> pool = mp.Pool(Number_of_CPU_cores)\n> pool.map(wrapper, parameter_sets)\nHow to use “mpi4py” module: “mpi4py” module allows the model simulation with each node. An example is shown below.",
    "> from mpi4py import MPI\n> comm = MPI.COMM_WORLD\n> num_processor = comm.Get_size()\n> rank = comm.Get_rank()\n> simulation_done_by_one = 0\n> simulation_target_by_one = N\n> while(simulation_done_by_one < simulation_target_by_one):\n>  …\n>  simulation_done_by_one += 1\nHere, N is the target number of the simulations in one node.\nNote: In both the cases i and ii above, be careful when writing a file. If two different nodes access the same file, this file may not be readable at the end."
  ],
  "subjectAreas": [
    "Computer Sciences",
    "Systems Biology",
    "Biophysics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics"
  ]
}