{
  "id": 3316,
  "origin_website": "Cell",
  "title": "A protocol for the use of cloud-based quantum computers for logical network analysis of biological systems",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\n      As the account setups are now complete, you can begin with the analysis of\n      Boolean networks.\n    \n      Obtaining network rules from Cell Collective in SBML format\n    \nTiming: 5 min\n      In this section we show how to download the required Boolean networks from\n      the Cell Collective database.\n    \n        Go to\n        https://cellcollective.org/[href=https://cellcollective.org/]10[href=https://www.wicell.org#bib2]\nClick the ‘Get Started as Researcher’ button.\n        Find a Boolean network to analyze. The\n        imgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2904-Fx4.jpg\n        icon on the top right can be used show the available models in a list.\n        Boolean networks are indicated by the ‘boolean’ value in the ‘Type’\n        column.\n      \nNote: In this protocol, we will focus on\n      the networks of Giacomantonio and Goodhill9[href=https://www.wicell.org#bib3]\n      and Fauré et al.11[href=https://www.wicell.org#bib4] These models are\n      available under the names “Cortical Area Development” and “Mammalian Cell\n      Cycle 2006” respectively.\n    \n        Click ‘File’ --> ‘Download’ --> ‘SBML’ to obtain the Boolean rules\n        of the model as a .sbml file. This format can be further processed using\n        the BoolNet R-package.3[href=https://www.wicell.org#bib5]\nAlternatives: Use the Jupyter\n      notebook “STARProtocol.ipynb” along with the two networks provided as txt\n      files in the ‘networks’ folder of the GitHub repository associated with\n      this protocol (https://github.com/sysbio-bioinf/QuantumSTARProtocol[href=https://github.com/sysbio-bioinf/QuantumSTARProtocol]). The files for any other Boolean network to be analyzed should be\n      placed in the same ‘networks’ folder.\n    \n      Installing BoolNet to convert network rules into txt format\n    \nTiming: 5 min\n      We here explain how to use the BoolNet package for R for parsing the\n      networks obtained in the previous section.\n    \n        Download and install the latest version of R following the instructions\n        at\n        https://cran.r-project.org/[href=https://cran.r-project.org/]\n        for your operating systems.\n      \n        Download and install RStudio following the instructions at\n        https://rstudio.com/ide[href=https://rstudio.com/ide] for your\n        operating system.\n      \nOpen RStudio and run the command\n> install.packages(\"BoolNet\")\n      in the console to install the latest version of BoolNet3[href=https://www.wicell.org#bib5]\n      from CRAN.\n    \n        Run the function convertRules() in the file convertRules.R provided on",
    "the GitHub repository. This takes the arguments ‘SBML’ and ‘savePath’\n        for the paths where the provided SBML file is located as well as the\n        desired location to save the .txt file.\n      \nNote: Boolean networks may contain time\n      delays, meaning that the update of a gene’s state relies on that gene’s\n      state more than one time step in the past. When networks are obtained from\n      the Cell Collective and represented using BoolNet notation in txt format,\n      such delays are indicated by square brackets. E.g. the appearance of a\n      term such as “Fgf8[-2]” in a Boolean rule means that the rule’s output is\n      calculated based on the value of Fgf8 two time steps in the past. The\n      proposed methods can not be applied to networks containing such time\n      delays in their rules.\n    \n      Installing software packages to run algorithms on quantum devices\n    \nTiming: 5 min\n      In this section, we explain an alternative way to install the required\n      Python packages, including the Qiskit environment, which does not rely on\n      the provided Jupyter notebook directly.\n    \n      In the specified GitHub repository, we provide a requirements.txt file\n      which can be used to install all libraries that are required for the\n      following analyses. This includes, among others, the Qiskit and Amazon\n      Braket SDKs for the creation and simulation of quantum circuits, and the\n      qiskit-ibm-runtime library for sending tasks to real IBM quantum\n      processors using the Runtime environment.\n    \nTo do so:\n        Create a new virtual environment in the programming language Python\n        named ‘myenv’ using the command\n      \n$ python -m venv myenv\nor.\n$ conda create --name myenv\nif Conda is installed.\nActivate this environment using\n$ source myenv/bin/activate\nInstall the libraries locally using the command\n$ pip install -r requirements.txt\nwith the downloaded file.\nMapping Boolean rules to quantum circuits\nTiming: seconds",
    "In this section we describe how the Boolean logic can be mapped into\n      quantum circuits. This process is an essential block for the algorithms\n      described further below.\n    \n      The function\n      parse_BoolNetRules(rulestxt = ”./networks/Giacomantonio2010.txt”,\n        saveDir = None)\n      provided in the functionsForProtocol.py file takes the argument\n      ‘rulestxt’, which specifies the path to the text file containing the\n      Boolean network rules (e.g., for the network of Giacomantonio), and\n      returns a Python file containing the instructions to build the associated\n      quantum circuit.\n    \nThis is done by.\n        Import the file “functionsForProtocol.py” in the Jupyter notebook.\n      \n        Run the parse_BoolNetRules() function. This generates a Python file with\n        the name of the network, with the ending “_rulefile.py”.\n      \nNote: The generated “_rulefile.py” file\n      includes all Boolean rules used to synthesize quantum circuits for\n      performing state transitions. These are defined using\n      ‘@classical_function’ from the qiskit.circuit library. The package\n      ‘tweedledum v1.1.1’ was used for the parsing of Boolean logic into quantum\n      circuits.\n    \n      Simulating the dynamics of a quantum Boolean network locally\n    \nTiming: seconds\n      In this section we simulate the dynamics of Boolean networks on quantum\n      devices using the local processor. This procedure is commonly used for\n      testing the created quantum circuit before sending it to a real quantum\n      device.\n    \nNote: The main function used for\n      generating circuits performing state transitions is\n      quantumStateTransition(). This function generates circuits of\n      \n(\n T + 1 \n)\nn\n      qubits to simulate\n      \n T \n      state transitions of an\n      \n n \n      component network, with each time step being mapped to a separate set of\n      qubits. Qubits are initially in the ‘0’ state by default. The first set of\n      n qubits of these circuits is initialized with a layer of Hadamard gates,\n      creating a uniformly weighted superposition of all\n      \nN =\n 2 n \n      states. All dynamical analyses are presented using the n = 5 cortical area\n      development network of Giacomantonio and Goodhill9[href=https://www.wicell.org#bib3]",
    "as an example, as shown in the Jupyter notebook.\n    \n        Call the function as shown in the following code snippet, which\n        generates a quantum circuit for performing\n        \nT =\n4\n        consecutive quantum state transitions from an initial uniform\n        superposition state and measures the final register of\n        \n n \n        qubits, which will stochastically collapse the superposition state on\n        one of the network’s two attractors.\n      \nNote: This process of initializing,\n      running and measuring the circuit is called a shot, which is then repeated\n      1000 times, yielding a probability distribution of measurement outcomes.\n    \n#Functions and network file required for all further analyses\nfrom functionsForProtocol import ∗\nrulestxt = \"./networks/Giacomantonio2010.txt\"\nCorticalNet4Transitions = quantumStateTransition(rulestxt, Tmax=4,\n          nrshots=1000)\nprint(CorticalNet4Transitions)\nNote: Given the order of components\n      specified in Giacomantonio2010.txt this returns the unperturbed\n      classical Boolean network’s attractor distribution of the states 10010 and\n      01101 with probabilities of 87.5% and 12.5% respectively. These\n      probabilities are equivalent to the attractor’s basin sizes, which denote\n      the relative number of states flowing into a given attractor. In Qiskit,\n      bitstrings denoting gene activity are read from right to left.\n    \n      Adding noise profiles to a simulator mimicking a real IBM quantum\n      processor\n    \nTiming: seconds to minutes\n    \n      In this section we simulate a single noisy state transition in the\n      cortical area network using a fake backend imitating the noise profile of\n      a real IBM quantum device.\n    \nNote: In addition to exact, noiseless\n      simulations, Qiskit offers the possibility of testing the results and\n      performance of a quantum circuit on simulators that can mimic the error\n      rates of the various real quantum processors by IBM. These are referred to\n      as ‘fake’ or ‘mock’ backends. These backends do not access a real device\n      and thus do not require the creation of an IBM Cloud account and their use\n      does not generate any costs. A comparison of the noisy and exact",
    "simulations can give a general estimate of the expected fidelity with\n      which a quantum circuit can be executed.\n    \n        To import an existing fake backend, check the list of devices for which\n        this is available. To do this, check the backends available in the\n        qiskit.providers.fake_provider module of Qiskit.\n      \n        Run the following code snippet which adds the noise profile of this\n        backend and simulates a state transition.\n      \nNote: We chose as an example to import the\n      FakeToronto backend, mimicking the noise profile of the 27-qubit\n      IBMQ Toronto processor.\n    \nfrom qiskit.providers.fake_provider\n          import FakeToronto\nrulestxt = \"./networks/Giacomantonio2010.txt\"\nbackend = FakeToronto()CorticalNet_noisySimulatorTransition =\n          quantumStateTransition(rulestxt, Tmax=1, nrshots=1000,\n          backend=backend, optimization_level=3)\nprint(CorticalNet_noisySimulatorTransition)\nNote: Since there is a limited set of\n      quantum gates available on the IBMQ Toronto device, the operations\n      performed in the circuit are first transpiled, i.e. decomposed, into these\n      native gates. This transpilation also respects the coupling map of the\n      processor, which specifies which pairs of qubits can execute 2-qubit\n      gates. For example, to perform operations on pairs of qubits that are not\n      connected on the coupling map, swap gates are added. Therefore, the\n      transpiled circuit will be deeper than the circuit executed on the\n      noiseless simulator. The required time for adding the noise profile will\n      increase significantly if more than one noisy state transition is\n      simulated due to the increasing depth of the circuit after transpilation.\n    \nNote: The parameter\n      optimization_level can take integer values from 0 to 3, with 0\n      indicating no optimization while 3 denotes the maximal optimization to\n      result in a decomposition that is as shallow as possible. The chosen\n      optimized transpilation is a partially stochastic process which will yield\n      circuits of varying depths. This can be prevented by adding an optional\n      value for the seed_transpiler argument. This can be an arbitrary\n      integer, e.g. seed_transpiler = 123, however the same value should be kept",
    "for all future simulations to ensure reproducibility. The noise profile\n      thus applies coherence times as well as gate errors stored in the\n      FakeToronto() backend model. The provided Jupyter notebook also\n      includes a visualization which compares the resulting distributions as bar\n      plots. Additionally, we calculate fidelity measures to quantify their\n      similarity.\n    \n      Using parameterized circuits to gradually vary initial gene activities\n    \nTiming: seconds\n      We use rotation gates to modify the bias of the initial qubit states, thus\n      changing the probabilities associated with attractors.\n    \nNote: Using the additional arguments\n      ‘initActivities’ and ‘thetatype’ for the quantumStateTransition()\n      function, we can continuously tune the activity of genes in the initial\n      superposition state.\n    \n      Here, initActivities is an array of\n      \n n \n      elements, with the i-th element indicating the bias for the\n      i-th gene in the network file. These angles correspond to the polar\n      angle on the Bloch sphere, i.e., 0° is identical to the default ‘0’ state\n      and a\n      \n R y \n(\nθ =\n 90 ° \n)\n      rotation would yield the same result as the previously used Hadamard\n      gates. The argument ‘thetatype’ specifies whether the rotation is given as\n      an ‘angle’ or ‘radian’.\n    \n        Call the function in the following code snippet, which exemplarily\n        simulates a steady increase in the initial activity of the first\n        component listed in the network, Fgf8, please also refer to Weidner\n        et al.1[href=https://www.wicell.org#bib1] (supplement section 4).\n      \n        Verify that for\n        \nθ =\n 0 ° \n , only the 10010 attractor is found, indicating that the entire\n        subspace of\n        \n2  n − 1 \n= 16\n        states where Fgf8 is inactive leads to this attractor. The weight of the\n        01101 should then gradually increases with the bias of the tuned\n        component towards the ‘1’ state.\n      \n#Variation in first gene Fgf8\nthetavalues = list(range(0,190,10)) #vary angle from 0° to 180°\nfor theta in thetavalues:",
    "print(\"Gate used for initialising the first gene is R_y(theta = \" + str(theta) + \"°)\")\n  ThetaVariationGiacomantonio =\n          quantumStateTransition(rulestxt, Tmax=4, nrshots=1000,\n          initActivities=[theta,90,90,90,90], thetatype=\"angle\")\n  print(ThetaVariationGiacomantonio)\n      Simultaneous knockout and overexpression simulations by use of\n      superposition perturbations\n    \nTiming: seconds\n      In this section, we use superposition states as perturbations of the\n      network dynamics. This is done by using the initActivities and\n      initPerturbed arguments of the quantumStateTransition() function.\n    \nNote: ‘initActivities’ specifies if genes\n      should be perturbed with a particular superposition state. We do this\n      using an additional Boolean vector: initPerturbed. If entries in this\n      vector are True, the corresponding initial state created by the\n      \n R y \n ( θ ) \n      rotations specified in initActivities will be re-used after every quantum\n      state transition.\n    \nNote: For angles that are not 0° or 180°,\n      this is equivalent to simultaneously performing a classical knockout (KO)\n      and overexpression (OE) simulation, both of which may alter the system’s\n      attractor landscape.\n    \n        Execute the first function call in the following code snippet where the\n        third network component Pax6 is perturbed with a bias towards OE.\n      \nNote: This returns attractors from both a\n      KO and OE simulation, however those of the OE perturbation will contribute\n      with larger probabilities than would be the case in an unbiased averaging\n      of attractor basin sizes.\n    \n        Execute the second function call, where a second perturbation with a\n        bias towards KO for the fifth component, Coup_tfi, is added. This\n        returns the union set of all attractors from the four possible double\n        perturbations.\n      \nSingleSuperpositionPerturbation =\n          quantumStateTransition(rulestxt,\nTmax=4, nrshots=1000, initActivities=[90,90,135,90,90],\ninitPerturbed=[False, False, True, False, False],\n          thetatype=\"angle\")\nprint(\"Single superposition perturbation of Pax6, biased towards OE:\")\nprint(SingleSuperpositionPerturbation)\nprint(\"Double superposition perturbation of Pax6 and Coup_tfi, biased\n            towards OE and KO respectively:\")\nDoubleSuperpositionPerturbation =\n          quantumStateTransition(rulestxt,\nTmax=4, nrshots=1000, initActivities=[90,90,135,90,45],\ninitPerturbed=[False, False, True, False, True],\n          thetatype=\"angle\")\nprint(DoubleSuperpositionPerturbation)\n      Performing inverted state transitions by amplitude amplification\n    \nTiming: seconds",
    "We exploit the reversibility of quantum circuits in combination with\n      Grover’s algorithm to amplify the probability of states that are\n      predecessors of a specified attractor.\n    \nNote: The following code generates a\n      circuit implementing\n      \nG =\n2\n      iterations of the Grover operator, i.e. two repetitions of oracle and\n      diffuser. The marked state is the attractor 01101, whose predecessors and\n      pre-predecessors (nrTransitions = 2) will be amplified. That is, this\n      Grover search effectively performs inverted state transitions.\n      Single-state attractors such as 01101 are their own predecessors, thus all\n      four states in the basin of attraction of this attractor (01101, 11101,\n      11001, 01001) will have their probabilities of measurement increased.\n      Repeated runs and measurements of this circuit will yield a probability\n      distribution over all possible\n      \n 2 5 \n= 32\n      states of this 5-gene network.By repeated measurement, we found that the\n      circuit has a probability of 93.4% to yield one of these four states in\n      the basin of attraction even though they make up only 12.5% of the\n      system’s state space.\n    \nTo reproduce the same analysis.\n        Run the following code snippet to amplify the predecessor states of the\n        ‘markedState’ attractor 01101 using G = 2 iterations of the Grover\n        operator.\n      \n        Verify that the solution probability is larger than the 4/32 = 12.5%\n        probability which would be expected from random sampling.\n      \nOptional: Change the parameter G to\n      see how the amplification of the four solution states varies. The degree\n      to which predecessor states are amplified depends on the number of\n      iterations\n      \n G  . The optimal value for this parameter depends on the total number of\n      solutions, which can be determined by quantum counting, as described\n      further below.\n    \nprint(\"G=2 iterations:\")\nInvertedTransitionsCircuit_G2 =\ngenerate_groverSTGinversion_circuit(rulestxt, nrTransitions=2,\nmarkedState=[0,1,1,0,1], G=2)\nresult_G2 = execute(InvertedTransitionsCircuit_G2,\nbackend=Aer.get_backend('qasm_simulator'),\n          shots=1000).result()\ncountDict_G2 =\noutputformat(result_G2.get_counts(InvertedTransitionsCircuit_G2),\nnormalizeOutput=True, sortOutput=True, digits=3)\nprint(countDict_G2)\nsolution_prob_G2 = countDict_G2[ \"11001\"] +\n          countDict_G2[\"01001\"] +",
    "countDict_G2[\"01101\"] +\n          countDict_G2[\"11101\"]\nprint(\"After G=2 iterations, the M/N=4/32 solution states have a\ncumulative probability of \" + str(solution_prob_G2) +\n          \".\")\nBasin size estimation using quantum counting\nTiming: seconds to minutes\n    \n      In this section, we use a quantum counting algorithm to count the total\n      number of solutions states instead of amplifying their probabilities as in\n      the previous section.\n    \nNote: The quantum counting algorithm\n      combines the Grover operator with a quantum Fourier transform to estimate\n      the total number of solutions M of a Grover search. Results are measured\n      on a separate readout register of qubits, whose length ‘r_registerLen’\n      determines the accuracy of the obtained value. The measured bitstrings\n      here no longer correspond to gene activity but instead represent the\n      binary encoding of an integer value for M. In the examples shown below,\n      the state 00000 has 14 immediate predecessors, while the attractor 01101\n      has a basin size of 4, which is reached after at least two inverted\n      transitions, as in the Grover search before.\n    \n        Run the first function call to QuantumCountingAlgo() in following code\n        snippet, which estimates the number of immediate predecessors of the\n        state 00000 (14 states in total in the classical system).\n      \n        Run the second function call to QuantumCountingAlgo(), which estimates\n        all predecessors of the 01101 attractor up to 2 transitions away from\n        the attractor (4 states in total in the classical system).\n      \nCountingResults_00000_Tinv1 = QuantumCountingAlgo(rulestxt,\nnrTransitions=1, markedState=[0,0,0,0,0], r_registerLen=5, nrshots =\n          1000)\nprint(CountingResults_00000_Tinv1)\nCountingResults_01101_Tinv2 = QuantumCountingAlgo(rulestxt,\nnrTransitions=2, markedState=[0,1,1,0,1], r_registerLen=5,\n          nrshots =\n1000)\nprint(CountingResults_01101_Tinv2)\nSubmitting tasks to IBM’s quantum processors\nTiming: seconds to hours, depends on\n      queue and whether the device is currently online or undergoing maintenance\n    \n      In this section we submit the circuits we created to the IBM quantum\n      devices to be run.\n    \nNote: IBM Qiskit Runtime is a new\n      framework used to access IBM’s quantum processing units, offering in-built",
    "optimization procedures aimed at simplifying commonly performed analyses.\n      A prominent feature of the Runtime framework is the possibility to apply\n      some techniques of error suppression and mitigation in an automated way.\n    \n      Making use of the code in the snippet below, execute the following steps.\n    \n        Define a runtime service based on the account previously saved (in the\n        snippet).\n      \n        Generate a circuit for a single state transition from a uniform\n        superposition state (in the snippet).\n      \n        Transpile the generated circuit to match the set of gate operations\n        available on the ‘ibm_algiers’ quantum device (in the snippet).\n      \n        Monitor the status of the running job on the quantum device, after it\n        gets assigned a job_id, under ‘Jobs’ in the associated instance in the\n        IBM quantum cloud (on the IBM cloud webpage). See\n        troubleshooting[href=https://www.wicell.org#troubleshooting]\nproblem 1[href=https://www.wicell.org#sec5.1], problem 2[href=https://www.wicell.org#sec5.3],\n        problem 3[href=https://www.wicell.org#sec5.5].\n      \n        Read the results from the dictionary saved in the “result” variable.\n      \nNote: The ‘binary_probabilities()’ line\n      indicates that states are to be listed as bitstrings as before instead of\n      decimal integers (e.g. without this line the result would be presented in\n      such a way that 00011 --> 3), to more easily evaluate which network\n      components are active or inactive.\n    \nfrom qiskit_ibm_runtime import QiskitRuntimeService, Sampler,\n            Session,\nOptions\nfrom qiskit import transpile\nfrom qiskit.tools.visualization import plot_histogram\n# Save an IBM Cloud account on disk and give it a name.\nservice =\n          QiskitRuntimeService(name=\"StarProtocol\")\noptions = Options()\n# The following two settings are optional\noptions.resilience_level = 0 #Range from 0 to 3, 1 by default\noptions.optimization_level = 0 #Range from 0 to 3, 3 by default\nCorticalNet1Transition = quantumStateTransition(rulestxt,\n          Tmax=1,\nreturnCircuitOnly=True)\nbackend = service.get_backend('ibm_algiers')\nCorticalNet1Transition_tr = transpile(CorticalNet1Transition,\n          backend)\nwith Session(service=service, backend = backend):\n  sampler = Sampler( options = options)\n  job = sampler.run( circuits=CorticalNet1Transition_tr,\n          shots=100)\n  result = job.result().quasi_dists[\n          0].binary_probabilities()\nprint(result)\nOptional: by adding the two lines of\n      code “options.resilience_level = num” and",
    "“options.optimization_level = num” it is possible to access and\n      modify the error mitigation and error suppression techniques currently\n      available within the Runtime framework. Both parameters can range from 0\n      (no mitigation/suppression) to 3 (maximum mitigation/suppression).\n    \n      Further explanations on how these methods work can be found online at the\n      Qiskit webpage (Mitigation: https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/error-mitigation.html[href=https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/error-mitigation.html]\n      ,\n    \n      Suppression:\n      https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/error-suppression.html[href=https://qiskit.org/documentation/partners/qiskit_ibm_runtime/how_to/error-suppression.html])\n    \nExtra error mitigation techniques (optional)\nTiming: Minutes to hours\n    \n      In this section we make use of error mitigation techniques to improve the\n      quality of the results provided by the quantum device.\n    \nNote: On top of the error mitigation and\n      suppression techniques offered by the runtime framework, other methods can\n      be used to better refine the results one can obtain from a quantum\n      computer. We provide here one example: Multiple transpilation. The\n      transpilation of an algorithm on to a quantum device is not a unique\n      process, but can be performed in different, yet theoretically equivalent\n      ways. The performance of these different transpiled algorithms on a\n      quantum device can be very different though, providing a motivation to try\n      to find the optimal one to perform the required analysis. As Qiskit\n      transpilation methods, though relying on several optimization methods,\n      still involve stochasticity to a certain degree, it is possible to perform\n      the transpilation of a given algorithm multiple times and select among\n      those the one thought to be the best one upon a chosen criterion. In our\n      case, we choose the transpilation with the least number of CNOT gates\n      involved.\n    \nTo perform Multiple transpilation:\n        Define the quantum circuit to be executed (CorticalNetTransition in the\n        snippet below).\n      \n        Transpile multiple times the same circuit: in general these\n        transpilations will be different from each other.\n      \n        Count the number of CNOT gates present in each of the different\n        transpilations.\n      \n        Select as the preferred choice the transpilation with the least number",
    "of CNOT gates.\n      \n        Run the selected quantum circuit with the same method used for the\n        circuits above. See troubleshooting[href=https://www.wicell.org#troubleshooting]\nproblem 1[href=https://www.wicell.org#sec5.1], problem 2[href=https://www.wicell.org#sec5.3],\n        problem 3[href=https://www.wicell.org#sec5.5].\n      \nservice = QiskitRuntimeService(name=name)\n          #Login to IBMQ runtime service\nbackend = service.get_backend('ibm_algiers')\n          #Configure the quantum\ndevice to be used\nCorticalNet1Transition = quantumStateTransition(rulestxt,\n          Tmax=1,\nreturnCircuitOnly=True)\n          #Create the circuit simulating the Boolean\nnetwork to be analyzed\ntrans_qc_list = transpile([CorticalNet1Transition]∗ 20,\n          backend,\noptimization_level=3)\n          #Generate 20 different transpilations for the\ncircuit to be run\ncx_count = [circ.count_ops()[ 'cx'] for circ\n          in trans_qc_list] #Count the\nnumber of CNOT gates contained in each different transpilation\nbest_idx = np.where(cx_count == np.min(cx_count))[0][0] #Pick the\n          transpilation with the least amount of CNOT gatesbest_qc =\n          trans_qc_list[best_idx]\n          #Set given transpilation to be the\ncircuit to run\nCorticalNet1Transition_tr =\ntranspile(best_qc,backend, optimization_level=0)#Create the\n          transpiled\ncircuit with the features evaluated above\n#Run everything on the cloud platform\nwith Session(service=service, backend = backend):\n  sampler = Sampler( options =\n          Options(resilience_level=0))\n  job = sampler.run( circuits=CorticalNet1Transition_tr,\n          shots=100)\n  result =\n          job.result().quasi_dists[0].binary_probabilities()\nprint(result)\nplot_histogram(result)\n      Running quantum circuits on an IonQ’s QPU using AWS braket\n    \nTiming: hours, depending on time at\n      which task was sent and queue of the device\n    \n      In this section, we send a task for the simulation of a quantum state\n      transition to the Amazon Braket cloud using the account that was set up in\n      the “Before you begin” section.\n    \n      To run tasks on the IonQ quantum processor, provide the name of your\n      bucket and a folder inside that bucket after having saved your keys using\n      “aws configure”.\n    \nNote: The estimated cost for all tasks run\n      using your AWS account can be seen by clicking your account name in the\n      top right corner --> “Account” --> “Bills”. Additional payment\n      methods can be added under “Account” --> “Payment preferences”. When a\n      new credit card is added, AWS will send a 1,00$ authorization charge to",
    "verify the legitimacy of the card.\n    \n        Replace the variables “my_bucket” and “my_prefix” with your specific\n        information as described in the “before you begin[href=https://www.wicell.org#before-you-begin]” section.\n      \nRun the code snippet to obtain a cost estimate.\nfrom braket.aws import AwsDevice\nnrshots = 100\ncost = 0.3+0.01∗nrshots #$0.30 / task + $0.01 / shot\nprint(\"NOTE: Running a task on the IonQ backend with this number of\n            shots\nwill create costs of $\" + '{0:.2f}'.format(cost) + \" USD!\")\n#Specify your account specific data here\nmy_bucket = \"amazon-braket-YOUR-BUCKET-HERE\"\nmy_prefix = \"YOUR-FOLDER-NAME-HERE\"\ns3_folder = (my_bucket, my_prefix)\ndevice = AwsDevice(\n          \"arn:aws:braket:us-east-1::device/qpu/ionq/Harmony\")\n#real IonQ QPU, larger device named Aria is also available\n#device = AwsDevice(\"arn:aws:braket:::device/quantum-\nsimulator/amazon/sv1\") #SV1 state vector simulator, costs\n            $0.075 USD per\nminute of run time\nNote: If the QPU is offline, we can use\n      the SV1 simulator for testing purposes.\n    \n      For more information on this simulator, go to Devices--> SV1 in the\n      Amazon Braket Dashboard or use the following link:\n      https://docs.aws.amazon.com/braket/latest/developerguide/braket-devices.html#braket-simulator-sv1[href=https://docs.aws.amazon.com/braket/latest/developerguide/braket-devices.html#braket-simulator-sv1].\n    \n        Run the following code, which generates a circuit performing a single\n        state transition, analogous to the one shown in the previous analysis\n        using Qiskit Runtime, sends out the task and prints the results. See\n        troubleshooting[href=https://www.wicell.org#troubleshooting]\nproblem 1[href=https://www.wicell.org#sec5.1], problem 4[href=https://www.wicell.org#sec5.7],\n        problem 5[href=https://www.wicell.org#sec5.9], problem 6[href=https://www.wicell.org#sec5.11].\n      \nGiacoCirc = synthesizeFullNetworkUpdateCircuit(rulestxt,\nupdate=\"synchronous\")\nn= 5 InitCircuit = QuantumCircuit(2∗n, n)\nfor q in range(5):\nInitCircuit.h(q)\nGiacoCirc = InitCircuit.compose(GiacoCirc, list(range(0, 2 ∗\n          n)),\nlist(range(0, n)))\nIonQCircuit = QiskitQASM2IonQCompiler(GiacoCirc,\ngatenameMapping=gatenameMapping_Qiskit_IonQ)\nprint(\"Circuit depth:\")\nprint(IonQCircuit.depth) #Depth of 140 for single Giacomantonio\ntransition circuit\nnow = datetime.now()\ncurrent_time = now.strftime( \"%H:%M:%S\")\nprint(\"Current Time =\", current_time)\ntask = device.run(IonQCircuit, s3_folder, shots=nrshots,\npoll_timeout_seconds=24∗60∗60∗20) #20 day polling time before task\n          times\nout\nresultCounts = task.result().measurement_counts\nprint(resultCounts)\nnow = datetime.now()\ncurrent_time = now.strftime( \"%H:%M:%S\")\nprint(\"Current Time =\", current_time)\n#IonQ measures all qubits -> Parse output back into same format as\n          was\nused in Qiskit simulations",
    "qubitindices = [5,6,7,8,9] # Which qubits carry the outputs at t=1\n          for\nnodes in order, 0-indexed\nresultCounts_qiskitFormat =\n          ionqDict2qiskitNotation(resultCounts,\nqubitindices=qubitindices, invertEndian=True)\nprint(resultCounts_qiskitFormat)\nNote: To run circuits generated in Qiskit\n      on the IonQ processor, we rewrite the circuits to be executable on the\n      natively available set of basis gates of the device. The returned results\n      are also parsed back into dictionaries in the qiskit format. This is\n      necessary as gate names differ between the two frameworks. For the IonQ\n      device, all qubits are measured. The probabilities concerning only the\n      activities of the desired qubits corresponding to the output of the state\n      transition are then summed up. These transformations are performed by the\n      custom functions QiskitQASM2IonQcompiler() and ionqDict2qiskitNotation().\n    \nNote: The\n      poll_timeout_seconds argument when running a circuit using Braket\n      gives the value in seconds for which a task will be polled for results. It\n      is set to a default value corresponding to 5 days. Depending on the\n      current queue, shorter values may lead to a timeout before the task is\n      finished.\n    \n      The average expected queue time can be checked at\n      https://status.ionq.co/[href=https://status.ionq.co/] along with\n      the current status of the QPU. This site also lists any recent incidents\n      which may be informative if a job is not being executed."
  ],
  "subjectAreas": [
    "Computer Sciences",
    "Systems Biology"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics"
  ]
}