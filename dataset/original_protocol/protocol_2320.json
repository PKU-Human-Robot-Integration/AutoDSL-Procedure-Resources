{
  "id": 2445,
  "origin_website": "Cell",
  "title": "Generating transcriptional regulatory networks from time-ordered stem cell differentiation RNA sequencing data",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nDownload and prepare the data matrix for analysis\nTiming: 1 min\nStem cell differentiation is determined by the underlying gene regulatory network during the process of development, which leads the stem cells into their particular terminal cell phenotype. During stem cell differentiation, the stemness biomarkers of stem cells will descend over time while the characteristics and functions of terminal cells will ascend. The proposed protocol is designed for time-ordered transcriptomic profiling data. First, we use the MFSelector package to identify ascending and descending monotonic key genes. Then, we use the TO-GCN software to identify the time order of transcriptional factors and biological processes. Based on the official MFSelector tutorial, it accepts data in a tab-delimited text file with the first column containing gene identifiers. It is first developed for gene expression microarray data, but it is also compatible for RNA sequencing data. The expression values can be either normalized read counts (i.e., counts per million, CPM) or other quantitative measures, such as TPM (transcripts per million), and FPKM (fragments per kilobase of transcript per million fragments mapped). TO-GCN recommends to use normalized quantitative measures, e.g., TPM but also accepts normalized read counts. In this protocol, we use an RNA sequencing dataset from our previous study (Wong et al., 2020[href=https://www.wicell.org#bib15]) as an example. It is the dataset of mesenchymal stem cells differentiated into mesangial cells. This dataset has been deposited in the Gene Expression Omnibus (GEO) database: GSE140914 (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE140914[href=https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE140914]). This dataset has been normalized with TMM (Trimmed Mean of the M-values) and and processed CPM values after batch effect removal. These processed data are analysis-ready. Only a simple process is required to combine the data of all samples.\nDownload the processed data (GSE140914_RAW.tar) from GEO with GEOquery package.",
    "Once the file is downloaded, use the command to extract the file.\n>library(GEOquery)\n>getGEOSuppFiles(\"GSE140914\", makeDirectory = F)\n>untar(\"GSE140914_RAW.tar\")\n>list.files(pattern = \"gz$\") |> lapply(gunzip)\nImport and combine the data with R.\n# Import data\n>data_list <- list.files(pattern=\"ˆGSM\") |> lapply(read.delim, header = TRUE)\n# Combine data\n>data_mat <- sapply(data_list, \\(x) x[, 3])\nNote: We import the data of 15 samples from 15 decompressed files. Each file contains three columns, which are Ensembl gene identifiers, HGNC gene symbols, and normalized read counts. The genes of all files are in the same order. We can combine these data without additional mapping efforts.\nProcess the sample names.\n# Get sample names, batch information, group information\n>sample_names <- sapply(data_list, \\(x) colnames(x)[3])\n>sample_names <- gsub(\"X\", \"\", sample_names)\n>batch_id <- gsub(\"\\\\.\\\\S+\", \"\", sample_names)\n>sample_group <- gsub(\"\\\\S+\\\\.\", \"\", sample_names)\n>sample_code <- paste0(\"B:\", batch_id, \"_D:\", sample_group)\nNote: The third column name is the sample name which is named as “batch (integer)”-“days after differentiation started (integer)”. When importing file into R, sample names will automatically be converted, for example, ‘1-1’ will become “X1.1”. Therefore, we include a few steps in our example code to deal with this.\nProcess the gene identifiers.\n>gene_id <- data_list[[1]][, 1]\n>gene_names <- data_list[[1]][, 2]\n>gene_labels <- paste(gene_id, gene_names, sep = \":\")\nNote: We use these commands to create a merged gene identifier for each gene which is composed of the Ensembl gene identifier and the HGNC gene symbol. We use the merged gene identifiers in next step to obtain readable outputs of MFSelector.\nGenerate the input data for MFSelector.\n# Assign column names and row names\n>colnames(data_mat) <- sample_code\n>rownames(data_mat) <- gene_id\n# Generate the input data for MFSelector\n>data <- cbind(gene_labels, as.data.frame(data_mat))\nVisualize the overall relationship between the samples with a multidimensional scaling (MDS) plot with R (Figure 1[href=https://www.wicell.org#fig1]).",
    "# Define a function to generate MDS plot\n>get_MDS_plot <- function(prefix, data_mat, sample_group){\n  cmd <- t(data_mat) |> dist() |> cmdscale()\n  df <- data.frame(Sample = colnames(data_mat), Dimension_1 = cmd[, 1],\n  Dimension_2 = cmd[, 2], Group = sample_group)\n  p1 <- ggplot(df, aes(Dimension_1, Dimension_2)) +\n  geom_point(aes(colour = Group), size = 4) +\n  scale_color_brewer(palette=\"Paired\") +\n  ggtitle(paste(prefix, \"MDS Plot\"))\n  print(p1)\n}\n# Load required package\n>library(ggplot2)\n# Generate a MDS plot for this dataset -> Figure 1[href=https://www.wicell.org#fig1]\n>get_MDS_plot(\"GSE140914\", data_mat, sample_group)\n>ggsave(\"GSE140914_MDSplot.tiff\", dpi = \"retina\"\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1929-Fig1.jpg\nFigure 1. A multidimensional scaling (MDS) plot based on the entire gene expression profile\nIdentification of ascending and descending monotonic key genes by Monotonic Feature Selector\nTiming: 30 min\nMFSelector is an R package which is designed to identify genes either with increasing or decreasing expressions across different time ordered stages, i.e., ascending and descending monotonic key genes. It is suitable for the transcriptomic profiling of cell differentiation investigations. The options for using MFSelector can be referred to the MFSelector Tutorial shown in the official site: http://microarray.bmi.nycu.edu.tw:8080/tools/module/MFSelector/index.jsp?mode=support[href=http://microarray.bmi.nycu.edu.tw:8080/tools/module/MFSelector/index.jsp?mode=support]. The key options for different datasets are the number of data points in each stage, the name represented for each stage, and the type of monotonic genes. We develop the protocol with the multicore version of MFSelector.\nPrepare the inputs with R.\nLoad required package.\n>library(MFSelector)\n>library(parallel)\nPrepare MFSelector key input arguments.\n>nsc <- table(sample_group)\n>stageord <- order(sample_group)\n>stagename <- sample_group |> unique() |> sort()\nDetect the number of total cores in the current machine.\n>total_cores <- detectCores()\n>half_cores <- total_cores/2\nIdentify candidate descending monotonic key genes with MFSelector. The outputs are a table of candidate genes saved in a tab-delimited text file and the scatter plots of all candidate genes saved in a PDF file.\n>mfselector(data, nsc, stageord = stageord, stagename = stagename,",
    "type = 1, nline = T, dline = T, pdf = 1:100, cmp = 0, permut = 100, svdenoise = 0.03, svdetimes = 4, cores = half_cores)\nRename the output files.\n>mf_outputs <- list.files(pattern=\"ˆmfselector\")\n>mf_outputs_type1 <- gsub(\".∗\\\\.\", \"MFSelector_Type1.\", mf_outputs)\n>mapply(file.rename, mf_outputs, mf_outputs_type1)\n>rm(mf_outputs, mf_outputs_type1)\nIdentify candidate ascending monotonic key genes.\n>mfselector(data, nsc, stageord = stageord, stagename = stagename,\ntype = 2, nline = T, dline = T, pdf = 1:100, cmp = 0, permut = 100,\nsvdenoise = 0.03, svdetimes = 4, cores = half_cores)\nRename the second output files.\n>mf_outputs <- list.files(pattern=\"ˆmfselector\")\n>mf_outputs_type2 <- gsub(\".∗\\\\.\", \"MFSelector_Type2.\", mf_outputs)\n>mapply(file.rename, mf_outputs, mf_outputs_type2)\n>rm(mf_outputs, mf_outputs_type2)\nNote: For an alternative solution for running parallel MFSelector on a Windows machine, see troubleshooting[href=https://www.wicell.org#troubleshooting]: problem 3[href=https://www.wicell.org#sec5.5].\nExport high quality plots (complying with most publication standards)\nTiming: 4 min\nDefine an R function to identify genes that have fulfilled the given criteria.\n>candidate_genes_parser <- function(input_file, DE = NULL, SVDE = NULL, nline = NULL, out_col = NULL, ...){\n    input_tab <- read.delim(input_file)\n    rii <- 1:nrow(input_tab)\n    if(!is.null(DE)){\n      sii <- which(as.numeric(input_tab[, \"DE\"]) <= DE)\n      rii <- intersect(rii, sii)\n    }\n    if(!is.null(SVDE)){\n      sii <- which(as.numeric(input_tab[, \"SVDE\"]) <= SVDE)\n      rii <- intersect(rii, sii)\n    }\n    if(!is.null(nline)){\n      sii <- which(input_tab[, \"with.N.1.distinct.lines\"] == TRUE)\n      rii <- intersect(rii, sii)\n    }\n    if(is.null(out_col)){\n      candidate_genes <- as.character(input_tab[rii, 1])\n    }else{\n      candidate_genes <- as.character(input_tab[rii, out_col])\n    }\n    return(candidate_genes)\n}\nGet candidate monotonic key genes.\n>MF_type1_genes <- candidate_genes_parser(\"MFSelector_Type1.txt\", DE = 4)\n>MF_type2_genes <- candidate_genes_parser(\"MFSelector_Type2.txt\", DE = 4)\nFind the indices of candidate genes.\n>mii_type1 <- match(MF_type1_genes, gene_labels)\n>mii_type2 <- match(MF_type2_genes, gene_labels)\nGenerate MDS plots with these candidate genes (e.g., Figure 2[href=https://www.wicell.org#fig2]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1929-Fig2.jpg\nFigure 2. A multidimensional scaling (MDS) plot based on the gene expression profile of candidate descending monotonic key genes\n>get_MDS_plot(\"GSE140914_Type1\", data_mat[mii_type1, ], sample_group)\n>ggsave(\"GSE140914_Type1_MDSplot.tiff\", dpi = \"retina\") # Figure 2[href=https://www.wicell.org#fig2]\n>get_MDS_plot(\"GSE140914_Type2\", data_mat[mii_type2, ], sample_group)\n>get_MDS_plot(\"GSE140914_Type1+2\", data_mat[c(mii_type1, mii_type2), ], sample_group)",
    "Generate heatmap plots with these candidate genes.\nDefine a function for the Z-score transformation.\n>z_transformation <- function(x){(x-mean(x))/sd(x)}\nDefine a function to perform hierarchical clustering with the Ward's method.\n>ward_hclust <- function(d){hclust(d, method = \"ward.D\")}\nDefine a function to generate a heatmap.\n>get_heatmap<-function(prefix, data, sample_group, gene_symbols = NULL){\n    sample_col_fac <- as.factor(sample_group)\n    n_group <- sample_group |> unique() |> length()\n    dataZ <- apply(data, 1, z_transformation) |> t()\n    my_col_palette <- brewer.pal(11, \"RdBu\") |> rev()\n    levels(sample_col_fac) <- brewer.pal(n_group, \"Paired\")\n    col_colors <- as.character(sample_col_fac)\n    if(!is.null(gene_symbols)){\n          rownames(dataZ) <- gene_symbols\n    }\n    heatmap.2(dataZ, col = my_col_palette, ColSideColors = col_colors,\n      Colv = TRUE, dendrogram = \"both\", hclustfun = ward_hclust,\n      margins = c(5, 7), trace = \"none\", keysize = 1.2,\n      lhei = c(1.5, 9.5), lwid = c(1.5, 6.5))\n}\nLoad the required packages for generating heatmap.\n>library(gplots)\n>library(RColorBrewer)\nGenerate a heatmap plot with type 1 (descending) monotonic candidate genes (Figure 3[href=https://www.wicell.org#fig3]).\n>tiff(\"GSE140914_Type1_Heatmap.tiff\", width=10, height=12, unit=\"in\", res = 320)\n>get_heatmap(\"GSE140914_Type1\", data_mat[mii_type1, ], sample_group,\ngene_symbols = gene_labels[mii_type1])\n>dev.off() # Figure 3[href=https://www.wicell.org#fig3]\nNote: The default graphics device is 7 inches square, which is not large enough for a heatmap with a long gene list. Therefore, we create a larger TIFF device to save the heatmap.\nGenerate scatter plots with these candidate genes.\nDefine a function to generate the scatter plot with ggplot2.\n>get_scatter_plots <- function(my_gene_id, data, gene_id, sample_group, mf_tab){\n    mii1 <- which(gene_id == my_gene_id)\n    mii2 <- which(mf_tab[, 1] == my_gene_id)\n    if(length(mii1) > 0 & length(mii2) >0){\n      DE <- mf_tab[mii2, 2]\n      PVAL <- round(mf_tab[mii2, 3], 2)\n      QVAL <- round(mf_tab[mii2, 4], 2)\n      SVDE <- mf_tab[mii2, 5]\n      TITLE <- paste(my_gene_id, \"\\nDE =\", DE, \" p-value =\", PVAL,\n            \" q-value =\", QVAL, \" SVDE =\", SVDE)\n      expression <- as.numeric(data[mii1, ])\n      ordered_idx <- order(sample_group)\n      df <- data.frame(Samples = 1:length(expression),\n          Expression = expression[ordered_idx],\n          Group = as.factor(sample_group[ordered_idx]))\n      group_min_df <- data.frame(\n      Min = tapply(df$Expression, df$Group, min),\n      Group = levels(df$Group))",
    "p <- ggplot(data = df, aes(x = Samples, y = Expression)) +\n        geom_point(aes(color = Group, shape = Group),\n          size = 4) + scale_color_brewer(palette=\"Paired\") +\n        scale_x_continuous(breaks = 1:length(expression),\n          labels = colnames(data)[ordered_idx]) +\n        geom_hline(aes(yintercept = Min, color = Group),\n        group_min_df, lty = \"dashed\") + ggtitle(TITLE) +\n        theme(plot.title = element_text(hjust = 0.5)) +\n        theme_bw() + theme(axis.text.x = element_text(angle = 45,\n          vjust = 1, hjust = 1))\n      print(p)\n    }\n}\nImport the output text files of MFSelector.\n>mf_tab_1 <- read.delim(\"MFSelector_Type1.txt\", header = TRUE)\n>mf_tab_2 <- read.delim(\"MFSelector_Type2.txt\", header = TRUE)\nGenerate scatter plots with these candidate genes (Figure 4[href=https://www.wicell.org#fig4] as an example). If “parallel” package is available in your system, use “mclapply()” instead of “lapply()”.\n>get_scatter_plots(MF_type1_genes[1], data_mat, gene_labels, sample_group, mf_tab_1)\n>ggsave(\"Figure_4.tiff\", dpi = \"retina\") # Figure 4[href=https://www.wicell.org#fig4]\n>pdf(\"Scatter-Plots_Type1.pdf\")\n>lapply(MF_type1_genes, get_scatter_plots, data_mat, gene_labels, sample_group, mf_tab_1)\n>dev.off()\n>pdf(\"Scatter-Plots_Type2.pdf\")\n>lapply(MF_type2_genes, get_scatter_plots, data_mat, gene_labels, sample_group, mf_tab_2)\n>dev.off()\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1929-Fig3.jpg\nFigure 3. A heatmap based on the gene expression profile of candidate descending monotonic key genes\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1929-Fig4.jpg\nFigure 4. A scatter plot of a selected descending monotonic key gene. DE and SVDE are the discriminating error and the sample variance for the discriminating error respectively. These concepts were proposed and used by the authors of MFSelector. The statistical significance was assessed with a permutation process and the defaulted outputs such as p- and q-values were reported. Visit MFSelector official website for more details.\nPrepare the input data for TO-GCN\nTiming: 5 s\nPrepare the input files for TO-GCN.\nCompute the mean CPM values for each group.\n>sample_group_fac <- as.factor(sample_group)\n>get_group_mean <- function(x, sample_group_fac){\n  tapply(x, sample_group_fac, mean)\n}\n>group_mean_cpm <- apply(data_mat, 1, get_group_mean, sample_group_fac) |> t()\nDefine a function to set negative values as zero.\n>neg_to_zero <- function(x){ (abs(x)+x)/2 }\nFilter out lowly expressed genes (CPM <= 1).\n>check_mat <- neg_to_zero(group_mean_cpm - 1)\n>mode(check_mat) <- \"logical\"\n>check_ans <- apply(check_mat, 1, any)",
    ">group_mean_cpm_subset <- group_mean_cpm[check_ans, ]\nImport Ensembl gene biotype annotation. See problem 4[href=https://www.wicell.org#sec5.7] for details.\n>gene_biotype <- read.delim(\"gene_biotype.txt\", header = T)\nCheck if there are gene identifiers without Ensembl gene biotype annotations.\n>bii <- match(rownames(group_mean_cpm_subset), gene_biotype$ensembl_gene_id, nomatch = 0)\n>nii <- which(bii!=0)\nSelect only protein coding genes.\n>feature_type <- gene_biotype[bii[nii], 2]\n>pii <- which(feature_type == \"protein_coding\")\n>group_mean_cpm_pro <- group_mean_cpm_subset[nii[pii], ]\nDownload and import full list of human transcript factors from AnimalTFDB3.0.\n>download.file(\"http://bioinfo.life.hust.edu.cn/static/AnimalTFDB3/download/Homo_sapiens_TF[href=http://bioinfo.life.hust.edu.cn/static/AnimalTFDB3/download/Homo_sapiens_TF]\", \"Homo_sapiens_TF.txt\")\n>human_tf <- read.delim(\"Homo_sapiens_TF.txt\", header = T)\nIdentify the indices of genes annotated as transcription factors.\n>tii <- match(rownames(group_mean_cpm_pro), human_tf$Ensembl, nomatch = 0)\n>tf_vec <- as.logical(tii)\nSplit the mean TPM table into two tables for transcription factor coding genes and non-transcription factor coding genes respectively.\n>tf_group_mean_cpm <- group_mean_cpm_pro[tf_vec, ]\n>non_tf_group_mean_cpm <- group_mean_cpm_pro[!tf_vec, ]\nGenerate the input files for TO-GCN.\n>write.table(tf_group_mean_cpm, \"TF_gene_matrix.tsv\", row.names = T, col.names = F, sep = \"\\t\", quote = F)\n>write.table(non_tf_group_mean_cpm, \"Non-TF_gene_matrix.tsv\", row.names = T, col.names = F, sep = \"\\t\", quote = F)\nNote: Here, we identify protein coding genes based on Ensembl annotations. An example of how to retrieve this annotation with biomaRt is all provided. See troubleshooting[href=https://www.wicell.org#troubleshooting]: problem 4[href=https://www.wicell.org#sec5.7].\nRun the TO-GCN analysis\nTiming: 8 min",
    "Unlike the previous R scripts steps, the TO-GCN analysis is composed of three major parts (by three tools): (1) estimates the cutoff value (by ‘Cutoff’), (2) constructs the time-ordered gene co-expression network (by “TO-GCN”), and (3) generates a list of co-expressed gene for each level in the TO-GCN (by ‘GeneLevel’). You can directly run the precompiled executable files or create the executable files by C++ compiler for your operating systems. In the first part, the ‘Cutoff’ tool will give you a range of cutoff suggestions for the following analysis by checking all Pearson’s correlation coefficient (PCC) values of expression profiles between all pairs of TF genes. In the second part, the ‘TO-GCN’ tool will construct a gene co-expression network (GCN) with multiple levels that correspond to the up-regulation time order of the TF genes. To obtain a reasonable and meaningful TO-GCN, you need to choose some (at least one) of the TF genes that may be up-regulated earliest as the initial seed. The candidates for the initial seed can be found in the list of descending monotonic key genes (MF_type1_genes) generated by the MFSelector. The output of ‘TO-GCN’ can be visualized by the Cytoscape (https://cytoscape.org[href=https://cytoscape.org]). In the last part, the ‘GeneLevel’ tool will give you a list of genes that correspond to each time-ordered level. You can perform the GO (Gene Ontology) term or KEGG pathway enrichment test to obtain dynamic biological processes over the time points.\nEstimate the cutoff value of Pearson correlation coefficient for constructing a gene co-expression network. The input file contains a matrix of TF gene IDs and their expression level (can be TPM, FPKM, or CPM, etc.) at each time point.\nGo to the downloaded TO-GCN folder (using Windows as an example).\n$ cd TO-GCN_STAR-Protocol-main\\precompiled_files\\Windows",
    "Prepare input files (either from the output of step 13 or the example_data folder in package).\n$ copy ..\\..\\example_data\\TF_gene_matrix.tsv .\n$ copy ..\\..\\example_data\\Non-TF_gene_matrix.tsv .\nGet the range of cutoff values for reference with TF gene matrix.\n$ Cutoff.exe 5 TF_gene_matrix.tsv\nNo. of TFs: 1122\nNo. of time points: 5\nCutoff value for your reference: 0.86 ∼ 0.90\nConstruct a time-ordered gene co-expression network (TO-GCN) of TF genes. Two input files are required in this step. The first input file contains the TF gene matrix used in the step 14, while the second input file contains a list of TF gene IDs for initiating the BFS (Breadth-First Search) algorithm to determine the time order for TF genes in the network.\nCreate a text file of the initial TF gene (use ENSG00000175592 as an example).\n$ echo ENSG00000175592 > initial_seed.txt\nConstruct the network with two input files and the PCC cutoff value.\n$ TO-GCN.exe 5 TF_gene_matrix.tsv initial_seed.txt 0.9\nNo. of TFs: 1122\nNo. of time points: 5\nNo. of initial TF seeds: 1\nCutoff: 0.90\nAssigning levels for nodes in GCN by Breath-First-Search (BFS) method…\nDone!\nOptional: Use Cytoscape to visualize the network with two output files, Node_relation.csv and Node_level.tsv, for the input of edges and nodes respectively.\nGenerate sets of gene lists for each time-ordered level. This step requires three input files, a TF gene matrix, a non-TF gene matrix, and one of the output files (Node_level.tsv) from step 15.\n$ GeneLevel 5 TF_gene_matrix.tsv Non-TF_gene_matrix.tsv Node_level.tsv 0.9\nNo. of TFs: 1122\nNo. of non-TF genes: 11118\nNo. of time points: 5\nCutoff: 0.90\nDone!\nOptional: Conduct the functional enrichment test with the list of genes in output files. These genes were output in a list (Gene_list_in_each_level.csv) and a matrix (Gene_level_matrix.csv).",
    "Note: Although precompiled executable files were provided for Linux, MacOS, and Windows, you can still use any C++ compiler to generate the executable files with files in the “source_code” folder, problem 5[href=https://www.wicell.org#sec5.9].\nThe suggested cutoff value in step 14 is from the top 5% value (p-value < 0.05) in all PCC values of the expression profiles between all pairs of TF genes. It is worth noting that a higher cutoff value will generate more levels in a TO-GCN which means higher resolution of time order level, and vice-versa. However, a very high cutoff value will filter out too many likely co-expression relationships between TF genes and will obtain very few numbers of TF genes for analysis. Therefore, we provide a range of cutoff suggestions to build the TO-GCN."
  ],
  "subjectAreas": [
    "Rnaseq",
    "Genomics",
    "Sequence Analysis",
    "Bioinformatics",
    "Stem Cells",
    "Cell Differentiation"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}