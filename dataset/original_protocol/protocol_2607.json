{
  "id": 2753,
  "origin_website": "Cell",
  "title": "Predicting nucleosome positioning using statistical equilibrium models in budding yeast",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nHere we describe the step-by-step methods on how to compute nucleosome occupancy profiles and optimize parameters by comparison with the experimental data. First, we will describe a model that only considers TF binding. Next, we will go through for a model with TF binding and nucleosome remodeling. Note that the parameters used in these programs were optimized for yeast nucleosome and TFs, which likely need to be adjusted when applying to other species. The “timings” listed below are program running times; it will take longer to inspect results and trouble shoot.\nNDR annotation and occupancy data modification\nTiming: 20 min\nThe algorithms and codes to accurately count and locate nucleosome-depleted-regions (NDRs) are described below. We also place zero-occupancy whenever NDRs are defined.\nIdentify NDRs using the width of the occupancy below 0.732 to be > 110 bp.\nNote: In cases where the dips in nucleosome occupancy are shallow, our algorithm requires the NDR edges to be steep, i.e., the distance between sites with occupancy = 0.8 and 0.664 to be < 100 bp.\nIf the centers of two neighboring NDRs are separated by less than 125 bp, merge them into one NDR.\nModify the nucleosome occupancy data (  Y  ) by forcing the nucleosome occupancy in NDRs to zero.\nRetransform the modified occupancy to maintain the average    ⟨ Y ⟩  = 80 % .  \nNote: Due to limitation of enzyme-based experimental methods, the nucleosome occupancies in the NDR regions are low but still well-above zero. This modification significantly improved the model performance in predicting NDRs.\nThe above algorithms 1 to 4 are coded in MATLAB and consists of three steps:",
    "ndr_cut.m: Using “yy1_lee.mat” as input data, this program identifies all genomic regions with nucleosome occupancy below certain threshold. In our current approach, we used eight different thresholds:   threshold  ( i )  = 0.8 − i × SD   where   i = 1,2 , … , 8  , and   SD   is the standard-deviation calculated from genome-wide nucleosome occupancy, which yields eight output files: NDR_1.mat, NDR_2.mat, …, NDR_8.mat. Set   SD = 0.0678   (default) and run the following code with input   i = 1,2 , … , 8 .  \n> load yourpath/ndr_call/datafolder/yy1_lee.mat;\n% The loading above generates two 16×1 cell arrays, x1_lee and y1_lee, representing\n% Genomic indexes and nucleosome occupancies for the 16 chromosomes, respectively.\n> NDR_i = ndr_cut(x1_lee, y1_lee, i);\nNote: The saved outputs “NDR_1.mat, NDR_2.mat, …, NDR_8.mat” are each divided into 16 cell arrays, one for each chromosome (sample data shown in Table 4[href=https://www.wicell.org#tbl4]). Start and end index here represent the genomic locations at the upstream and downstream edges of each NDR.\ntable:files/protocols_protocol_2265_4.csv\nndr_pos_cal2.m: This program compares the boundaries in NDR_1.mat, NDR_2.mat, etc., picks the NDRs with steep edges, merges nearby NDRs, and force the nucleosome occupancies in NDRs to be zero. The final output includes the NDR positions (ndrpos_chrA.mat) and the modified nucleosome occupancy (yy3A.mat). ndrpos_chrA.mat records the start and end index of each NDR on all 16 chromosomes, and yy3A.mat has the same format as yy1_lee.mat. Copy all the NDR_i.mat into the “dataFolder” and use this folder name as input.\n> path1 = 'yourpath\\ndr_call\\dataFolder\\';\n> [occup, ndr_chr] = ndr_pos_cal2(path1);\n> save yy3A.mat occup;\n> save ndrpos_chrA.mat ndr_chr;\nNote: These codes and the input/output data can be found in the folder “ndr_call” (https://github.com/hungyok/nuctf_equi_bai/tree/main/ndr_call[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/ndr_call]).",
    "Given the modified occupancy, yy3A.mat, we transform it back to log data and recalculate c and   γ   to make sure    ⟨ Y ⟩  = 80 % .   This step is carried out using the same MATLAB code transf_yy_data.m and linear_occup.m (see step 6 in the previous section). The final normalized nucleosome occupancy is recorded in yy3A_lee.mat using c = 0.8484 and   γ   = 0.1338.\nNote: In ndr_cut.m, we chose the standard deviation of the occupancy (SD) to discretize the nucleosome occupancy. You can use other values (typically between 0.01 to 0.1) as the step size. The “ndr_pos_cal2” program defines several thresholds, e.g., thresholds on NDR length, NDR boundary slopes, neighboring NDR distance, etc. These numbers may need to be readjusted when using the program for other MNase measurements.\nModel 1: Nucleosome occupancy considering the effect of TF binding\nTiming: 1 day\nTiming: 15 min (for step 5.c.i)\nTiming: 15 min (for step 5.c.ii)\nAll the codes, input, and output files can be found in the folder “NucTF” (https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF]).\nRun the commands below to get the TF energies:\n> path1 = 'yourpath/tf_energy_all/sgd_genome/'; % input sequence folder\n> path2 = 'yourpath/tf_energy_all/Etf_allmat_chr/'; % output folder\n> [Emtf,k] = tf_binding_pot(path1,path2);\nFeed the sequence of the genome in the fasta format (e.g., sgd_chr1.fa for chromosome 1 and so on) from the folder “sgd_genome” into the program using the input parameter “path1”. The code preloads two other files, listbai_all.txt (TF name and motif length) and wmsbai_data_all.txt (PWM of all TFs) (see step 3 in the “before you begin[href=https://www.wicell.org#before-you-begin]” section for the preparation of these files). The code then calculates TF energy profiles for all the chromosomes (Etf_chr1.mat to Etf_chr16.mat) and the average TF energies (Emtfall.mat), which are stored in the folder “Etf_allmat_chr” indicated by “path2”.",
    "Note: Each energy file (e.g., Etf_chr1.mat for chromosome 1) is a matrix file where it contains the binding energy for each TF at different chromosomal locations (see the sample data in Table 5[href=https://www.wicell.org#tbl5] for four TFs on a few locations on chr I). The code, the subfolders, and the input/output files can be found in the folder “tf_energy_all” (https://github.com/hungyok/nuctf_equi_bai/tree/main/tf_energy_all[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/tf_energy_all]). Due to the large file size, we only uploaded Etf_chr1, 2, and 3.\ntable:files/protocols_protocol_2265_5.csv\nUse occupancy code “occupx.m” to compute nucleosome/TF occupancy.\nNote: Besides three specified paths, this code has four inputs: TF, Eseq, xfit, and tfx. The first two are logical parameters that take on the value of 0 or 1. TF = 1 means that TF information is considered, while Eseq = 1 means that nucleosome sequence-specific energy is considered. xfit and tfx are only useful when TFs are considered in the model (see next section). The output is an occupancy data, O.mat, comprising of 16×1 cell arrays (one for each chromosome), which includes the occupancy data for nucleosome and each TF considered in the model. The code is in the folder: https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile].\nThe following two examples compute genome-wide nucleosome occupancy with this code for two simple scenarios where TFs are not considered (TF is set to zero).\nExample 1. Calculate nucleosome occupancy where energy is uniform across the genome with no sequence preference of nucleosome binding (Eseq = 0) and TF binding (TF = 0). On MATLAB run the following commands:\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> path3 = 'yourpath\\ndr_call\\';\n> xfit = [0;0;0;0];\n> TF=0; Eseq=0;\n> tfx = [0];\n> [O] = occupx(TF,Eseq,xfit,tfx,path1,path2,path3);\n> save O_noseq.mat O;\nExample 2. Calculate nucleosome occupancy with sequence- dependent nucleosome binding energy (Eseq = 1) but no TF binding (TF = 0).",
    "… set path1-3 as the example above\n> xfit = [0;0;0;0];\n> TF=0; Eseq=1;\n> tfx = [0];\n> [O] = occupx(TF,Eseq,xfit,tfx,path1,path2,path3);\n> save O_seq.mat O;\nNote: The output of these two Examples can be found in the subfolders “example1” and “example2” respectively in the folder “occup_profile” (https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile]). Each folder contains an occupancy file and a log.txt file. The folder “example 2” also contains a plotting script “plot1.m” to generate the figure below.\nA graphical comparison of the outputs from Example 1 and Example 2 is shown in Figure 2[href=https://www.wicell.org#fig2].\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2265-Fig2.jpg\nFigure 2. Nucleosome occupancy prediction with two simple models\nNucleosome occupancy with (red) or without (black) sequence-dependent histone binding affinity. In the latter scenario, nucleosome has equal occupancy at all locations. TFs are not incorporated into these models.\nNote: All the energy terms are in the unit of kBT, and the motif and genomic lengths are in the unit of base pairs (bp).\nDetermine NDR-contributing TFs\nTiming: 15 h per TF (run multiple TFs in parallel to save time)\nThe next tasks are to determine the subset of TFs that will be incorporated into the model. This was done by optimizing the scaling parameters    c t   ,    γ t   ,    c N   , and    γ N    for each TF and evaluating the improvement in the model prediction in comparison with the no TF model. We tune these free parameters by minimizing the difference between experimentally measured (  Y  ) and predicted nucleosome occupancy   (  O N  )   by our model. In our current model, we use the root-square-mean deviation (RMSD) between   Y   and    O N    as the objective function:\n  RMSD  ( c , γ )  =      ∑  i    (   O N   ( i )  − Y  ( i )   )  2   L",
    "Where (  c , γ  ) is our parameter vectors and   L   is the total DNA length used in the computation. (  c , γ  ) are tuned by minimizing RMSD.\nThe 104 TFs that are present in the yeast nuclei in normal YPD growth condition are listed in the file “listbai_all.txt”. To optimize (  c , γ  ) for an individual TF, we use a modified Nelder-Mead simplex algorithm with Simulated Annealing (SA) to optimize these parameters (see Figure 3[href=https://www.wicell.org#fig3] for flow-chart).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2265-Fig3.jpg\nFigure 3. Optimization flowchart",
    "A flowchart showing the basic steps to use simplex_SA.m to obtain the best-fit parameters “  X  ”. The code simplex_SA.m uses occupxfunc.m (occupRfunc.m in the case of Model 2) to compute the objective function,    f i    (in our case it is the RMSD), at the    i  t h     vertex denoted by    x i   . For total n tuning parameters (e.g., n = 62 for model considering 30 TFs), the vertex   i   ranges from 1 to n+1.    x i    is a column containing n elements, e.g.,    x i    = [   c N  ;  γ N  ;  c  t 1   ;  c  t 2   ; …  c  t 30   ;  γ  t 1   ;  γ  t 2   ; …  γ  t 30    ]. The parameters are moved by two Simplex processes — reflect or shrink. Each move is accepted via Simulated Annealing (SA) criteria. We allow M steps to evolve at a given temperature Temp and after which Temp is decreased by a factor of alfa    <    1 (we used alfa   = 0.9  ).    N 0    represents the number of repeats we run the Simplex optimization. We set    N 0    = 1, if optimizing for one-TF model,    N 0    = 8 for 30-TF model, and    N 0    = 4 for the model with remodeling. The termination thresholds, Tmin and err, are both set to   ≈ 1 ×  10  − 5    .\nOpen the folder “https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/simplexM_tf1[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/simplexM_tf1]” to find:\nInput and output files that are saved in folder “input” and “output” respectively.\nA log file “log.txt” to record the optimization process.\nsimplex_SA_singleTF.m, the main simplex engine that executes the parameter optimization.\noccupxfunc.m, a sub-function that computes nucleosome occupancy and RMSD.\nsortf.m, a sub-function that sorts RMSDs.\nEdit directory to your path:\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> path3 = 'yourpath\\NucTF\\simplexM_tf1\\';",
    "Run the optimization code:\n> simplex_SA_singleTF(tfx,path1,path2,path3);\nInput parameters:\nThe “tfx” is the interest of TF index listed in “lisbai_all.txt”. It is an integer from 1 to 104.\nThe path1 loads nucleosome energy “E_Em.mat” located in the folder “nuc_energy”.\nThe path2 loads TF energy files Etf_chr1.mat to Etf_chr16.mat, and Emtfall.mat located in the folder “path2\\Etf_allmat_chr”. It also loads listbai_all.txt, a list of 104 TF names and motif sizes.\nThe path3 loads yy3A_lee.mat and rand_genome.mat (located in the “path3\\input” folder), where the former is the reference nucleosome occupancy data, and the latter has a subset of chromosomes that accounts for 70% of the genome (we tune the parameters on 70% of the genome and use the rest 30% as an independent test). The path3 also loads tf_xhIIa.mat (“path3\\input\\initialp”), a vector of eight numbers: an initial guessed values of   (  c N   ;    γ N   ;    c t   ;    γ t  )   (the first four numbers) and four other elements representing the displacements needed to build four simplex vertices around the guess vertex. For nucleosome, we set the initial   c   and   γ   to be 1.66 and 0.206 (optimized based on no TF model); without this prior knowledge, these two numbers can be set as (1;1). For any TF of interest, we set a uniform initial    c t    to be 9×10-6 and    γ t    to be 1. The values of the displacements are somewhat arbitrary as long as they represent small variations of   (  c N   ;    γ N   ;    c t   ;    γ t  )  . Output files:\nsimplex_xval.txt stores sorted (  c , γ  ).\nsimplex_fval.txt stores sorted RMSDs.\nsimplex_tval.txt stores latest values of difference between the best and worst RMSDs, temperature, and RMSD.\nsimplex_Temp.txt reports the content of “simplex_tval.txt” per simplex step.",
    "Note: The first two files simplex_xval.txt and simplex_fval.txt contain the fitting parameters and results, while the latter two record the fitting process. The file simplex_xval.txt is a 4 × 5 matrix of c and   γ  . The four rows of the matrix are    c N   ,    γ N   ,    c t    and    γ t    respectively. Five columns represent 5 vertices (Simplex requires N+1 vertices for N variables). The first column of the matrix is our optimized parameters. These files are saved in the folder “output”.\nRun “occupx.m” using the optimized parameters to get the final nucleosome occupancy (see “final occupancy profile calculation[href=https://www.wicell.org#sec3.8]” section below for more details).\nNote: The “occupx.m” program can be found in the folder “occup_profile” (https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile]). This program also calculates a few parameters that indicate the overall quality of the model, including the average nucleosome occupancy, AUC, NDR probability (   P NDR   ), and rmsd (sigma), which can be found at the bottom of the log file (see https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile/log.txt[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile/log.txt] for an example). After doing this for all 104 TFs, we rank them based on    P NDR    (higher    P NDR    indicates more contribution to NDR formation) and store the ranking in another file called “tfindx.txt” located in the folder “tf_energy_all” (https://github.com/hungyok/nuctf_equi_bai/tree/main/tf_energy_all[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/tf_energy_all]).\nParameter optimization for a model considering multiple TFs\nTiming: 4–5 days\nWe can now set up a model with multiple TFs taken into consideration. Below, we describe a model where we incorporated the top 30 TFs. Accordingly, there are in total of 62 unknown parameters (31 pairs of (  c , γ  )’s), of which 60 is for TFs and two for nucleosome. The directory structure and the optimization process are very similar to the one-TF case.\nOpen the folder “https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/simplexM_ top30[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/simplexM_%20top30]” to find:",
    "Input and output folders. The folder “output” represents a typical running folder contains intermediate outputs (unoptimized). We also put the optimized parameters into “output_ optimized”).\nA log file “log.txt” to record the optimization process.\nsimplex_SA_multiTF.m, the main simplex engine that executes the parameter optimization.\noccupxfunc.m, a sub-function that computes nucleosome occupancy and RMSD.\nsortf.m, a sub-function that sorts RMSDs.\nEdit directory paths:\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> path3 = 'yourpath\\NucTF\\simplexM_top30\\';\nRun the optimization code:\n> simplex_SA_multiTF(tfx,path1,path2,path3);\nInput parameters: The inputs are the same as in simplex_SA_singleTF, except that tfx here is a 1D array containing multiple TF indices. For example, to consider top 30 TFs that contribute to NDRs, the tfx should be the first 30 numbers listed in the “tfindx.txt” file. Path3 loads “top30_xhIIa.mat” (located in path3\\input\\initialp), which is a 1D array containing the initial guessed values of (  c , γ  )s of nucleosome and the 30 TFs. Here, the first 62 elements are the (  c , γ  )s and the second 62 are the small displacements needed to build simplex vertices. Output files:\nsimplex_xval.txt stores sorted (  c , γ  ).\nsimplex_fval.txt stores sorted RMSDs.\nsimplex_tval.txt stores latest values of difference between the best and worst RMSDs, temperature, and RMSD.\nsimplex_Temp.txt reports the content of “simplex_tval.txt” per simplex step.",
    "Note: Similar file description as in “simplexM_tf1” except that the file simplex_xval.txt is a 62 × 63 matrix of c and   γ   with the first and second rows of the matrix are    c N    and    γ N    respectively, and the rows 3   –   32 are    c t   ’s and rows 33–62 are    γ t   ’s. The first column of the matrix is our optimized parameters and will be used to determine the final genome-wide occupancy profile (see below). The program is currently written to incorporate top 30 TFs. To use for a different number of TFs, modify “tfx” and the initial parameter file “top30_xhIIa.mat” accordingly.\nNote: Number of search steps, “M”, in simplex_SA.m can be changed to adjust the optimization quality/time. Currently, at each of the five “temperature” (which controls the parameter search range), we gradually decrease the number of steps to be M=100, 83, 67, 50, and 33. Larger M may lead to better convergence but cost more computational time. With our current setting, we repeated step 12 nine times and each time starting from the last output (Figure 3[href=https://www.wicell.org#fig3]). One simplex step takes   ∼   125 s. We recommend users to run a total of at least   ∼   3000 simplex steps, which takes 4–5 days.\nFinal occupancy profile calculation\nTiming: 15 min\nThe optimized set of parameters (c and   γ  ), which is the first column of the last output file “simplex_xval.txt” obtained from steps 10–12 in “simplexM_top30”, are used to calculate the final occupancy profiles.\nOpen the folder “occup_profile” and run the code to compute the occupancy profiles (Example 3):\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> path3 = 'yourpath\\ndr_call\\';\n> load yourpath\\NucTF\\simplexM_top30\\output_optimized\\simplex_xval.txt;\n> xfit = simplex_xval (:,1); TF = 1; Eseq = 1;\n> load yourpath/NucTF/tf_energy_all/tfindx.txt;\n> tfx = tfindx(1:30);",
    "> [O] = occupx(TF, Eseq, xfit, tfx, path1, path2, path3);\n> save O_good.mat O; % save O_bad.mat O; when loading simplex_xval.txt from folder “output”\nNote: The output file “O.mat” is a 16 × 1 cell containing one column of nucleosome occupancy and 30 columns of TF occupancies (1 column for each TF). The output of Example 3 is in https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile/example3[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/occup_profile/example3]. For comparison, we show two case scenarios with optimized (good-fit) and unoptimized (bad-fit) parameters. These parameters are obtained from the folder “output[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucTF/simplexM_tf30/output]_optimized” and “output”, respectively. The occupancy data were saved in “O_good.mat” and “O_bad.mat”. The folder “example3” also has plotting script to generate a similar figure below.\nNote: Examples of bad vs good optimizations are shown in Figure 4[href=https://www.wicell.org#fig4] (top two panels).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2265-Fig4.jpg\nFigure 4. Nucleosome and TF occupancy simulation\nWe chose a 5 kb fragment in ChrI as an example. The measured nucleosome occupancy with NDR modification (black), predicted nucleosome occupancy (red), and the occupancy of one TF that is responsible for the NDR formation (blue) are shown in the plots. Top two panels show a comparison of Model 1 with bad and good parameters. Bottom panel shows the prediction from Model 2, which better reproduces the NDR size.\nModel 2: Nucleosome occupancy considering the effect of TF binding and remodelers",
    "All the codes and the input and output files can be found in the folder “NucRemod” (https://github.com/hungyok/nuctf_equi_bai/tree/main/NucRemod[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucRemod]). This version of the model considers both the effect from TF binding and nucleosome remodeling. We assume that the action of nucleosome remodeling machinery is to deform the nucleosome energy landscape near the TF-bound sites in a TF occupancy-dependent manner. In our model, remodeling effect is present only when TF occupancy is larger than a threshold, tfcut. The tfcut is currently set to 0.0022 (computed as the genome-wide average of all TF occupancies in Model 1). We assume that a remodeler modifies the energy landscape as a Gaussian deformation with height “h” and width “w” (free parameters). In the presence of multiple TFs adjacent to each other, we use the summation of individual deformation energies. Note that in this model, remodelers only affect the NDR length, but not the NDR probability. This is consistent with our recent experimental findings.12[href=https://www.wicell.org#bib12]\nParameter optimization\nTiming: 8–9 days\nWe use the optimized “c” and “  γ  ” of TFs obtained in Model 1 to optimized “h” and “w” for remodeler and “c” and “  γ  ” of nucleosome. Here we have only four variable parameters and therefore the simplex has N = 5 vertices. The following steps will calculate the optimal parameters.\nOpen the folder “nuctf_equi_bai\\NucRemod\\simplexM_remod” to find:\nAn “input” folder containing a file “pos_octf.mat” that records positions and occupancy of TFs when the TF occupancy cutoff is tfcut=0.0022. It is generated by the code “occup_tfs.m” by running the following steps:\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> tfcutx = 0.0022;\n> load yourpath/NucRemod/simplexM_remod/input/avgxval_top30.txt;\n> xfit = avgxval_top30;\n> load /NucTF/tf_energy_all/tfindx.txt;\n> tfx = tfindx(1:30);\n> [pos_octf] = occup_tfs(xfit,tfx,tfcutx,path1,path2);\n> save pos_octf.mat pos_octf;",
    "The format of pos_octf.mat is a 16 × 3 cell matrix. For each chromosome (row 1–16), the three cells represent TF binding position, TF occupancy, and identity (TF indices) respectively. This file is used by occupR.m, occupRfunc.m, and tf_cluster.m.\nTwo output folders for fitting parameters: “output” and “output_optimized”. One example of unoptimized parameters generated during the fitting process is stored in “output”. While “output_optimized” contains the best fitting parameters.\nAn output log file “log.txt” that records the optimization process.\nsimplex_SA_remod.m, the simplex engine with Simulated Annealing.\noccupRfunc.m, a sub-function that calls tf_cluster.m and occup_nucs.m to construct remodeling deformation energy, calculate nucleosome occupancy, and compute RMSD. This step is repeated nx = 10 times to allow combinatorial binding of multiple TFs (see step below). The final nucleosome occupancy represents an average between these configurations. Larger nx can be used to achieve better averaging.\ntf_cluster.m, a sub-function that gathers the binding configurations of TFs using the information provided by “pos_octf.mat”. For isolated TFs, the binding status is determined by comparing their occupancy (from Model 1) to a random number. When multiple TFs bind adjacent to each other, we allow maximally two TFs to overlap, and their individual binding status are determined by the same random number generator. The output of this function was used to generate an altered energy landscape in occupRfunc.m.\noccup_nucs.m, a sub-function that computes nucleosome occupancy (one chromosome at a time) using the altered energy landscape.\nsortf.m, a sub-function that sorts a set of RMSDs.\nEdit directory paths:\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> path3 = 'yourpath\\NucTF\\simplexM_top30\\';\n> path4 = 'yourpath\\NucRemod\\simplexM_remod\\';\nRun the optimization code:\n> simplex_SA_remod(tfx, path1, path2, path3, path4);",
    "The input / output files and the tfx array are same as in “simplexM_top30” in Model 1, except this time the file simplex_xval.txt is a 4 × 5 matrix. The first column of the matrix is our optimized parameters and is used in determining the genome-wide occupancy profile in step 18 below.\nThe current setting of the number of Simplex searches, M, is (12,12,10,10,6) at five temperatures. We also repeat the optimization step (step 16 above) four times and each time starting from the last output (Figure 3[href=https://www.wicell.org#fig3]). One simplex step takes   ∼   1 h. We recommend users to run a total of at least   ∼   200 simplex steps, which takes 8–9 days.\nFinal occupancy profile calculation\nTiming: 5 h\nThe optimized set of parameters (   c N   ,    γ N   , h, and w) obtained from steps 14–17 above and the TF parameters (   c t   ,    γ t   ) obtained from Model 1 are used to calculate the final occupancy profiles using the code occupR.m (https://github.com/hungyok/nuctf_equi_bai/tree/main/NucRemod/occup_profile[href=https://github.com/hungyok/nuctf_equi_bai/tree/main/NucRemod/occup_profile]). The occupancy calculation depends on “nx“ to account for the TF-dependent remodeling (see step 14(e)). Here, in occupR.m, we set nx to be 100.\nOpen the folder “occup_profile” and run the code to compute the occupancy profiles:\n> path1 = 'yourpath\\nuc_energy\\';\n> path2 = 'yourpath\\tf_energy_all\\';\n> path3 = 'yourpath\\NucRemod\\simplexM_remod\\';\n> path4 = 'yourpath\\ndr_call\\';\n> load /NucRemod/simplexM_remod/output_optimized/simplex_xval.txt;\n> remod = simplex_xval(:,1); % load the best-fit remodeling parameters\n> load /NucTF/simplexM_top30/output_optimized/simplex_xval.txt;\n> load /NucTF/tf_energy_all/tfindx.txt;\n> tfx = tfindx(1:30);\n> xfit = simplex_xval(:,1); % load the best-fit TF parameters\n> [O] = occupR(remod, xfit, tfx, path1, path2, path3, path4);",
    "Note: The output file “O.mat” is a 16 × 1 cell. Here we report only nucleosome occupancy per cell and can be found in the same folder “occup_profile”. A comparison between TF only model and TF + Remod model is shown in Figure 4[href=https://www.wicell.org#fig4] (bottom panel).\nModel evaluation\nTiming: 1 day\nWe use four criteria to evaluate the model against experimental data: Avg_occ, RMSD,    P NDR   , and AUC. They are defined as follows:\nAvg_occ   =  ⟨ O ⟩    is the average nucleosome occupancy. In budding yeast, we expect this number to be close to 0.8.\nRMSD is the root-square-mean deviation of nucleosome occupancy between the predicted and measured genome-wide nucleosome occupancy.\n   P NDR    measures the fraction of experimentally determined NDRs that are predicted by the model. We identify NDRs from the predicted nucleosome occupancy the same way as for the experimental data. The predicted NDRs are consistent with experimental data when the predicted NDR lies within 40 bp of the center of a true NDR. For example,    P NDR  = 0.56   means that, out of the 4713 NDRs detected from the nucleosome occupancy data, 2640 can be recovered in our model.\nFor AUC (area under the ROC curve), we calculate true positive (TP), true negative (TN), false positive (FP), and false negative (FN) for our NDR prediction when we varied the NDR occupancy cutoff from 0.04 to 0.96 by an increment of 0.01. We plot the true positive rate, TPR=TP/(TP+FN), against the false positive rate FPR=FP/(FP+TN), and AUC is the area underneath this curve. An AUC=1 represents an ideal model, and AUC=0.5 is the baseline.",
    "Note: The parameters above are calculated by codes occupx.m and occupR.m, for models incorporating TFs and TFs + remodelers, respectively, and they are recorded in the logfile. For our current models, Table 6[href=https://www.wicell.org#tbl6] shows some typical values for these parameters.\ntable:files/protocols_protocol_2265_6.csv"
  ],
  "subjectAreas": [
    "Genomics",
    "Bioinformatics",
    "Computer Sciences",
    "Molecular Biology",
    "Model Organisms",
    "Biophysics"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}