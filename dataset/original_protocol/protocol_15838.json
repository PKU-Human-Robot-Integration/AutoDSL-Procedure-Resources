{
  "id": 19664,
  "origin_website": "Wiley",
  "title": "Computational Pipeline for Analysis of Biomedical Networks with BioNAR",
  "procedures": [
    "This protocol describes how a network is initiated in the BioNAR package and how annotations are added for further analysis. BioNAR implements networks as R data frames, in which each row corresponds to a vertex interactor pair and each vertex has a unique identifier (vertex_ID). Therefore, a network can be directly uploaded as a data frame in this format. Alternatively, a network can be imported from most standard graph file formats, including .gml and other formats supported by the igraph R package. BioNAR also allows network import for synaptic protein sets/synaptic compartments/brain regions directly from the synaptome.db package (Sorokina et al., 2022[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0031]); this is described in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0002]. For constructing the protein interaction networks described here, we selected the NCBI Gene Entrez ID to use as a unique “vertex_ID” for each node/protein.\nMany graph-related algorithms behave poorly when applied to graphs containing disconnected components. Consequently, most biological networks—including PPI networks—are constructed to retain only the network's largest connected component of vertices. We follow this practice for downstream analysis as well, but BioNAR also stores the disconnected components, as they may be of importance to the user at a later stage.\nVertices are typically annotated with categorical or continuous metadata. Annotations are usually handled in a three-column data frame format, where the first column contains the annotation term ID, the second column the annotation term name, and the third column the associated vertex_ID. All annotation terms for the same vertex_ID are collected and converted into semicolon-separated lists to store all annotations of the vertex held as a string in the vertex annotation. For example, if a protein is annotated with two different molecular functions A and B, in vertex annotation it will be stored as “A; B.”",
    "In proteomic networks, annotations typically include Gene Ontology (GO) annotations and gene-disease association values (GDAs), and the direct import of both of these types of annotations from public databases is implemented in BioNAR. However, the package supports any custom annotation, including gene-expression values, pathway membership data, and so on. As an example of adding custom data, this protocol describes the addition of new binary annotation for the SynGo ontology (Koopmans et al., 2019[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0042]). BioNAR is also designed to allow the user to assign the results of any vertex calculation as a new vertex attribute. The ability to retain such calculated supports reproducibility, as many algorithms used in network analysis have a stochastic component, so that multiple invocations of the same analysis can create a distribution of results, which can now all be stored for later analysis.\nNecessary Resources\nHardware\nA modern compute environment capable of running R version >4.3.0 and RStudio version >2022.12.0\nSoftware\nR version >4.3.0 and RStudio version >2022.12.0\nFiles\nSample network files (for the examples described) PSD_PPI.txt and/or PSDnetwork.gml (see Supporting Information), or your own data files in either format\nAdditional annotation file provided for illustrative purposes (see Supporting Information): SynGO.txt\n1. Install RStudio and BioNAR package as described in Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0002].\nOpen RStudio and launch the library BioNAR, as well as a few more frequently used libraries, assuming they have not been installed by default. Navigate (using the command setwd) to the directory in which you have stored the network and annotation files (in our case, it is called “Sample network”).\n         \nlibrary(BioNAR)\nlibrary(synaptome.db)\nlibrary(ggplot2)library(pander)\nlibrary(ggrepel)\nlibrary(randomcoloR)\nsetwd(“∼/Documents/Sample network”)\n2. Load your network. This can be done in any of three ways; examples of each format are provided below, using the same test network below.\n         \na. Import a network from a text table:",
    "t <- read.table(“PSD_PPI.txt”, sep = “\\t”, header = T, stringsAsFactors = F)\nhead(t)\ngg <- buildNetwork(t)\nsummary(gg)\nb. Import a network from a graph/.gml file:\ng <- igraph::read.graph(“PSDnetwork.gml”,format=“gml”) #graph from gml\nsummary(g)\nThe commands summary(gg) and summary(g) will show the same graph composition from the text import (step 2a) or .gml import (step 2b), respectively: 2297 vertices and 9406 edges, with the Human Entrez ID used as the node name for all three graphs.\nc. Import network from synaptome.db (see Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0002]).\n3. Annotate the network with GeneNames. In this step, the raw graph from step 2 are annotated by importing annotation data from the human genome-wide gene annotation database org.Hs.eg.db. For each node in the graph, the Entrez Gene Name is assigned using the annotateGeneNames function.\n         \ng<-annotateGeneNames(g)\nSometimes gene IDs become obsolete and gene names are not assigned. We can check for this:\nany(is.na(V(g)$GeneName))\nIf the result is TRUE, we can find such genes and assign its GeneName manually. Some functions further down require unique GeneNames to function correctly.\nidx<-which(is.na(V(g)$GeneName))\nidx\nV(g)$GeneName[idx]<-‘AKAP2’\n4. Annotate the network with metadata. In this step, the raw graph from step 2 is annotated by importing annotation data from relevant external files and/or databases. For each node in the graph, the following annotation is added: associated human diseases are extracted directly from the Human Disease Ontology (HDO) using the annotateTopOntoOVG function and Gene Ontology terms (BP, MF, and CC) are extracted using the annotateGOont function.\n         \nafile<-system.file(“extdata”, “flatfile_human_gene2HDO.csv”, package = “BioNAR”)\ndis <- read.table(afile,sep=“\\t”,skip=1,header=FALSE,strip.white=TRUE,quote=“”)\ng <- annotateTopOntoOVG(g, dis)\ng <- annotateGOont(g)\nsummary(g)",
    "After calling summary(g), you will see that nodes now have attributes: id (v/n), name (v/c), GeneName (v/c), TopOnto_OVG (v/c), TopOnto_OVG_HDO_ID (v/c), GO_MF_ID (v/c), GO_MF (v/c), GO_BP_ID (v/c), GO_BP (v/c), GO_CC_ID (v/c), and GO_CC (v/c), where id corresponds to internal graph ID, name – Human Entrez ID, TopOnto_OVG is the disease name according to the Human Disease Ontology (HDO), TopOnto_OVG_HDO_ID is the disease ID according to the HDO, GO_MF_ID is the Gene Ontology Molecular Function ID, GO_MF is the Gene Ontology Molecular Function name, GO_BP_ID is the Gene Ontology Biological Process ID, GO_BP is the Gene Ontology Biological Process name, GO_CC_ID is the Gene Ontology Cell Compartment ID, and GO_CC is the Gene Ontology Cell Compartment name. (v/c) and (v/n) indicate that the corresponding attributes are character and numerical values associated with vertices.\nTo annotate a graph with your own metadata, you need to provide it in the form of a data frame (see example “SynGO.txt”), where the first column should contain vertex IDs matching name IDs in the network (Human Entrez ID) and the second column the respective attribute values. When using the command annotateVertex(g), you will need to provide the name of your new attribute as the parameter name (“syngo” in our case) and the name of your annotation table as the parameter values (“sg”).\n         \nsg <- read.table(“SynGO.txt”, sep = “\\t”, header = T, stringsAsFactors = F)\ng <- annotateVertex(g, name = “syngo”, values = sg, idatt = “name”)\nIf you call summary(g), you will now see an additional new attribute “syngo” in addition to those listed above.",
    "Support Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0002] describes how install BioNAR from Bioconductor.\nNecessary Resources\nHardware\nA modern compute environment capable of running R version >4.3.0 and RStudio version >2022.12.0.\nSoftware\nR version >4.3.0 and RStudio version >2022.12.0\nFiles\nNone\n1. Download R from https://www.r-project.org/[href=https://www.r-project.org/], open the installer, and follow the installation prompts.\n2. Download RStudio Desktop from https://www.rstudio.com[href=https://www.rstudio.com], open the installer, and follow the installation prompts.\n3. Open RStudio and install the Bioconductor package BioNAR using the following commands.\n         \nif (!require(“BiocManager”, quietly = TRUE))\ninstall.packages(“BiocManager”)\nBiocManager::install(version = “3.17”)\nBiocManager::install(“BioNAR”)\nlibrary(BioNAR)\nThis will check for and then install the Bioconductor package manager “BiocManager” if it is not already installed. It will then install BioNAR from Bioconductor.\nDuring the installation process, BiocManager may determine that some packages are obsolete; in this case, it will ask:\nOld packages: ‘x.y.z’, …\nUpdate all/some/none? [a/s/n]:\nIf this is the first package you are installing, we suggest typing “n”; if you've already have a working R environment, it is wise to type “a”.\n4. Install additional utility packages:\n         \nBiocManager::install(c(“pander”, ‘randomcoloR’, ‘ plotly’ ))\n5. Check that the library is installed correctly by using the command:\n         \nlibrary(BioNAR)",
    "BioNAR includes a direct plug-in to the Synaptic Proteome database, which contains 64 independent proteomic studies of mammalian synapses, recently curated into a single dataset describing a landscape of ∼8000 proteins (Sorokina et al., 2021[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0044]). BioNAR does this through the Bioconductor package synaptome.db, which allows users to obtain the corresponding gene information, such as subcellular localization, molecular interactions, brain region, gene ontology, and disease association, and to construct customized protein-protein interaction network models for gene sets and entire subcellular compartments (Sorokina et al., 2022[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0031]).\nSupport Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0003] describes how to extract a custom PPI network for postsynaptic compartment based on a gene set comprising proteins that were found in three or more independent postsynaptic studies.\nNecessary Resources\nHardware\nA modern compute environment capable of running R version >4.3.0 and RStudio version >2022.12.0.\nSoftware\nR version >4.3.0 and RStudio version >2022.12.0\nFiles\nnone\n1. Open RStudio and install the Bioconductor package synaptome.db using following commands.\n         \nif (!require(“BiocManager”, quietly = TRUE))\n   install.packages(“BiocManager”)\nBiocManager::install(version = “3.17”)\nBiocManager::install(“synaptome.db”)\nlibrary(synaptome.db)\nThis will check for and then install the Bioconductor package manager “BiocManager” if it is not already installed. It will then install synaptome.db from Bioconductor. During the installation process, BiocManager may determine that some packages are not the most recent version; in that case, it will ask:\nOld packages: ‘x.y.z’, …\nUpdate all/some/none? [a/s/n]:\nIf it is the first package you are installing, we suggest typing “n”; if you already have a working R environment, it seems wise to type “a”.\n2. Extract the compartment ID for postsynaptic compartment. To do this, navigate using setwd to the directory where you will store all the results; in our case this is “Sample network”. The command match will return the database ID for required compartment, which is “1” in our case (for the postsynaptic compartment).\n         \nsetwd(“∼/Documents/Sample network/”)",
    "cid<-match(“Postsynaptic”, getCompartments()$Name)\ncid\n3. Get all the gene IDs for the specified compartment.\n         \nt<-getAllGenes4Compartment(cid)\ndim(t)\n4. Select a subset of genes that were found in three or more studies.\nIn our example, the gene list for the postsynaptic compartment is large (5568 genes), and we want to reduce it to the highest-confidence set of genes, found in at least three (arbitrary decision) different studies, which results in 2643 genes. To get this, we specify “3” for the findGeneByCompartmentPaperCnt command.\n         \ngp <- findGeneByCompartmentPaperCnt(3)\npostgp <- gp[gp$Localisation == “Postsynaptic”,]\ndim(postgp)\nhead(postgp)\n5. Build the PPI for the selected set of genes.\n         \nlibrary(BioNAR)\nggb<-buildFromSynaptomeGeneTable(postgp, type = “limited”)\nwrite_graph(ggb, file = “PSDnetwork.gml”, format = “gml”)\nProtein-protein interactions will be returned for a “limited” type of the network, which includes only genes presented in the list. The BioNAR command buildFromSynaptomeGeneTable creates a “limited”-type network and returns its largest connected component.\nAlternatively, it is possible to create a network of “induced” type, in which case an expanded network including all possible interactors of the listed genes will be obtained from the database. This can be created with the synaptome.db command getIGraphFromPPI; this functionality is outside the scope of this paper (Sorokina et al., 2022[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0031]). The resulting graph contains the one connected component consisting of 2297 vertices and 9406 edges, which we saved in a gml format to use for further analysis.",
    "To assess any network model for biological plausibility, we often want to test a network's degree distribution for evidence of scale-free structure and compare it against an equivalent randomized network model. The assumption here is that a network based on noisy data will have more random architecture, whereas biological networks typically tend towards a more scale-free structure. For this we use the R PoweRlaw package (version 0.50.0; Gillespie, 2015[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0010]), which deploys a goodness-of-fit approach to estimate the lower bound and the scaling parameter of the discrete power-law distribution for the optimal description of the graph degree distribution.\nAlthough degree is the most commonly used vertex metric, there are other centrality metrics that can be estimated from the graph structure. BioNAR directly supports the calculation of the following network vertex centrality measures. Some are implemented via igraph (Gabor & Tamas, 2006[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0009]): degree (DEG), betweenness (BET), clustering coefficient (CC), and page rank (PR; see igraph manual for details). Other measures appear only in BioNAR: semilocal centrality (SL), mean shortest path (mnSP), and standard deviation of the shortest path (sdSP).\nCalculated vertex centrality values can be added as vertex attributes (calcCentrality) or returned as an R matrix (getCentralityMatrix), depending on user preference. Any other numerical characteristics, calculated for vertices and represented in a matrix form, can also be stored as a vertex attribute (applyMatrixToGraph).\nTo enable comparison of an observed network's vertex centrality values to those of an equivalently sized randomized graph, we enabled three randomization models: the G(n,p) Erdös-Rényi model (Erdös & Rényi, 1959[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0007]; “gnp,” illustrated in the example below), the Barabasi-Albert preferential attachment model (Barabási & Albert, 1999[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0002]; “pa”), and the derivation of a new randomized graph from a given graph by iteratively and randomly adding/removing (“cgnp”) or rewiring edges (“rw”).",
    "For proteomic networks with matching multi-condition gene-expression data, scale-free structure has also been demonstrated by using the expression data to perform a perturbation analysis on the network to measure network entropy (Teschendorff et al., 2015[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0033]). Originally, this kind of analysis was designed for comparing a control with a perturbed network (e.g., wild-type versus mutant, untreated versus treated), where vertices with low entropy rate appear to be the most important players in disease propagation.\nHowever, the assessment of scale-free structure does not actually require gene-expression data, as it based solely on the network topology. In BioNAR, following the procedure described by Teschendorff et al. (2015[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0033]), all vertexes are artificially assigned a uniform weight and then sequentially perturbed, with the global entropy rate (SR) after each protein's perturbation being calculated and plotted against the log of the protein's degree (see Theoretical Appendix for more detail). In case of scale-free or approximate scale-free topologies, we see a clear bimodal response between over-weighted vertices and their degree and an opposing biphasic response in under-weighted vertices and their degrees.\nBasic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0004] starts with estimating and fitting the observed graph degree distribution to a power law and comparing this against a random network. At the next step, we estimate the graph entropy, again comparing it to the random graph. Finally, we estimate the range of centrality metrics for our graph and a randomly generated graph; in our example, we use the Erdös-Rényi model.\n1. Check the network degree distribution.\n         \npFit <- fitDegree(as.vector(igraph::degree(graph=g)), Nsim=1000,\n    plot=TRUE,WIDTH=2480, HEIGHT=2480)\npwr <- slot(pFit,‘alpha’)",
    "This command will take the graph created in Basic Protocol 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0001], fit it to a power-law distribution, and return a figure consisting of a log-log plot of the cumulative distribution function (CDF) of postsynaptic PPI network degree distribution (Fig. 2A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0002]). During fitting, code performs a bootstrapping hypothesis test to determine whether a power-law distribution is plausible. The number of bootstrapping rounds is defined by the parameter Nsim, which is set to 100 by default. Setting the Nsim parameter to large values makes calculation slower: for example, with Nsim = 1000 it takes couple of minutes to get a fit. By using a slot function, we extract scaling coefficient α to compare with the random graph results.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/51bf5b3e-bfbe-4ee4-871b-3cbb3b1fa825/cpz1940-fig-0002-m.jpg</p>\nFigure 2\n(A) The results of a fit of network degree distribution (P(k)) versus its degree (k) for the postsynaptic network. The red line shows the best-fit power-law distribution with estimates of the scaling parameter α (2.63) and kmin (13), with a goodness of fit of 0.32 after 1000 iterations of the bootstrapping. (B) Distribution of alpha values for 5000 random G(n,p) Erdös-Rényi graphs, with actual α value (2.63) shown as a vertical line near the left.\n2. Compare network degree distribution with a set of random graphs.\nThe following commands will generate a sample of 5000 random G(n,p) Erdös-Rényi graphs and estimate α coefficients of their best fits to the power-law distribution. To save compute time, we reduce the number of bootstrapping tests to 10 in this example; however, it still takes about hour and a half to complete the task, using 500 samples instead of 5000 to save time. The histogram of obtained values is plotted in Figure 2B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0002], where the vertical line on the left indicates the value (2.63) for the actual graph.\n         \nlrgnp<-list()\nalphaGNP<-c()\nfor(i in 1:5000){\nrgnp<-BioNAR:::getGNP(g)",
    "pFit <- fitDegree( as.vector(igraph::degree(graph=rgnp)),\nNsim=10, plot=FALSE,threads=5\np <- slot(pFit,“alpha”)\nlrgnp[[i]]<-rgnp\nalphaGNP[i]<-p\n}\nqplot(alphaGNP)+geom_vline(xintercept = pwr)\n3. Calculate graph entropy.\nAs we do not have actual expression data for our graph, we can use simulated data (see the Theoretical Appendix for more detail). The command getEntropyRate estimates the global entropy rate for the whole network, whereas getEntropy estimates entropy value for each network vertex. The command plotEntropy visualizes the results as a plot (Fig. 3A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0003]).\n         \nent <- getEntropyRate(g)\nent\nSRprime <- getEntropy(g, maxSr = ent$maxSr)\nhead(SRprime)\nplotEntropy(SRprime, subTIT = “Entropy”, SRo = ent$SRo, maxSr = ent$maxSr)\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/9635a83a-80a1-4dc8-afe6-74831927dbc0/cpz1940-fig-0003-m.jpg</p>\nFigure 3\nGlobal entropy (SR). (A) SR for the postsynaptic network under study plotted against the log of the protein's degree. The horizontal dashed line corresponds to the entropy rate of the unperturbed graph (SR0 = 0.698). We can see that entropy for both up- and down-perturbed low-degree vertices stays close to that value, whereas the hubs (high-degree vertices) deviate from it significantly, which makes for a bimodal response between gene overexpression and degree and opposing biphasic response relative to over-/underexpression between global entropy rate and degree, observed only in networks with scale-free or approximate scale-free topology. (B) SR values for a randomized G(n,p) Erdős-Rényi network, perturbed in a similar way.\n4. Calculate the graph centrality measures.\n         \ng <- calcCentrality(g)\nThe command calcCentrality assigns centrality measures the following node attributes: DEG, degree; BET, betweenness; CC, clustering coefficient; SL, semilocal centrality; mnSP, mean shortest path; PR, page rank; and sdSP, standard deviation of the shortest path. Rather than saving these centrality values on the graph, e.g., to provide different names for the vertex centrality attributes, they are obtained in matrix form:\n         \nmc <- getCentralityMatrix(g)",
    "The matrix will contain eight columns for each of the measures above, with the rows corresponding to each node's database ID (2297 nodes in total, synaptome.db version 0.99.12).\n5. Calculate the graph centrality measures for a randomized graph.\n         \nggrm <- getRandomGraphCentrality(g, type = c(“cgnp”))\nWe need to select the type of randomization, “cgnp” in our case, that corresponds to a sampling algorithm, which will randomly perturb the graph adjacency matrix and shuffle its vertices in such a way that the correlation between new and old adjacency matrix is 75%.",
    "This protocol splits the network into communities using a non-exhaustive set of commonly used clustering algorithms for molecular networks. These include modularity-maximization-based algorithms, such as the popular agglomerative “fast-greedy community” algorithm (fc; Clauset et al., 2004[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0005]), the process-driven agglomerative random walk algorithm “Walktrap” (wt; Pons & Latapy, 2006[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0025]), the coupled Potts/simulated annealing algorithm “SpinGlass” (sg; Reichardt & Bornholdt, 2006[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0026]; Traag & Bruggeman, 2009[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0034]), the divisive spectral-based “leading-eigenvector” (lec; Newman, 2006[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0023]) and fine-tuning (Spectral; McLean et al., 2016[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0019]) algorithms, and the hierarchical agglomerative “Louvain” algorithm (louvain; Blondel et al., 2008[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0004]). We also included a non-modularity information-theory-based algorithm, “InfoMAP” (infomap; Rosvall & Bergstrom, 2008[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0028]; Rosvall et al., 2009[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0027]). All algorithm implementations, apart from Spectral, are imported from R's igraph package (Gabor & Tamas, 2006[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0009]). The Spectral algorithm (McLean et al., 2016[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0019]) was written in C++ and wrapped in R within a satellite CRAN package, rSpectral (https://cran.r-project.org/web/packages/rSpectral/index.html[href=https://cran.r-project.org/web/packages/rSpectral/index.html]), linked to BioNAR. Default parameters used in the fc, lec, sg, wt, and louvain algorithms were chosen to maximize the measure modularity (Newman & Girvan, 2004[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0044]); infomap seeks the optimal community structure in the data by maximizing the objective function called the minimum description length (Rissanen, 1978[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0046]; Grünwald et al., 2005[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0047]).\nIn this protocol, first, community structures are obtained for the network used in previous protocol. The user can select some or all of the available clustering algorithms to run simultaneously. This community structure(s) can then be visualized. The process can also be iterated by re-clustering the largest communities after each cycle (the threshold for communities to be re-clustered can be defined). Finally, we extract a summary table that compares across all the clustering algorithms used in the analysis.\n1. Use the network g obtained with previous protocols.\n2. Cluster the network.",
    "We provide two functions, calcClustering and calcAllClustering, that use calcMembership to calculate community memberships and store them within the graph vertices attributes named after the algorithm. The difference between them is that calcAllClustering allows the user to calculate memberships for all clustering algorithms simultaneously (this can be slow, especially on larger graphs, e.g., up to 30 min for our full example network), and store them as graph vertices attributes, whereas calcClustering allows users to select a specific algorithm.\n         \ng <- calcAllClustering(g)\nsummary(g)\nThe resulting graph summary in the example will contain the graph memberships for all nine clustering algorithms: “fast-greedy community” (fc), “leading-eigenvector” (lec), “Walktrap” (wt), “SpinGlass” (sg), “Spectral” (spectral), “Louvain” (louvain), and “InfoMAP” (infomap). The SpinGlass algorithm is implemented as three instances (sgG1, sgG2, and sgG5), each based on a selected gamma value (1, 2, and 5, respectively) specifying the desired cluster size.\nThe user also has the option to select one or more specific clustering algorithm to run over their network, because running all clustering algorithms over the large network might be time consuming. For instance, to cluster the network g using only the Louvain algorithm, the command would look like:\n         \ngl <- calcClustering(g, alg = “louvain”)\nsummary(gl)\n3. Compare the output of clustering algorithms.\nFor comparing output across different clustering algorithms on a network, a summary matrix is created, consisting of: the maximum modularity obtained (mod), the number of detected communities (C), the number of singlet communities (Cn1), the number of communities with size ≥100 (Cn100), the fraction of edges lying between communities (mu), the sizes of the smallest community (Min. C) and the largest community (Max. C), and the average (Mean C), median (Median C), first quartile (1st Qu. C), and third quartile (3rd Qu. C) of community size (Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-tbl-0001]).\n         \nm <- clusteringSummary(g)\nView(m)",
    "Table 1.\n                Summary of the Clustering Algorithms Used\ntable:\n﻿Alg,mod,C,Cn1,Cn100,mu,Min. C,1st qu. C,Median C,Mean C,3rd qu. C,Max. C\nlec,0.339,16,3,8,0.526,1,5.25,102.5,143.5625,215.75,502\nwt,0.2846,490,359,3,0.447,1,1.0,1.0,4.688,2.0,773\nfc,0.394,20,0,6,0.39,2,5.25,22.5,114.85,105.25,565\ninfomap,0.379,174,0,2,0.597,2,6.0,8.0,13.201,14.0,125\nlouvain,0.425,15,0,11,0.479,22,101.0,121.0,153.133,216.0,311\nsgG1,0.448,24,0,9,0.44,2,5.75,11.5,95.708,231.5,316\nsgG2,0.433,42,0,8,0.523,3,10.75,56.0,54.69,71.5,158\nsgG5,0.368,102,0,0,0.617,3,14.0,22.0,22.52,27.0,78\nspectral,0.37,63,9,4,0.595,1,3.0,28.0,36.46,56.0,184\nNote that your own summary may look slightly different, as some of the algorithms use randomization, so each time they will give slightly (but not significantly) different results.\n4. Visualize the community structure results.\nThe BioNAR package provides functionality to visualize a network's community structure with an in-built cluster-driven layout algorithm, which is suitable for networks up to tens of thousands of vertices and millions of edges. This layout splits the network into clusters, lays out each cluster individually, and then combines individual layouts with the igraph function merge_coords, so that each distinct community is shown independently and painted in a unique color. In our example case, we show the community structure for the results obtained by the Louvain clustering algorithm, which resulted in 15 communities (see Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-tbl-0001]). For visualization purposes, we need to extract the membership in a form of a data frame. A palette is provided using distinctColorPalette command from the package randomcoloR, which defines an individual color for each community; the layoutByCluster command calculates the layout. Additionally, you can define edge color, size of the node, and position of the legend (Fig. 4A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0004]).\n         \nlibrary(randomcoloR)\nmem.df<-data.frame(names=V(g)$name,membership=as.numeric(V(g)$louvain))\npalette <- distinctColorPalette(max(as.numeric(mem.df$membership)))\nlay<-layoutByCluster(g,mem.df,layout = layout_nicely)\nplot(g,vertex.size=3,layout=lay, vertex.label=NA,\nvertex.color=palette[as.numeric(mem.df$membership)],edge.color='grey95')\n   legend('topright',legend=names(table(mem.df$membership)),\ncol=palette,pch=19,ncol = 2)\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/31b000fd-177e-47fc-a27e-a6351962ebd6/cpz1940-fig-0004-m.jpg</p>\nFigure 4\nLouvain clustering visualized with BioNAR. (A) Results of Louvain clustering. (B) Results of re-clustering for Louvain algorithms, in which several of the larger clusters from A are now split to smaller clusters.\n5. Re-cluster the obtained community structure (optional).",
    "A common phenomenon when applying modularity-based clustering algorithms over networks of a large size is to end up with a small number of larger, or “super-,” communities, masking any substructures within these super-communities. In this situation, we provide the user with the facility to re-cluster these large/super-communities in a hierarchical manner, applying the same, or potentially a different, clustering algorithm at each iteration (re-cluster). We also need to specify the threshold for cluster size, which will be retained during re-clustering procedure—10 in our case—and then we use the same algorithm again.\n         \nremem<-calcReclusterMatrix(g,mem.df,alg = “louvain”,10)\nhead(remem)\nThis will return a table where each vertex name (1st column) will be assigned a cluster membership in the original graph (2nd column) and another cluster membership in the re-clustered graph (3rd column). In the example case of Louvain clustering results, the original clustered graph had 15 communities, and the re-clustered graph had 127.\n6. Visualize the re-clustered community structure.\n         \nlay<-layoutByRecluster(g,remem,layout_nicely)\nplot(g,vertex.size=3,layout=lay,\n    vertex.label=NA,\n    vertex.color=palette[as.numeric(mem.df$membership)],\n    edge.color='grey95')\nlegend('topright',legend=names(table(mem.df$membership)),\n    col=palette,pch=19,ncol = 2)\nThe re-clustered graph is shown at Figure 4B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0004].",
    "The algorithms considered in Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0005] are based on a range of different mathematical approaches and will give different results for the same network (as can be clearly seen in Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-tbl-0001]). However, for further analysis, presentation, or publication, it is usually necessary to select one clustered network model based on a single algorithm. In most cases, there is no ground truth, and the choice of the “correct” or “best” clustering algorithm is subjective. While accepting that there is no “correct” or “best” clustering approach, however, we can at least assess which algorithms identify “useful” clusters. To do this, we rely on an assumption that proteins/molecules that are well known to cooperate in the same complex/molecular pathways should be more likely to be found together in the same cluster. Thus, we can use our functional annotations (such as GO annotations) to help identify clustering methods that fit that assumption.\nTo achieve this, we estimate the number of enriched communities for each algorithm and for each annotation term, considering the network's size, the size of each cluster, and the number of annotated genes in the network and in the clusters (see Theoretical Appendix for background details that underpin the method).",
    "The protocol starts by estimating the overrepresentation of annotation terms in each community discovered by each clustering algorithm. Overrepresentation analysis (ORA) is a common approach to identify annotation terms that are significantly over- or under represented in a given set of vertices compared to a random distribution. In biological networks, GO terms and pathway names are amongst the most frequently used. ORA differs from Gene Set Enrichment Analysis (GSEA) in that the latter use numerical values associated with genes, such as expression values, whereas the former relies on presence/absence data utilizing null hypothesis tests, such as the hypergeometric test. To keep the package as general purpose as possible, we used the Bioconductor package fgsea to implement ORA functionality on top of arbitrary string vertex annotation and vertex grouping, obtained by clustering (but not limited by it). We represent the results of ORA as an R data frame, with rows representing the combination of annotation term and cluster and columns—the enrichment characteristics, including the size of the cluster (Cn), the number of annotated vertices in the graph (Fn), the number of annotated vertices in the cluster (Mu), the odds ratio (OR) and its 95% confidence interval (defined by CIl and CIu), and the fold enrichment (Fe and FC). We also provide p-value, adjusted p-value, size of overlap, and the list of vertices from the cluster that contribute to the annotation term. Using the odds ratio allows us to distinguish functionally enriched communities relative to functionally depleted communities.",
    "If we were to rank algorithms simply according to the percentage of functionally enriched communities, it would not tell us anything about the size of community the enrichment originates from—that is, whether the enrichment occurs within extremely large or small communities. Therefore, we plot the fraction of functionally enriched communities greater or equal to the log of its Fe value, measured at 100 intervals taken from 0 to the maximum Fe value (the maximum found from all algorithms studied). Because Fe values take into consideration the size of communities, at this step we can exclude enrichment from communities at the extreme sizes. In general, functional enrichment of non-extreme communities is observed by those clustering algorithms following a sigmoid distribution (see Fig. 5A[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0005]). Thus, we test how well each distribution fits to a generalized sigmoid function using the two-sample Kolmogorov-Smirnov (KS) test to the goodness of fit of each distribution to our set of five idealized sigmoid curves (see Theoretical Appendix for technical detail).\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/68a32024-e3b3-4c87-a48f-514b3db75fe3/cpz1940-fig-0005-m.jpg</p>\nFigure 5\nFold enrichment. (A) A schematic representation of possible scenarios of Fe distribution. The blue curve corresponds to the case in which most cluster-term pairs have small Fe values, either because large clusters cover large part of the network or because only a tiny fraction of the vertices are annotated. The red curve corresponds to the case in which the algorithm produces a lot of small clusters, so that the majority of cluster-term pairs have very large Fe values. To avoid both extreme scenarios, we try to find clustering algorithm with Fe distribution close to the black curve. (B) Plot (type p3) of the fraction of enriched communities against the Fe for each of the nine algorithm clustering results obtained for the postsynaptic network. Each color corresponds to the specific algorithm.",
    "To reproduce clustering results analyzed in this step, we recommend using the example network, built and stored in the external file PSD_annot_cls.gml in BioNAR. The network in this file is the same as in previous protocols but contains the clustering results already assigned to each node.\n \n1. Load the network from BioNAR.\n         \nfile <- system.file(“extdata”, “PSD_annot_cls.gml”, package = “BioNAR”)\ngg <- igraph::read.graph(file,format=“gml”) #graph from gml\nsummary(gg)\n2. Estimate enrichment for the one clustering algorithm and one annotation.\nIf we want to take a look at overrepresentation for a specific algorithm, we need to select the algorithm and then use the function clusterORA to perform overrepresentation analysis for the results obtained with specified algorithm. We also need to specify the annotation set that we will use for assessing the clustering results. Here, we use GO Molecular function annotation (“GOMFID”), but it could be Biological Process or any other annotation, stored as a node attribute in our graph.\n         \nora<- clusterORA(gg, ‘louvain’, name = ‘GOMFID’,\n          vid = “name”, alpha = 1, col = COLLAPSE)\n3. Estimate enrichment for all selected clustering algorithms against the annotation set.\nTo compare all the clustering results, we need to select all algorithms that we want to compare. Then, using the function clusterORA, we perform the overrepresentation analysis on the results obtained with the specified algorithms. As before, we specify the annotation: GOMFID. Finally, we need to calculate FeMax, which corresponds to the maximum Fe value, and FcMax, which corresponds to the maximum Fc value. These values will be needed for further analysis to specify the required range of Fe and Fc values.\n         \nalgs<-c(‘lec’, ‘wt’, ‘fc’, ‘infomap’, ‘louvain’,\n      ‘sgG1’, ‘sgG2’, ‘sgG5’, ‘spectral’)\nora<-lapply(algs, function(alg){clusterORA(gg, alg, name = ‘GOMFID’,\n      vid = “name”,alpha = 1, col = COLLAPSE)})\nnames(ora)<-algs\nFeMax<-log2(max(sapply(ora,function(d){max(d$Fe)})))\nFcMax<-log2(max(sapply(ora,function(d){max(d$Fc)})))",
    "4. Analyze unadjusted p-values for enrichment and print summary table (optional).\nThe command summaryStats will combine the results of enrichment obtained in the step 1, which will produce a list of tables: “SUM,” “SUM2,” “SUM3,” “SUM4,” and “CAN,” where the “SUM” table contains main summary that can be used for detailed analysis of algorithm/term pairs (which is outside the scope of this protocol) and “SUM2,” “SUM3,” and “SUM4,” containing the auxiliary values for further fitting to sigmoid curves.\nThe key table for the enrichment analysis is “CAN,” which records the annotation-term-to-cluster-association data for each clustering algorithm. This shows the user which clusters an enriched annotated term is associated with. As illustrated by the example below, “CAN” consists of four columns, where “ALG” corresponds to the name of the algorithm, “Fn” to the respective GO term ID, “C” to the ID of the cluster, and “Mu” to the number of the genes in the cluster annotated with this term (the cardinality of the pair; see Table 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-tbl-0002] for the first six rows of the “CAN” table).\n         \nstatsR1 <- summaryStats(ora, 0.1, usePadj=FALSE, FeMAX=FeMax, FcMAX=FcMax).\nnames(statsR1)\nView(head(statsR1$CAN))\nTable 2.\n                First Six Rows of ‘CAN’ Table\ntable:\n﻿ALG,Fn,C,Mu\nlec,GO:0035615,1,7\nlec,GO:0005484,2,13\nlec,GO:0000149,2,18\nlec,GO:0003730,3,10\nlec,GO:1990841,3,5\nlec,GO:0003678,3,4\nALG, algorithm name; Fn, enriched GO term ID; C, ID of enriched cluster; Mu, number of genes associated with a term.\n5. Plot the fraction of enriched communities and rank the algorithms.",
    "The command plotRatio creates a rank table for the algorithms and four plots, p1-p4, all showing the distribution of the fraction of enriched communities against fold enrichment (Fe). p1 and p3 show the distribution plotted against log2(Fe), whereas p2 and p4 use log(log2(Fe)). p1 and p2 highlight the top three distributions, whereas p3 and p4 (shown in Fig. 5B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0005]) plot all algorithms each with a different color. Table 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-tbl-0003] and Figure 5B[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0005] show that the Louvain algorithm gives the most useful distribution (for the example given), followed by sgG2 and fc.\n         \nplots<-plotRatio(x=statsR1, desc=“p.values”,LEGtextSize=0.75, LEGlineSize=2)\nView(plots$ranktable) print(plots$p3)\nTable 3.\n                Results of Ranking of the Algorithms Based on the Proportion of Enriched Communities\ntable:\n﻿Alg,Fraction of communities enriched log2(FE) > 0.5_log2(FE) < 4.8,Fraction of communities enriched log2(FE) > 4.8_log2(FE) < 8.0\nlouvain,1.0,0.0\nsgG2,0.973,0.027\nfc,0.96,0.038\nspectral,0.95,0.049\nsgG5,0.88,0.122\nsgG1,0.86,0.139\nlec,0.81,0.19\ninfomap,0.72,0.279\nwt,0.617857142857143,0.382142857142857\nThe table is obtained from the View(plots$ranktable) command.\n6. Fit sigmoid function.\nThis command fits a sigmoid distribution (described in the Theoretical Appendix) to the fraction of enriched communities against Fe values for each clustering algorithm (Fig. 6[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0006]). The function creates a list called fitres, which contains the fitting results. To visualize the fitting results, you need to print gridplot, which is the part of fitres.\n         \nfitres<-fitSigmoid(statsR1)\nprint(fitres[[‘0’]]$gridplot)\nTo view the fitting results, you will need to select fitInfo. They will be presented in the form of a table with the following columns: “alg,” corresponding to the algorithm's name; “isConv,” indicating whether the fit has converged; “finTol,” for the final fitting error; and “stopMessage,” providing a message describing the reason to stop fitting. You can also assess the results of two-sample Kolmogorov-Smirnov (KS) test by selecting “ks” below. Here the columns will correspond to the p-values from the Kolmogorov-Smirnov test of correspondence between Fe distribution and sigmoid function rates.",
    "View(fitres[[‘0’]]$fitInfo,caption = “Summary of the fitting results”)\nView(fitres[[‘0’]]$ks,caption = ‘Summary of the Kolmogorov-Smirnov test’)\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/6a6cf2c7-e233-4abd-835e-f128d6972ae6/cpz1940-fig-0006-m.jpg</p>\nFigure 6\nResults of fitting to five generalized sigmoid functions. Each panel, (A)-(I), illustrates a different clustering method. In each, four gray sigmoid curves correspond to four reference sigmoid curves with rate parameter c (see Technical Appendix) equal to [−10, −5, −1, −0.5], whereas the solid black sigmoid defines the ideal/desired behavior with rate equal to −2. The open circles and red line correspond to the actual fit, while the dashed blue line indicates the 95% confidence interval. Panels (C) and (E) show that the fc and Louvain algorithms give the closest fit to the ideal, with KS values of 1E-01 and 9e-02.\n7. Test the robustness of obtained fitting results.\nTo test the robustness of the fit, we can add some noise to results obtained in previous step. We added noise to each data point by randomly sampling from a Gaussian distribution with mean 0 and a standard deviation of [0.01, 0.05, 0.1, 0.5]. For this we must specify the level of noise (here, 0.05) while executing the commands in step 4. The resulting fitting results with noise and values can be assessed in a similar way (Fig. 7[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0007]). It can be seen that the fc, Louvain, and sgG1 algorithms give the more robust results.\n         \nprint(fitres[[‘0.05’]]$gridplot)\nView(fitres[[‘0.05’]]$fitInfo,align = ‘lllrrrl’,landscape = TRUE,\nmain = ‘Summary of the fitting results’)\nView(fitres[[‘0.05’]]$ks,align = ‘lllrrrl’,landscape = TRUE,\nmain = ‘Summary of the Kolmogorov-Smirnov test’)",
    "We should note here that users should be cautious not use the same datasets (directly or indirectly) for generating the clustered network and testing it. In our example here, we used GO terms, which are not linked to the methods or datasets used in either the clustering methods or the construction of the network architecture, including selection of nodes and edges.\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/f1648bd7-718d-440d-bd3e-b1c2d7290a85/cpz1940-fig-0007-m.jpg</p>\nFigure 7\nResults of fitting to five generalized sigmoid functions with added noise. Each panel, (A)-(I), illustrates a different clustering method. The confidence interval is wider for wt (B) than in Figure 6, and is unbounded for infomap (D), sgG5 (H), and spectral (I), which indicates that fitting for results of these algorithms is unstable. See also legend to Figure 6[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0006].",
    "Not all proteins act similarly in propagating signals, or information, through a network. It is often assumed that proteins that interact with many partners have more significant impact on signal propagation or on disease mechanisms when perturbed. It is also generally found that the majority of proteins interact with just a few neighbors, and thus their contribution is generally predicted to be less impactful (Vidal et al., 2011[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0035]). The importance of a protein in propagating information appears to be dependent on its nearest neighbors, as well as its ability to influence other communities relative to the one to which it most likely belongs (Nepusz et al., 2008[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0021], 2012[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0022]). The bridgeness metric reflects the probability that a vertex could belong to more than one community at the same time, thus providing a useful measure for ranking the vertices based on their topological influence and formation of linkages between clusters in the network model (Nepusz et al., 2008[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0021], 2012[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0022]).\nThe protocol starts from the testing of the robustness of communities obtained in the “most useful” algorithm, obtained in Basic Protocol 3[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0005]. For this, the consensus matrix is produced by creating smaller network by randomly keeping a proportion (by default 80%) of the network edges (type = 1) or vertices (type = 2) and rerunning the clustering algorithm on largest connected component of that network. This is then repeated (by default, 500 times) to produce a distribution (matrix) of clustered networks. This new matrix is used to estimate the bridgeness, which takes values between 0, implying that a vertex clearly belongs to a single community, and 1, implying that a vertex forms a “global bridge” across every community in the network with the same probability (Nepusz et al., 2008[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0021], 2012[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0022]).",
    "Although useful itself as a measure of a “global” network importance, bridgeness becomes more informative when combined with other vertex centrality measures, such as semi-local centrality. Semi-local centrality considers the nearest and next to the nearest vertex neighbors, so reflects the “local” importance of the protein. It also lies between 0 and 1 and indicates whether the vertex is likely to have local influence. Plotting bridgeness against semi-local centrality allows us to categorize both the local and global influence of each vertex within a network given only the network structure. BioNAR also supports the comparison of bridgeness against any vertex centrality measure (or any normalized numeric vertex value) of the user's choice, e.g., against page rank.\nThe protocol for this starts with estimating the bridgeness from the consensus matrix obtained in Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0006] and proceeds by plotting the bridgeness against the centrality measure of choice, which is implemented in two ways. In this example, we continue working with the network from Basic Protocol 4[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0006] and the algorithm that showed the best enrichment performance there, i.e., Louvain.\n1. First, calculate the consensus community structure:\n         \nconmat <- makeConsensusMatrix(g, N=5,\nalg = “Louvain”, type = 2,\nmask = 10, reclust = FALSE,\nCnmax = 10)\nHere, “alg” selects the clustering algorithm to be used, “type” the sampling scheme (1 sample edges and 2 sample vertices) used, “mask” the percentage of edges or vertices to remove from the graph, “reclust” whether re-clustering should be performed on the community set found, “Cnmin” minimum cluster size, and “Cnmax” the maximum cluster size above which re-clustering will be performed (if reClust = TRUE). The resulting matrix conmat has dimensions of 2297 × 2297, where each matrix element is assigned the frequency with which a pair of nodes vertices is found in the same cluster.",
    "2. Calculate the robustness of community structure. To do this, assign to each cluster a value in a range from 0, indicating no confidence in the community existing, to 1, indicating absolute confidence in the cluster existing, thus evaluating the “goodness” of a chosen clustering algorithm.\n         \nclrob<-getRobustness(g, alg = “louvain”, conmat)\npander(clrob)\nThis will return a 15 × 5 table, in which each of the 15 clusters obtain by the Louvain algorithm has the following values: C (cluster number), Cn (cluster size), Crob (cluster robustness), and CrobScaled (0-1, Crob after scaling). CrobScaled should be used to indicate cluster robustness. It can be seen in the example that the most robust cluster is Cl9 (CrobScaled = 1) and the least robust is Cl15 (CrobScaled = 0).\n3. Calculate the bridgeness.\n         \nbr<-getBridgeness(gg,alg = “louvain”, conmat)\nhead(br)\nThe command getBridgeness takes the graph and consensus matrix (conmat) from step 1 as an input and returns the bridgeness results in a form of table with three columns, where the first column contains ID (Human Entrez ID), the second GENE.NAME (Human Gene Name), and the third BRIDGENESS.louvain (bridgeness values obtained with the Louvain algorithm). Next, assign bridgeness values as vertex attributes:\n         \ng<-calcBridgeness(g,alg = alg, conmat)\nvertex_attr_names(g)\nFor convenience, bridgeness values will also be stored as vertex attributes.\n4. Plot bridgeness against the semilocal centrality (SL).\nIf we want to highlight the proteins of interest on the plot, we can specify their IDs as VIP vertices. In our case we will highlight the synaptic proteins with known function “Protein cluster,” based on a classification, extracted from an unrelated published study (Lips et al., 2012[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0043]), which is also stored in BioNAR as an external data file.\n         \nsfile<-system.file(“extdata”, “SCH_flatfile.csv”, package = “BioNAR”)\nshan<- read.table(sfile,sep=“\\t”,skip=1,header=FALSE,strip.white=TRUE,quote=“”)\nhead(shan)",
    "The table shan consists of three columns: the first column contains the function number, the second the function description, and third the gene ID (Entrez ID) that is associated with this function. Here, we want to select gene IDs with “protein cluster” functions.\n         \ntable(shan$V2)\nshan[shan$V2 ==“Protein_cluster”,] -> prCl\ndim(prCl)\nplotBridgeness(g,alg = “louvain”,\nVIPs=prCl$V3,\nXatt=‘SL’,\nXlab = “Semilocal Centrality (SL)”,\nYlab = “Bridgeness (B)”,\nbsize = 3,\nspsize =7,\nMainDivSize = 0.8,\nxmin = 0,\nxmax = 1,\nymin = 0,\nymax = 1,\nbaseColor=“royalblue2”,\nSPColor=“royalblue2”)\nBy plotting bridgeness against semi-local centrality (Fig. 8[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-fig-0008]), we have categorized the influence each protein found in our network has on the overall network structure:\n         \nRegion 1 (top left): Proteins with a “global” rather than “local” influence in the network (vertices in this region have also been referred to as bottleneck bridges, connectors, or kinless hubs; 0 < SL < 0.5; 0.5 < B < 1).\nRegion 2 (top right): Proteins with both “global” and “local” influence (0.5 < SL < 1, 0.5 < B < 1).\nRegion 3 (bottom left): Proteins centered within the community they belong to, but also communicating with a few other specific communities (0 < SL< 0.5; 0 < B < 0.5).\nRegion 4 (bottom right): Proteins with “local” impact, primarily restricted to just one or two communities (also referred to as local or party hubs; 0.5 < SL< 1, 0 < B < 0.5).\nTo plot the same figure in an interactive manner (to see the names for non-highlighted dots), the function ggplotly from the plotly library can be called as follows:\n         \nlibrary(plotly)\ngp<-plotBridgeness(g,alg = “louvain”,\nVIPs= prCl$V3,\nXatt=‘SL’,\nXlab = “Semilocal Centrality (SL)”,\nYlab = “Bridgeness (B)”,\nbsize = 1,\nspsize =2,\nMainDivSize = 0.8,\nxmin = 0,\nxmax = 1,\nymin = 0,\nymax = 1,\nbaseColor=“royalblue2”,",
    "SPColor=“royalblue2”)\nggplotly(gp)\n<p>imgsrc:https://currentprotocols.onlinelibrary.wiley.com/cms/asset/0bbb1c92-17ed-4b61-b195-00f5493fe4d9/cpz1940-fig-0008-m.jpg</p>\nFigure 8\nPlot of bridgeness (B) against the semilocal centrality (SL) for Louvain clustering results. Highlighted are the proteins with known function “protein cluster.” Of the highlighted proteins, only a few belong to region 1 and have global impact on the network (PICK1, CASK, PASCIN1, MPP3). The rest belong to region 3 and largely influence their own communities.",
    "This protocol describes how to identify which annotations overlap, and where within the network different annotations tend to overlap (or, conversely, are distinct and separate). For example, within large-scale molecular networks, disease-associated genes are often found closely linked to one another (referred to as disease modules by Menche et al., 2015[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0020], and based on the shortest path in the network linking the disease terms), and the composition of these modules can be compared across different diseases. Disease annotations that tend to overlap in these modules also tend to show significant similarities at the level of gene coexpression patterns, clinical phenotype, and comorbidity. Conversely disease annotations residing in separated network neighborhoods appear to be more phenotypically distinct.\nThis phenomenon is not restricted to diseases and can be generalized, so that given two annotations distributed across a network, a common query would be to find the points of intersection where the two annotation sets overlap (or segregate). To support such queries, we implemented the algorithm from Menche et al. (2015[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-bib-0020]), which tests whether the observed mean shortest paths between two distinct annotation sets, superimposed on a network, is significant compared to a randomly annotated network.\nThe following example illustrates the estimation of disease separation for a manually selected set of diseases: DOID:10652 (Alzheimer's disease), DOID:3312 (bipolar disorder), DOID:14330 (Parkinson's disease), DOID:0060041 (autism spectrum disorder), DOID:1826 (epilepsy syndrome), DOID:5419 (schizophrenia), DOID:9255 (frontotemporal dementia), and DOID:1059 (intellectual disability). The command calcDiseasePairs estimates the separation of pairwise annotations across the graph and compares it with that of a randomly reannotated graph. This can be useful for generating a qualitative overview of the relationships between the annotations.\nWe do not need the cluster structure for this analysis, so the annotated network from Basic Protocol 2[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0004] (g) is sufficient to perform Basic Protocol 6[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#cpz1940-prot-0008].",
    "1. Calculate the annotation pairs.\nThe BioNAR command calcDiseasePairs calculates the observed overlap between two annotation sets on a network, and compares this to a single instance of the network with annotations randomly permuted; this is useful for a qualitative estimate of how likely an overlap is simply a random occurrence.\nTo calculate annotation overlap, we need to specify the name of the annotations. In our example, it is TopOntoOVGHDOID, which contains the HDO IDs for diseases. We will also need to specify the IDs for which the overlap will be calculated. “r” corresponds to random permutations (other options are “none,” in which case no permutation will be applied at all, and “binned,” in which case the permutation process tries to take into account the node degree, which is slightly longer than random).\n         \np <- calcDiseasePairs(\n   g,\n   name = “ TopOnto_OVG_HDO_ID”,\n   diseases = c(“DOID:10652”,“DOID:3312”, “DOID:14330”, “DOID:0060041”, “DOID:1826”, “DOID:5419”, “DOID:9255”, “DOID:1059”),\n   permute = “r”\n)\npander(p$disease_separation)\nThe command pander will return a snapshot of an 8 × 8 table, where for each of disease pair there is a value that ranges from negative (indicating potential overlap) to positive (indicating separation).\n2. Calculate the significance of the annotation overlap.\nTo calculate the significance of observed overlaps (or separations) of the observed annotation pairs in the network, the command runPermDisease is used. This compares the overlap against multiple permutations of the network (where the user can define the number of permutations). Executing this command may take considerable time, depending on the number of permutations chosen. It generates a results table containing the overlap of each annotation pair with p-value, p adjusted by Bonferroni test, and q-value.",
    "In our simple example below, we selected 100 permutations, but for better significance, there should be 10,000 permutations (requiring ∼1 hr of computing time for this size of network and this set of annotations).\n         \nr <- runPermDisease(\ng,\nname = “TopOnto_OVG_HDO_ID”,\ndiseases = c(“DOID:10652”, “DOID:3312”),\nNperm = 100,\nalpha = c(0.05, 0.01, 0.001)\n)\npander(r$Disease_overlap_sig)\nThe pander command will return a table containing a number of rows equivalent to the number of annotation pairs and the following columns: HDO.ID.A, the HDO ID for the first disease; N.A., the number of genes associated with this disease; HDO.ID.B, the HDO ID for the second disease; N.B., the number of genes associated with second disease; sAB, a value that characterizes the overlap (negative for overlap and positive for separation); Separated, indicating whether the pair is separated based on sAB; Overlap, indicating whether the pair overlaps based on sAB; zScore, the Z score for this pair of annotations (see the formula in Menche et al., 2015); p-value, the respective p-value for the overlap; Separation/Overlap.than.chance, indicating whether the ratio of the separation and overlap is greater than expected by chance; Bonferroni, the Bonferroni value for the overlap; p.adjusted, the p-value adjusted for multiple testing; and q-value, the q-value adjusted by the FDR. An example of the table resulting from this step is provided in the Supporting Information as Supplementary Table 1[href=https://currentprotocols.onlinelibrary.wiley.com/doi/10.1002/cpz1.940#support-information-section]; in this table, a few pairs of diseases show significant overlap (highlighted in yellow), such as Alzheimer's disease and Parkinson's disease (p.adjusted = 6.01E-06, Bonferroni ***), schizophrenia and bipolar disorder (p.adjusted = 4.25E-013, Bonferroni ***), and autism spectrum disorder and bipolar disorder (p.adjusted = 5.51E-08, Bonferroni ***)"
  ],
  "subjectAreas": [
    "Bioinformatics"
  ],
  "bigAreas": [
    "Bioinformatics & Computational Biology"
  ]
}