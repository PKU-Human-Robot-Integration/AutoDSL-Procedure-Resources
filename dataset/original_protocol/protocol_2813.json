{
  "id": 2975,
  "origin_website": "Cell",
  "title": "Measurement of selection coefficients from genomic samples of adapting populations by computer modeling",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nBinarization of genomic data\nTiming:  1.0  L  ×  N /  10 7   sec \nRun our program ACTGtranslate.m (key resources table[href=https://www.wicell.org#key-resources-table]) that inputs N sequences of length L from the MEGA output files for all timepoints t1, t2, and t3 obtained in preliminary step 3. The program will automatically carry out the steps, as follows:\nInitialize parameters.\n%% parameters\n% b1 - number of the first sequence to be read\n% b2 - number of the last sequnce to be read\n% tr1 - deletion threshold\n% fcut - monomorphous threshhold\nb1 = 1;\nb2 = 3;\ntr1 = 0.05;\nfcut = 0.05;\nam = (b2-b1+1); %amount of the sequences\ngen = {}; %container for raw info\ndata = {}; %container for result info\nTake data from .fas files.\nNote: Steps 2–6 are performed 3 times, for each time period, where k=1:3 is the counter.\n%take data from files\nfor k = 1:3\nfilepath=strcat('data\\period',num2str(k));\n  oldpath=cd(filepath);\nfilelist{k}= dir ('∗∗/∗.fas');\ngen{k} = fastaread(filelist{k}.name,’BlockRead’, [b1 b2],’IgnoreGaps’,false);\nFind the length of the sequence.\nl = length(gen{k}(1).Sequence);\n%l - length of the sequence\nFind the sites with deletions and insertions in sequences (Figure 1[href=https://www.wicell.org#fig1]) and memorize them.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2514-Fig1.jpg\nFigure 1. An example of MEGA11 output with an insertion and a deletion\nNote: The aim of protocol is to measure the selection coefficient si defined for sites that evolve due to point mutations. Genomic regions with frequent insertions and deletions cannot be described by thus parameter and, hence, cannot be treated by this method.\n%data cleaning\n  banlistSeq = [];\n  banlistSit = [];\n  erram = zeros(am,1);\n  potential = [];\n  for i0 = 1:l\n    del = 0;\n    sch = 1;\n    for j0 = 1:am\n    if isempty(banlistSeq) || j0 ∼= banlistSeq\n      seq = gen{k}(j0).Sequence;\n      if seq(i0) =='-' || seq(i0) =='N'\n        potential = [potential j0];",
    "del = del+1;\n      end\n    else\n      sch=sch+1;\n    end\n  end\n  if del ∼=0\n    if del/(am-sum(erram)) >=tr1\n      banlistSit = [banlistSit i0];\n      potential = [];\n    else\n      erram(potential,1) = erram(potential,1)+1;\n      banlistSeq = [banlistSeq potential];\n      banlistSeq = sort(banlistSeq);\n      potential = [];\n    end\n  end\nend\nDelete all sequences with deletions. Mark the sites where some sequences have insertions with ‘E’.\nif ∼isempty(banlistSeq)\n  gen{k}(banlistSeq) = [];\nend\nif ∼isempty(banlistSit)\n  for sch3 = 1:am\ngen{k}(sch3).Sequence(banlistSit) = 'E';\n  end\nend\ndata{k} = zeros(am,l);\nFind the common consensus nucleotide or aminoacid sequence for all the time points.\n%finding the common consensus\ncons = '';\nfor i = 1:l\n  qA=0;\n  qC=0;\n  qT=0;\n  qG=0;\n  qE=0;\n  for j = 1:am\n    seq = gen{k}(j).Sequence;\n    switch seq(i)\n      case 'A'\n      qA = qA+1;\n      case 'C'\n      qC = qC+1;\n      case 'T'\n      qT = qT+1;\n      case 'G'\n      qG = qG+1;\n      case 'E'\n      qE = qE+1;\n    end\n  end\n  [∼,I] = max([qA qC qT qG qE]);\nswitch I\n  case 1\ncons = [cons 'A'];\n  case 2\ncons = [cons 'C'];\n  case 3\ncons = [cons 'T'];\n  case 4\ncons = [cons 'G'];\n  case 5\ncons = [cons 'E'];\nend\nend\nFor each time point and each genome, replace the consensus variant at each nucleotide or aminoacid position (below termed “site”) by 0 and any other variant by 1. Digit 2 marks the site that will be excluded later.\n%binarization\nfor i2 = 1:l\n  for j2 = 1:am\n    seq = gen{k}(j2).Sequence;\nif seq(i2)∼='E'\n    if seq(i2) == cons(i2)\n      data{k}(j2,i2)=0;\n    else\n      data{k}(j2,i2)=1;\n    end\nelse\n  data{k}(j2,i2)=2;\nend\n  end\nend\nFinds “legitimate” sites that do not have insertions and deletions and whose diversity is above threshold fcut.\nNote: Homozygous sites do not allow the measurement of selection coefficients. Weakly heterozygous sites do, but with a large statistical error. For example, for 100 sequences estimated per geographic area, the threshold fcut of a few percent is recommended.",
    "%finding the 'right' site numbers\nrightsites{k}=[];\nfor msch = 1:l\nif data{k}(1,msch)∼=2\n  if ∼(mean(data{k}(:,msch))>=1-fcut || mean(data{k}(:,msch))<=fcut)\nrightsites{k} = [rightsites{k} msch];\n  end\nend\nend\n  cd(oldpath);\nend\nFinds the intersection between the legitimate sites of the three time periods.\n  %findind the intersection between 'right' sites of the different time\n  %periods\nC1=intersect(rightsites{1},rightsites{2});\nC2=intersect(C1,rightsites{3});\nExcludes illegitimate sites marked “2” and memorizes the numbers of the legitimate sites.\n%removing 'bad' sites and remebering the numbers of the 'right' one\nfor kk=1:k\n  [∼,l]=size(data{kk});\n  C3 = 1:l;\n  C3(C2) = [];\n  data{kk}(:,C3) = [];\nend\ndata{k+1} = C2;\nGenerates file BinData.mat containing genomic binary sequences for renumbered legitimate sites at three time points and displays the resulting binary matrices (see an example in Table 1[href=https://www.wicell.org#tbl1]).\ntable:files/protocols_protocol_2514_1.csv\nParameters: L = 100, N = 1000. Only the first 13 sites and 12 individual sequences are shown.\n%saving the data\nsave(strcat('BinData','.mat'),'data');\ndisp(data)\nInference of selection coefficients\nTiming:  8.0  L  ×  N /  10 7   s e c \nThis major step serves to infer the selection coefficients of polymorphous loci from a DNA sample. Below we use an example with N mock binary sequences of length L data generated by run runs of Monte-Carlo simulation using recomb_2022.m (key resources table[href=https://www.wicell.org#key-resources-table]), for a fixed set of    s i  .   The same procedure can be run with N real-life sequences of length L obtained from several independent populations combined in one matrix (Table 1[href=https://www.wicell.org#tbl1]).\nNote: Monte-Carlo simulation of sequences is required only if you want to test the accuracy of the protocol. It takes much more time than the main protocol:   30  L  ×  N  ×  r u n  ×  t f / 6 ⋅  10 8   m i n  .\nRun MATLAB program s_measure.m (key resources table[href=https://www.wicell.org#key-resources-table]) that inputs binary sequences from BinData.mat. The program carries out the steps, as follows:",
    "Input data from BinData.mat.\nload('BinData.mat','data');\ngenome1 = data{1,1};\ngenome2 = data{1,2};\ngenome3 = data{1,3};\norder = data{1,4};\nInput parameter description:\ntr1 - deletion threshold in ACTGtranslate.m.\nfcut - monomorphous threshhold in ACTGtranslate.m.\ngenome1 (2, 3) – binary matrix representing genomic samples at times 1, 2, or 3.\nC – initial value of C in Equation 1[href=https://www.wicell.org#fd1].\nappr – method of curve approximation:\n‘poly’ - by basic polynomials.\n‘spline’ – by cubic splines.\n‘pchip’ – by Piecewise Cubic Hermite Interpolating Polynomial (PCHIP).\napprR – additional parameter for ‘poly’ approximation - rate of polynomial.\ntsec1, tsec2, tsec3– times of the first, second and third sequence sample.\nr – recombination probability per genome.\ns0 –the width of the uniform distribution of selection coefficient.\nac∗s0, bc∗s0 - borders of uniform s distribution.\nM – crossover number.\nL – number of loci.\nN –population size\ntf – end time of evolution.\nf0 – initial value of f.\nrun – number of Monte Carlo evolution runs, also used as the seed for the first run.\nrun2 – the seed for generating the random distribution of s.\nmu – mutation probability per site.\neps – the accuracy of C.\nstep – step in C.\nRun program s_measure. m with the loaded arguments. It initialize variables.\nFunction sdis=s_measure(genome1,genome2,genome3,order,C,appr,apprR,generate)\nglobal tsec1 tsec2 tsec3 r s0 M L N tf f0 run run2 mu ac bc\nscon = {};\nif gen\n[∼,l] = size(genome1{1,1});\n%l - quantity of the alleles\n[R,∼] = size(genome1);\n%R - quantity of runs\nf1 = zeros(R,l); % array for fi at 1 time (for R runs)\nf2 = zeros(R,l); % array for fi at 2 time (for R runs)\nf3 = zeros(R,l); % array for fi at 3 time (for R runs)\nend",
    "eps = 10ˆ-3; % difference between zero and value of the y coordinate of the triangle center, when the loop stops\nyccord = 1; % basic value of the y coordinate of the triangle center\nstep =10ˆ-3; % value of the step\nfindc = true;\nCalculate the frequency of digit “1” for each site   i ,    denoted    f i   ( t )  ,   at each time point   t =  t 1  ,  t 2  , and   t 3    (Table 2[href=https://www.wicell.org#tbl2]).\ntable:files/protocols_protocol_2514_2.csv\nParameters: L = 100, N = 1000. Only the first 13 sites are shown. The example from Table 1[href=https://www.wicell.org#tbl1] is used.\n% calculation of fi\nif gen\nfor rs = 1:R\n  f1(rs,:)=mean(genome1{rs,1});\n  f2(rs,:)=mean(genome2{rs,1});\n  f3(rs,:)=mean(genome3{rs,1});\nend\nf1f = mean(f1);\nf2f = mean(f2);\nf3f = mean(f3);\nelse\n  f1f=mean(genome1);\n  f2f=mean(genome2);\n  f3f=mean(genome3);\nend\nAt each time point   t  , estimate the relative shifted value of selection coefficient at site   i  , denoted as product   β  ( t )   s i   , from equation (Barlukova and Rouzine, 2021[href=https://www.wicell.org#bib1]).\n(Equation 1)\nβ\n(\nt\n)\ns\ni\n=\n−\nlog\n[\nf\ni\n(\nt\n)\n]\n+\nC\n%calculation of si\nbsi1 = -1∗log(f1f)-C;\nbsi2 = -1∗log(f2f)-C;\nbsi3 = -1∗log(f3f)-C;\nNote: The value of   C   is found, as follows. First, it gets initial value of C from the input arguments of the function. To determine the actual value   C  , the same program s_measure.m carries out the steps:\nRank genomic sites in the descending order of the estimated values of    s i   .\nCalculate for each site   i   its new number    m i   , where   i   is the label of the site in the genome, and    m i    is its number after the ranking in    s i   .\n%sorting and calculating\n[B1,I1] = sort(bsi1,'descend');\n[B2,I2] = sort(bsi2,'descend');\n[B3,I3] = sort(bsi3,'descend');",
    "Obtain a monotonous ranked curve    s i   (  m i  )    for each time point (Figure 2[href=https://www.wicell.org#fig2]A).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2514-Fig2.jpg\nFigure 2. Ranked curve    s i   (  m i  )    for three time points\n(A) Successful separation of curves, with a proper focal point, when far from a steady state.\n(B) Failure of the method close to a steady state. Parameters: (A) s0 = 0.05, ac = -1, bc = 1, L = 100, N = 1000, tf = 60, f0 = 0.1, runs = 100, μL = 0.1, t1 = 20, t2 = 40, t3 = 60; (B) t1 = 500, t2 = 750, t3 = 1000, tf = 1000, and the others as in (A).\nNote: The three curves form a small triangle. The curves will not separate fully, if the system is in a steady state where the method does not work (Figure 2[href=https://www.wicell.org#fig2]B). The code for plotting is not shown here, see file s_measure.m.\nFind the center of mass of this triangle, denoted   (  m c  ,   s c  )  .\nAdjust   C   to obtain    s i  = 0   at that center and repeats calculation with Equation 1[href=https://www.wicell.org#fd1] given above in step 14.\nRepeat the loop described in steps 18–26, until obtaining    s i  = 0   at the center of the triangle within accuracy eps.\nwhile abs(yccord) > eps\n%calculation of si\nbsi1 = -1∗log(f1f)-C;\nbsi2 = -1∗log(f2f)-C;\nbsi3 = -1∗log(f3f)-C;\n%sorting and calculating\n[B1,I1] = sort(bsi1,'descend');\n[B2,I2] = sort(bsi2,'descend');\n[B3,I3] = sort(bsi3,'descend');\nxdots = {};\nydots = {};\nxdotss = {};\nydotss = {};\nFit the three curves with one of four methods, three of which (a, b, c) are standard functions in MATLAB.\nPolynomial.\nswitch appr\n  case 'poly'\n%polynomial approximation\np1 = polyfit([1:1:length(I1)],B1,apprR);\np2 = polyfit([1:1:length(I2)],B2,apprR);\np3 = polyfit([1:1:length(I3)],B3,apprR);\nCubic splines.\n  case 'spline'\n%spline approximation",
    "sp1 = spline([1:1:length(I1)],B1);\nsp2 = spline([1:1:length(I2)],B2);\nsp3 = spline([1:1:length(I3)],B3);\nPiecewise Cubic Hermite Interpolating Polynomial (PCHIP).\n  case 'pchip'\n%pchip approximation\npp1 = pchip([1:1:length(I1)],B1);\npp2 = pchip([1:1:length(I2)],B2);\npp3 = pchip([1:1:length(I3)],B3);\nTest case (only for plotting the curves, when the other algorithms do not work).\n  case \"test\"\nfindc=false;\nyccord = 0;\nC = 0;\nend\nFind intersections of the three pairs of three curves by one of the methods chosen by input parameter appr.\nPolynomial.\ninter1 = p1 - p2;\ninter2 = p1 - p3;\ninter3 = p2 - p3;\nxdots{1,1} = roots(inter1);\nxdots{1,2} = roots(inter2);\nxdots{1,3} = roots(inter3);\nCubic spline.\nsinter1 = @(x) ppval(sp1,x)-ppval(sp2,x);\nsinter2 = @(x) ppval(sp1,x)-ppval(sp3,x);\nsinter3 = @(x) ppval(sp2,x)-ppval(sp3,x);\nxdots{1,1} = fzero(sinter1,mean([1:1:length(I1)]));\nxdots{1,2} = fzero(sinter2,mean([1:1:length(I2)]));\nxdots{1,3} = fzero(sinter3,mean([1:1:length(I3)]));\nPCHIP.\npinter1 = @(x) ppval(pp1,x)-ppval(pp2,x);\npinter2 = @(x) ppval(pp1,x)-ppval(pp3,x);\npinter3 = @(x) ppval(pp2,x)-ppval(pp3,x);\nxdots{1,1} = fzero(pinter1,mean([1:1:length(I1)]));\nxdots{1,2} = fzero(pinter2,mean([1:1:length(I2)]));\nxdots{1,3} = fzero(pinter3,mean([1:1:length(I3)]));\nFind y-coordinates of the intersection dots and memorize y-coordinates of the first and last point of the approximation curve by one of the methods chosen by input parameter appr.\nPolynomial.\nydots{1,1} = polyval(p1,xdots{1,1});\nydots{1,2} = polyval(p1,xdots{1,2});\nydots{1,3} = polyval(p2,xdots{1,3});\nybord{1,1} = polyval(p1,1);\nybord{1,2} = polyval(p2,1);\nybord{1,3} = polyval(p3,1);\nybord{2,1} = polyval(p1,length(I1));\nybord{2,2} = polyval(p2,length(I2));\nybord{2,3} = polyval(p3,length(I3));\nSpline.\nydots{1,1} = ppval(sp1,xdots{1,1});\nydots{1,2} = ppval(sp1,xdots{1,2});\nydots{1,3} = ppval(sp2,xdots{1,3});\nybord{1,1} = ppval(sp1,1);\nybord{1,2} = ppval(sp2,1);\nybord{1,3} = ppval(sp3,1);\nybord{2,1} = ppval(sp1,length(I1));\nybord{2,2} = ppval(sp2,length(I2));\nybord{2,3} = ppval(sp3,length(I3));\nPCHIP.\nydots{1,1} = ppval(pp1,xdots{1,1});\nydots{1,2} = ppval(pp1,xdots{1,2});\nydots{1,3} = ppval(pp2,xdots{1,3});\nybord{1,1} = ppval(pp1,1);\nybord{1,2} = ppval(pp2,1);\nybord{1,3} = ppval(pp3,1);\nybord{2,1} = ppval(pp1,length(I1));\nybord{2,2} = ppval(pp2,length(I2));\nybord{2,3} = ppval(pp3,length(I3));\nCheck the accuracy of the intersection points by verifying whether they have real values and lie on the curves.\nif findc\n%coordinates check\nIall={I1;I2;I3};\nfor times = 1: length(xdots)\n  ncount1 = 0;\nfor param1= 1: length(xdots{1,times})\nIallLen(times) = length(Iall{times,1});\n  if xdots{1,times}(param1)<= IallLen(times)",
    "&& xdots{1,times}(param1)>=1 && imag(xdots{1,times}(param1))==0 && ydots{1,times}(param1)<=ybord{1,times} && ydots{1,times}(param1)>=ybord{2,times}\n    ncount1 = ncount1 +1;\n    xdotss{times,ncount1} = xdots{1,times}(param1);\n    ydotss{times,ncount1} = ydots{1,times}(param1);\n  end\nend\nend\nForm the triangle from the intersection points and find its center.\n%coordinates of triangle tops\nxdcord = [];\nydcord = [];\n[shr,dl] = size(xdotss);\nfor h =1:shr\n  for c = 1:dl\n    xdcord = [xdcord xdotss{h,c}];\n    ydcord = [ydcord ydotss{h,c}];\n  end\nend\n%center finding\npolyin = polyshape({xdcord},{ydcord});\n[xccord,yccord] = centroid(polyin);\nModify C and repeat the cycle (step 18) until obtaining    s i  = 0   at the center within accuracy eps.\nif yccord>0\n  C = C+ step;\nend\nif yccord<0\n  C = C - step;\nend\nend\nend\nAfter the accuracy is reached in step 20, the final estimates of si are obtained.\nNote: In our example of simulated sequences, these estimates are plotted against their actual values (Figure 3[href=https://www.wicell.org#fig3]), at different number of runs used for averaging (100 and 1,000), and different time points. The code for plotting is not shown, see the file s_measure.m.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2514-Fig3.jpg\nFigure 3. Estimated values of selection coefficient as a function of their actual values\n(A) 100 runs.\n(B) 1000 runs. Parameter values are as in Figure 2[href=https://www.wicell.org#fig2].\nRe-order the ranked sites back,   i   to    m i    and plot the relative values of selection coefficient,   β  ( t )   s i   , against their actual aminoacid positions,   i   (Figure 4[href=https://www.wicell.org#fig4]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2514-Fig4.jpg\nFigure 4. Estimated relative values of selection coefficient in the genome\nX-axis: Site number in genome. Y axis: selection coefficient. (A, B and C) correspond to the three sampling times and differ, mostly, in the scaling factor common for all sites. Parameter values are as in Figure 3[href=https://www.wicell.org#fig3]."
  ],
  "subjectAreas": [
    "Genomics",
    "Sequence Analysis",
    "Computer Sciences",
    "Genetics",
    "Evolutionary Biology"
  ],
  "bigAreas": [
    "Molecular Biology & Genetics"
  ]
}