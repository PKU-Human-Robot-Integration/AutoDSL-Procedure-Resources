{
  "id": 3135,
  "origin_website": "Cell",
  "title": "WaveMAP for identifying putative cell types from in vivo electrophysiology",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nPreparing the dataset\nTiming: 20 min\nBefore beginning with data curation and averaging of spikes, it’s important to point out how the data should be prepared prior to processing. Electrophysiological data can be collected from a wide variety of acquisition devices and probes but as it’s beyond this protocol to address them all, we point out here general processing principles we’ve found to be compatible with WaveMAP. Code is not provided for these next steps as this can be handled directly by most spike sorting software. We begin the protocol presuming that the user has clusters of spikes (Figure 1[href=https://www.wicell.org#fig1]A) putatively associated with single units.\nNote: If using a high-density probe, a multi-channel spike can also be used but with a fixed number of channels above and below the largest amplitude spike; we’ve used five channels above and below a central channel (11 total) on a Neuropixels 1.0 probe.\nAlign spikes according to their depolarization peak/trough even if they are positive spiking in shape (see Figure 1[href=https://www.wicell.org#fig1]C). Axonal spikes should be aligned by their depolarization peak (Figure 1[href=https://www.wicell.org#fig1]C, right).",
    "Note: Previously, we mentioned that waveforms should be aligned by their depolarization trough, but this is not well-defined for all neurons. For negative spikes (Figure 1[href=https://www.wicell.org#fig1]C, left), this is easily seen but for positive spikes (i.e., spikes where their peak is larger than their troughs; Figure 1[href=https://www.wicell.org#fig1]C, right), they should be aligned at the trough of an “m-shaped” waveform12[href=https://www.wicell.org#bib12] or the central peak of an “axonal waveform”.13[href=https://www.wicell.org#bib13] An additional caveat with high-density probes is that multiple channels will record from the same unit. However, the spike shape may change across these channels due to differences in the morphology and even include both negative and positive spike shapes. To account for this, we recommend either just using the largest amplitude spiking channel or using the entire multi-channel waveform in WaveMAP analyses. The latter can be done by concatenating multiple channels together into one long waveform.\nSpike depolarization peaks/troughs should be aligned to 0.3 ms into the spike window to maximize the amount of visible post-hyperpolarization peak/trough.\nSelect the longest spike window (Figure 1[href=https://www.wicell.org#fig1]A, middle) possible without catching subsequent spikes.\nNote: We don’t often see units in vivo that spike faster than 500 Hz and so are able to use spike windows of 2.0 ms or more. Certain brain areas may have faster spiking neurons and as such, a tighter window should be used.\nIf spikes are of different sampling rates, downsample faster sampled spikes to the slowest sampling rate.\nCritical: Although the processing principles we describe here are general, it is of utmost important that the entire dataset is as standardized as possible. For instance, if multiple high-pass filter frequencies were used to find spikes within the same dataset, this can result in artifactual structure in downstream analyses (see problem 2[href=https://www.wicell.org#sec6.3]).\nCurating and averaging spikes",
    "Timing: Variable (depends on the size and quality of the dataset)\nBefore averaging waveforms, the most crucial step is to curate spikes thoroughly. We use automated curation using spike quality metrics followed by manual curation via visual inspection. This is of utmost importance as poor quality input data can result in poor quality outputs since WaveMAP classifies average waveforms using unsupervised methods. If WaveMAP results are suboptimal (lacking defined clusters in the projected space, Figure 3[href=https://www.wicell.org#fig3]), the data may need to be re-curated (see problem 3[href=https://www.wicell.org#sec6.5]). Even if a user has a pre-curated dataset, it’s worth briefly examining spikes by visual inspection. Lastly, the amount of curation required depends on initial data quality and the size of the dataset i.e., how strictly data can be curated without losing too many units. Around 300 high-quality units are needed for results with WaveMAP and we encourage users to err on the side of quality over quantity.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2705-Fig3.jpg\nFigure 3. Unnormalized vs. normalized waveforms in UMAP-space with pre-normalization amplitude shown as marker color\n(A) Unnormalized average single-unit waveforms from Lee et al. 20211[href=https://www.wicell.org#bib1] after UMAP projection and colored by the logarithm of their unnormalized amplitude.\n(B) Amplitude-normalized average single-unit waveforms from Lee et al. 20211[href=https://www.wicell.org#bib1] and colored by the logarithm of their pre-normalized amplitude.",
    "Critical: There is no “one-size-fits-all approach” when it comes to choosing spike quality metrics or their thresholds. For curation, we recommend tools that give a comprehensive view of many spike quality metrics like SpikeInterface’s QualityMetrics module.14[href=https://www.wicell.org#bib14] We suggest signal-to-noise ratio and ISI violation rate because they work well at estimating cortical unit isolation quality in low-density probes (i.e., units appear on only single channels) in experiments with minimal drift. With high-density probes and/or experiments with a lot of drift, these thresholds must be made less conservative and other metrics must examined such as amplitude cutoff and presence ratio (see https://allensdk.readthedocs.io/en/latest/_static/examples/nb/ecephys_quality_metrics.html[href=https://allensdk.readthedocs.io/en/latest/_static/examples/nb/ecephys_quality_metrics.html] for more details).\nConduct automated curation by calculating spike quality metrics and excluding spike clusters that exceed conservative exclusion criteria.\nNote: The following code is adapted from the Allen Institute’s ecephys package (https://github.com/AllenInstitute/ecephys_spike_sorting/[href=https://github.com/AllenInstitute/ecephys_spike_sorting/]).\nCalculate signal-to-noise (SNR) ratio15[href=https://www.wicell.org#bib15],16[href=https://www.wicell.org#bib16] for each cluster.\nNote: This is the ratio of mean waveform amplitude and background noise on the channel and can be computed with the following Python code where W is a Numpy array of spikes-by-samples.\nimport numpy as np\nW_bar = np.nanmean(W, axis=0)\nsig_amp = np.max(W_bar) – np.min(W_bar)\nnoise = W – np.tile(W_bar, (np.shape(W)[0], 1))\nsnr = sig_amp/(2∗np.nanstd(noise.flatten()))\nRemove any clusters that have an SNR below 3.0.\nCalculate the ISI violation rate.17[href=https://www.wicell.org#bib17]\nThis can be computed with the following Python code where spike_train is a Numpy array of spike times in seconds.\nNote: ISI violation rate is the percentage of intervals between spikes that are faster than physiologically possible due to action potential refractory periods.\nimport numpy as np\nisi_threshold = 0.0015 #The minimum duration of a spike, in seconds\nduration = np.max(spike_train) – np.min(spike_train)\nfiring_rate = spike_train.size / duration\nisis = np.diff(spike_train)\nnum_spikes = size(spike_train)\nnum_violations = np.sum(isis < isi_threshold)\nviolation_time = 2∗num_spikes∗isi_threshold\nviolation_rate = num_violations/violation_time\nisi_violation_percentage = violation_rate/firing_rate∗100",
    "Remove any clusters that have an ISI violation rate of above 0.25%.\nNote: If this automated curation step still yields many clusters that appear to be noisy (or leaves not enough to process), see problem 4[href=https://www.wicell.org#sec6.7].\nManually curate the spike clusters by visual inspection.\nPlot all the spikes in a cluster.\nExamine by visual inspection looking for spike clusters that are highly variable that made it through the previous step and remove those that are noisy or artifactual.\nRemove clearly artifactual spike clusters are those that appear with more than three peaks (multi-phasic) or are otherwise very “jagged”.\nRemove spike clusters that clearly show several distinct spike shapes. This indicates that the cluster is multi-unit.\nRemove spike clusters that show a large amount of variance in shape as this may be an artifact of drift.\nNote: If using multi-channel spikes high-density silicon probes, it’s important to visually examine all channels and not just the channel with maximum amplitude. These probes are delicate instruments and often certain channels can go dead producing extremely noisy or no signal. These spike clusters too should be rejected.\nOnce satisfied with curation, each spike cluster should be averaged to produce an average single-unit waveform.\nNormalizing the dataset\nTiming: 5 min",
    "Average waveform shape is more informative than amplitude for relating spikes to cell types. This is because as the distance increases between the recording electrode and the site of spike origination, waveform amplitude decreases18[href=https://www.wicell.org#bib18] and is a confound when attempting to identify cell types in extracellular settings. When waveforms are not normalized, UMAP attempts to explain the large differences in amplitude over more subtle differences in shape; this results in projected structures organized by amplitude only (see Figure 3[href=https://www.wicell.org#fig3]). Thus, it is usually necessary to individually normalize average waveforms to expose relevant waveform shape information to WaveMAP. One notable exception to this is in certain ex vivo settings, such as juxtacellular recordings, in which the recording distance can be minimized by advancing the probe onto the cell.\nLoad the averaged single unit waveforms into a Numpy array.\nNote: Each waveform should occupy a row with each column a time point. We provide a sample set of normalized average waveforms at https://github.com/EricKenjiLee/WaveMAP_Paper/full_data.npy[href=https://github.com/EricKenjiLee/WaveMAP_Paper/full_data.npy]. To use this, simply download it from the repository and change the path in the code appropriately. If you have your own waveforms, no particular file format is required: data simply must be converted into a Numpy array and assigned as the unnormWFs variable. MATLAB arrays can be converted with Scipy’s loadmat function; R data frames (as Rdata files) can be read into Python as well with the PyReadr package.\nApply mean subtraction to every waveform.\nNormalize the array by dividing each value by the maximum value in each row.\nimport numpy as np\nimport sklearn.preprocessing\nunnormWFs = np.load([path to averaged waveforms])\nmeanSubWFs = unnormWFs.T - np.mean(unnormWFs,axis=1)\nnormWFs = sklearn.preprocessing.normalize(meanSubWFs, norm = 'max')",
    "Note: With high-density probes, single unit waveforms appear across many channels; this “multi-channel average waveform” has been shown to be even more informative than waveforms collected over a single channel as morpho-electric features of the neuron can be detected19[href=https://www.wicell.org#bib19] such as back-propagating action potentials.16[href=https://www.wicell.org#bib16] In this case, we’ve instead located the channel with maximum amplitude and normalized waveforms on other channels to that maximum value. The multi-channel waveform can simply be the concatenation of each channel’s waveform into one long trace as has been used by others.7[href=https://www.wicell.org#bib7] We typically select a small, fixed number of channels to use for each multi-channel waveform (five channels above and below the maximum amplitude channel). For many spatially “small” units, several channels will yield no spikes and thus be zero.\nSet random seeds for dependencies\nTiming: <5 min\nMany of the algorithms used in WaveMAP (e.g., UMAP and Louvain clustering) use stochastic methods or random initialization to compute their solutions. While this is useful from a performance standpoint, it can result in slight differences in results between runs of the same code. If exact reproducibility is preferred, it is recommended to specify a fixed random seed to each possible stochastic algorithm that may be used by WaveMAP or its dependencies i.e., fixing UMAP itself, Python’s built-in package “random”, and Numpy’s intrinsic seed.\nAssign a random seed for NumPy, the Python operating system module, and the built-in “random” module.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/2705-Fig4.jpg\nFigure 4. Output plots of applying WaveMAP to average waveforms from primate dorsal premotor cortex\n(A) WaveMAP applied to normalized average single-unit waveforms from Lee et al. 2021.1[href=https://www.wicell.org#bib1] Units are in the UMAP projected space and colored by their Louvain cluster membership.\n(B) Normalized average single-unit waveforms from (A) and colored by their Louvain cluster membership.",
    "(C, top) The same visualization as in (A) but with a grid of test points (small x’s) overlaid on the embedded space. (C, bottom) Waveforms predicted at each test point in (C, top) using UMAP’s inverse transformation function which itself uses Delaunay triangulation. Waveforms are colored by their Louvain cluster membership with gray waveforms not occurring near or within a cluster in the embedding. Waveforms far from clusters incur artifactual noise as there is no real data to constrain predictions.\n(D) Mean absolute SHAP (SHapley Additive exPlanations) values (a measure of feature importance) for each time point along the waveform (called a “feature” and numbered in order). Each mean absolute SHAP value is composed of SHAP value contributions from each of the Louvain clusters colored as stacked bars.\nfrom wavemap_paper.helper_functions import RAND_STATE, set_rand_state\nset_rand_state(RAND_STATE)\nNote: Although algorithms like UMAP can produce different projections, they pick up on consistent underlying structure in a generalized sense (see Lee et al.,1[href=https://www.wicell.org#bib1] Figure 4[href=https://www.wicell.org#fig4], Supp. 1). To make UMAP deterministic in its projection, we also pick an additional internal seed when initializing the UMAP object (done in the next section).\nConstruct a high-dimensional graph of the dataset with UMAP and cluster with Louvain clustering\nTiming: <5 min\nCentral to the WaveMAP approach is Uniform Manifold Approximation and Projection (UMAP). This non-linear dimensionality reduction method proceeds in two stages: First, it constructs a graph-representation of the dataset and. Second, it projects the data into a lower dimension. We will use the first stage for this step.\nInitialize a UMAP object.\nPass the normalized waveform array, normWFs, into UMAP.\nfrom umap import umap_ as umap\nreducer = umap.UMAP(random_state = RAND_STATE, n_neighbors = 15)\nmapper = reducer.fit(normWFs)",
    "Note: UMAP has many possible parameters that can be set within umap.UMAP() but the most important is the n_neighbors parameter which controls the balance between preserving the local vs. global information: low values will look at highly-local neighborhoods and larger values will look at more data points. Generally, a value of 15 is a good balance between local and global structure.2[href=https://www.wicell.org#bib2] The tradeoff is that using smaller values (looking more locally) will preserve local features better but may produce structure from local noise; using larger values will be more robust to local noise but may lose local structure. It is generally a good idea to try a range of values and to evaluate which produces the most consistent structure.\nGet the high-dimensional UMAP graph.\nimport networkx as nx\nG = nx.from_scipy_sparse_array(mapper.graph_)\nApply Louvain clustering to the graph.\nimport cylouvain\nclustering = cylouvain.best_partition(G, resolution = 2)\nclustering_solution = list(clustering.values())\nNote: Louvain has a resolution parameter within cylouvain.best_partition(G, resolution = N) that implicitly sets the expected number of clusters. Smaller resolution parameters result in larger numbers of clusters while larger resolution results in fewer. One way to set this parameter is to maximize the modularity score while jointly minimizing the number of clusters see Figure 4[href=https://www.wicell.org#fig4] of.1[href=https://www.wicell.org#bib1] Using this strategy, we arrived at a value of 2 but this can be changed by the user. While we use Louvain, other methods obviate selection of a resolution parameter such as ensemble clustering on graphs ECG.20[href=https://www.wicell.org#bib20] There are yet other methods that offer more stability in clustering, such as Leiden clustering,21[href=https://www.wicell.org#bib21] but we’ve found both of these to find equivalent clusters in at least the datasets we evaluated.\nVisualize the graph clusters in the UMAP-embedded space.\nimport pandas as pd\nfrom matplotlib import cm\nfrom matplotlib import pyplot as plt\nembedding = reducer.fit_transform(normWFs)",
    "umap_df = pd.DataFrame(embedding, columns=('x', 'y'))\numap_df['waveform'] = list(normWFs)\numap_df['cluster_id'] = clustering_solution\ncmap = plt.get_cmap(\"turbo\")\ncolors = cmap(np.linspace(0, 1, len(set(clustering_solution))))\numap_df['cluster_color'] = [colors[i] for i in clustering_solution]\nplt.scatter(umap_df['x'].tolist(), umap_df['y'].tolist(),\nmarker='o', c=umap_df['cluster_id'].tolist(), cmap='turbo')\nExamine all waveforms at once colored according to cluster. This will help generate a better understanding of how the data were clustered.\nf,arr = plt.subplots(1)\nfor i,row in enumerate(umap_df['waveform'].tolist()):\narr.plot(umap_df['waveform'].tolist()[i],c=umap_df['cluster_color'].tolist()[i],alpha=0.5)\nIf desired, these waveforms, WaveMAP cluster membership, and positions in UMAP’s embedding can be saved as a CSV file and loaded in another workspace.\numap_df.to_csv(‘umap_df.csv’)\nCritical: Before proceeding to the next steps, it is crucial to verify that visible structure is not due to what are called “batch effects” which are well-known in the genomics/transcriptomics literature22[href=https://www.wicell.org#bib22] but less so in neuroscience. These are artifactual structures in dimensionality-reduced data due to procedural differences unrelated to the phenomena of interest. In extracellular spiking data, this can arise from the application of different frequency filters in the same dataset,23[href=https://www.wicell.org#bib23] data from different brain areas,16[href=https://www.wicell.org#bib16] or even differences in bath temperature during ex vivo electrophysiology.24[href=https://www.wicell.org#bib24] A simple yet effective method to detect these differences is to recolor each data point in the UMAP projection instead by some other criterion e.g., experiment day, animal, probe ID, or even by the experimentalist who collected the data. If colors tend to segregate in the UMAP projection and are not randomly interspersed, there may be a batch effect present, and the initial dataset should be revisited before proceeding with further analyses. This approach is especially important given the proliferation of multi-lab collaborations and ever larger datasets collected by teams of scientists rather than individuals.\nValidate putative cell types by comparing physiological, functional, and laminar differences between clusters",
    "The existence of clusters alone does not guarantee any relationship to underlying cell types. Our approach to build more confidence that WaveMAP clusters map onto “real” types is to examine if different clusters have distinct physiological, functional, and laminar distribution properties. In certain cases (either ex vivo experiments or with optogenetic tools), ground truth can be obtained directly and used to validate that clusters correspond to underlying cell type. Here we outline how we investigated these differences as in Lee et al.1[href=https://www.wicell.org#bib1] but this will vary depending on each user’s scientific questions.\nCompare physiological differences between clusters\nExamine firing rate differences.\nCalculate instantaneous firing rate across trials by binning the number of spikes in a short time window; we use 100 ms bins on spike time rasters collected at 30,000 Hz.\nCalculate both the maximum, median, and range of firing rates for each unit per cluster.\nStatistically compare the distributions of each cluster using various parametric and nonparametric approaches.\nCompare functional differences between clusters.\nGenerate peri-stimulus time histograms.\nAverage firing rates unit-by-unit across trials but between trial outcomes (e.g., success or failure; one choice vs. another).\nCalculate unit tunings by aligning to different trial events and comparing their firing rate differences.\nNote: While physiological properties of neurons (e.g., mean or max firing rate; ISI distribution) can be calculated similarly in most any setting, functional properties (e.g., response latency to stimuli) will be dependent on the particular behavioral experiment being done and the dynamics of interest. Thus, metrics to calculate are guided by the question of interest. For instance, Jia et al.16[href=https://www.wicell.org#bib16] used the latency between depolarization troughs in multi-channel waveforms to identify back-propagating action potentials (BAPs); Carr et al.25[href=https://www.wicell.org#bib25] use the cross-correlograms between WaveMAP clusters to identify putative microcircuits in macaque visual cortex.\nCompare differences in laminar distribution.",
    "Calculate the depth or layer distribution of each recorded cell to generate a histogram.\nStatistically compare the laminar distributions between clusters.\nNote: For estimating laminar distributions without histology, a laminar multi-contact probe must be used for recordings. It should be advanced into the tissue perpendicular to the cortical layers / such that the superficial most electrode can be placed near the cortical surface demarcated by a shift in neural activity during the insertion.1[href=https://www.wicell.org#bib1] Given the probe’s geometry, cell depths can be estimated. For the localization of cortical layers, current source density (CSD) or local field potentials (LFPs) can be used to estimate layers 2/3 and 5/6.26[href=https://www.wicell.org#bib26]\nUse interpretable machine learning (inverse UMAP transformation and SHAP) to investigate global trends and inter-cluster differences (optional)\nTiming: ∼1 h\nUnsupervised machine learning methods like UMAP and Louvain can often seem like black boxes in that it is not always clear what they are attending to with regards to features. To uncover this, we leverage interpretable machine learning to probe the global embedded space and highlight what waveform features best differentiate clusters from one another. For convenience, plotting functions for these next steps are imported from the WaveMAP package but more flexibility is desired, see problem 5[href=https://www.wicell.org#sec6.9].\nPlot predicted waveforms generated at test points in the embedded space.\nfrom wavemap_paper.helper_functions import plot_inverse_mapping\nplot_inverse_mapping(reducer, umap_df)\nUse SHAP to find key differences between waveform clusters.\nTrain a decision tree classifier in XGBoost to distinguish waveforms based on their cluster identity.\nCreate a test-train split and train a decision tree classifier in XGBoost.\nTrain the classifier on the training set.\nfrom wavemap_paper.helper_functions import train_gridsearch_classifier\numap_model, conf_mat = train_gridsearch_classifier(umap_df)\nEvaluate the classifier’s performance on the test dataset (optional).\nfrom wavemap_paper.helper_functions import plot_confusion_matrix\nplot_confusion_matrix(conf_mat,umap_df)\nInterpret the trained classifier with SHAP.\nPass the trained decision tree classifier into TreeSHAP.",
    "import shap\nimport xgboost as xgb\nxgbModel = xgb.XGBClassifier(umap_model.best_params_)\nxgbModel.fit(umap_df['waveform'].tolist(),umap_df['cluster_id'].tolist())\nexplainer = shap.TreeExplainer(xgbModel)\nGenerate an explanation of the most important features for differentiating certain waveform clusters using TreeExplainer.27[href=https://www.wicell.org#bib27]\nimport matplotlib as mpl\numap_cmap = mpl.colors.ListedColormap(colors, name='umap_cmap')\nshap_values = explainer.shap_values(umap_df['waveform'].tolist())\nshap.summary_plot(shap_values, color = umap_cmap)\nNote: In TreeExplainer, SHAP will rank the features that are the most important overall (length of the bar) broken down into how informative they are for individual clusters (the size of each colored sub-bar; Figure 4[href=https://www.wicell.org#fig4]D). The features here are the different time points along the waveform ordered from first to last. This will help point the experimenter to positions along the waveform that may be of interest when it comes to identifying putative cell types."
  ],
  "subjectAreas": [
    "Behavior",
    "Cognitive Neuroscience"
  ],
  "bigAreas": [
    "Ecology & Environmental Biology"
  ]
}