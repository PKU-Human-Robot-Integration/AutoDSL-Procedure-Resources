{
  "id": 1921,
  "origin_website": "Cell",
  "title": "Protocol for activity flow mapping of neurocognitive computations using the Brain Activity Flow Toolbox",
  "procedures": [
    "Step-by-step method details\nStep-by-step method details\nPart 1: Install the Brain Activity Flow Toolbox\nTiming: 1–5 min\nInstallation of the Actflow Toolbox includes cloning (or downloading) the package from GitHub. Software development guidelines and example usage can be found at https://github.com/ColeLab/ActflowToolbox[href=https://github.com/ColeLab/ActflowToolbox]. We recommend using Git via the command line interface (which requires an internet connection).\nIf not already installed, install Git by following the directions provided at https://git-scm.com/downloads[href=https://git-scm.com/downloads].\nOpen the command line interface (e.g., Terminal application in macOS) and navigate to the appropriate directory:\n>cd ∼/research_project_directory/\nInstall Actflow Toolbox with Git:\n>git clone --recurse-submodules https://github.com/ColeLab/ActflowToolbox.git[href=https://github.com/ColeLab/ActflowToolbox.git]\nPart 2: Estimate connectivity\nTiming: 5–30 min\nThis section describes how to estimate FC with the methods provided by the Actflow Toolbox. Brain connectivity is pivotal to the activity flow mapping procedure because it specifies (via estimated connectivity weights) how activity flowing over interacting brain regions contributes to a held out regions’ task activity (Cole et al., 2016[href=https://www.wicell.org#bib5]). Importantly, this builds upon the principle that connectivity is used to transfer information in the brain via activity flow processes (Ito et al., 2020b[href=https://www.wicell.org#bib16]). We focus on the combinedFC (Sanchez-Romero and Cole 2021[href=https://www.wicell.org#bib34]; see key resources table[href=https://www.wicell.org#key-resources-table]) estimation method as this is our current recommended best practice. The toolbox also contains the following options for FC estimation (most of which are detailed elsewhere throughout this protocol): Pearson correlation (corrcoefconn.py), multiple linear regression (multregconn.py), partial correlation (partial_corrconn.py), and principal component regression (pc_multregconn.py). In the following demonstrations we focus on resting-state FC but provide considerations for alternatively utilizing task-state FC. Further, it is worth noting that the connectivity estimate utilized in activity flow mapping does not need to be FC. For example, structural connectivity can be used (see expected outcomes[href=https://www.wicell.org#sec3.5] for current examples in the literature).",
    "Load data: in a Python compatible text editor (e.g., Atom), integrated development environment (e.g., PyCharm), or development package (e.g., Jupyter Notebook) that sources the same parent directory as /Actflowtoolbox/, load task activation data (Figure 1[href=https://www.wicell.org#fig1]C) and data to be used in connectivity estimation (see before you begin[href=https://www.wicell.org#before-you-begin] for formatting) (Figure 1[href=https://www.wicell.org#fig1]D).\nThe following code block example loads a subset of N = 30 subject’s data from the HCP S1200 release (see key resources table[href=https://www.wicell.org#key-resources-table]), which can be found in the example notebook included in the Actflow Toolbox (see key resources table[href=https://www.wicell.org#key-resources-table]).\nFurther, throughout this protocol we used the multimodal parcellation (MMP) developed by Glasser et al. (2016)[href=https://www.wicell.org#bib10] to define 180 cortical regions per hemisphere (360 total) (black outlines in Figure 1[href=https://www.wicell.org#fig1]A). Minimally preprocessed versions of this data and registration details are publicly available at https://www.humanconnectome.org/[href=https://www.humanconnectome.org/] (as well as detailed in Glasser et al., 2013[href=https://www.wicell.org#bib11]; see key resources table[href=https://www.wicell.org#key-resources-table]).\nNote: It is worth noting that the core usage of the Actflow Toolbox does not strictly require data to be organized per this parcellation scheme. The only requirement is that the data inputs are formatted as described in the before you begin[href=https://www.wicell.org#before-you-begin] section. As described, a node can be at the level of parcels, regions (defined by the atlas of the user’s choice), voxels, or vertices; activity flow mapping results will be returned at the same level.\nNote: The import lines in the corresponding code block specify all modules needed throughout all demonstration code blocks used in this protocol.\n# Load example data from ∼/HCP_example.ipynb\nimport pkg_resources\nimport sys\nimport numpy as np\nimport h5py\nfrom scipy import stats\nimport time\nimport sklearn\nfrom sklearn.linear_model import LinearRegression\nimport math as math\nimport statsmodels.api as sm\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\nimport seaborn as sns\nimport wbplot",
    "from wbplot import pscalar\nimport ActflowToolbox as actflow\nimport ActflowToolbox.connectivity_estimation as fc\n# Instantiate variables\nactflow_dir = pkg_resources.resource_filename(\n  \"ActflowToolbox.examples\", \"HCP_example_data/\"\n)\nsubj_nums = [\"100206\", \"108020\", \"117930\", \"126325\", \"133928\", \"143224\", \"153934\", \"164636\", \"174437\", \"183034\", \"194443\", \"204521\", \"212823\", \"268749\", \"322224\", \"385450\", \"463040\", \"529953\", \"587664\", \"656253\", \"731140\", \"814548\", \"877269\", \"978578\", \"100408\", \"108222\", \"118124\", \"126426\", \"134021\", \"144832\"]\nn_trs = 1195\n# Load task activations (GLM betas); 360 MMP regions x 24 HCP tasks x 30 HCP subjects\nfile_path = actflow_dir + \"HCP_example_taskactivations_data\" + \".h5\"\nh5f = h5py.File(file_path, \"r\")\nactivity_data = h5f[\"taskbeta\"][:]\nh5f.close()\nn_nodes, n_conditions, n_subjs = activity_data.shape\n# Load resting-state fMRI data: 360 MMP regions x one run of resting-state fMRI (1195 time points) x 30 HCP subjects\nrest_data = np.zeros((n_nodes, n_trs, n_subjs))\nfor subj_ix in range(n_subjs):\n  file_path = (\n    actflow_dir + \"HCP_example_restrun1_subj\" + subj_nums[subj_ix] + \"_data\" + \".h5\"\n  )\n  h5f = h5py.File(file_path, \"r\")\n  rest_data[:, :, subj_ix] = h5f[\"restdata\"][:]\n  h5f.close()\nNote: The corresponding code block demonstrates how to load the entire example dataset provided by the Actflow Toolbox, however the data files can be found in the cloned ActflowToolbox directory within the following path: /ActflowToolbox/examples/HCP_example_data/. A single participant’s resting-state data file is named as follows: HCP_example_restrun1_subj<######>_data.h5 (where <######> is replaced by one of the participant codes listed in the variable in the corresponding code block called <subj_nums>). Participants’ task activation data is concatenated in the array inside HCP_example_taskactivations_data.h5. The corresponding code block demonstrates how to extract relevant data from ∗.h5 files.",
    "Optional: Avoid potential circularity due to spatial smoothness by excluding source vertices that are 10 mm from the target node border (see before you begin[href=https://www.wicell.org#before-you-begin] for background) (Figure 2[href=https://www.wicell.org#fig2]). In the present protocol, target nodes refer to the iteratively held-out brain regions (or parcels, vertices, or voxels) (Figure 2[href=https://www.wicell.org#fig2] black region) whose task activations are predicted based on modeled contributions from source nodes, which are all other brain regions (excluding the target). For example: if there are 360 regions in total, the first iteration to predict task activations in target region one will hold out region one and use data from source regions two through 360 (359 sources in total) to make the prediction. This is iterated over all 360 target regions. The details of this procedure are described at-length in Part 3, where actflowtest is implemented. Target and source regions can be spatially contiguous, which can potentially raise concerns regarding spatial autocorrelation. To address this, we have added an (optional) step in the iterative process just described that excludes (or masks) vertices 10 mm outside of each target region’s border (Figure 2[href=https://www.wicell.org#fig2] green vertices) from being part of the source set. That is, contiguous source regions’ data will exclude data from vertices in this mask. This effectively adds a 10 mm “buffer” between a given target and all of its contiguous sources. The Actflow Toolbox has built-in functionality to perform this 10 mm masking procedure on fMRI data using the MMP atlas (Glasser et al., 2016[href=https://www.wicell.org#bib10]) (Figure 2[href=https://www.wicell.org#fig2]). We recommend the HCP minimal preprocessing pipeline (Glasser et al., 2013[href=https://www.wicell.org#bib11]; see key resources table[href=https://www.wicell.org#key-resources-table]) (in addition to our other nuisance regression recommendations in before you begin[href=https://www.wicell.",
    "org#before-you-begin]), as it yields time series data resampled and aligned onto common cortical surface vertices and subcortical voxels, which are more generally referred to as “grayordinates” (note that the data demonstrated in this protocol is from the cortical surface only). Accordingly, we used the MMP atlas because it was developed with HCP grayordinates and vertex-to-region correspondence is readily identifiable (from a parcellation that underwent robust validation testing; see Glasser et al., 2016[href=https://www.wicell.org#bib10] for details). Currently only 10 mm masks are available in this step. Additionally, this requires the node dimension of input data to be composed of vertices. This can be implemented for both task activation data and connectivity estimation, as follows:",
    "# Exclude source vertices 10 mm from target nodes to avoid circularity\n# Using preloaded vertex-wise data: activity_data_vertex and rest_data_vertex\n# Non-circular task activations\nactivity_data_noncirc = np.zeros((n_nodes, n_conditions, n_subjs))\nfor subj_ix in range(n_subjs):\n    activity_data_here = activity_data_vertex[:, :, subj_ix]\n    activity_data_noncirc_all = fc.calcactivity_parcelwise_noncircular(\n        activity_data_here\n    )\n    for node_ix in range(n_nodes):\n        for cond_ix in range(n_conditions):\n            extracted_data = activity_data_noncirc_all[node_ix, node_ix, cond_ix]\n            activity_data_noncirc[node_ix, cond_ix, subj_ix] = extracted_data.copy()\n# Non-circular resting-state FC\nfc_arr_noncirc = np.zeros((n_nodes, n_nodes, n_subjs))\nfor subj_ix in range(n_subjs):\n    rest_data_here = rest_data_vertex[:, :, subj_ix]\n    # Can specify connmethod = \"combinedFC\" here\n    fc_arr_noncirc[:, :, subj_ix] = fc.calcconn_parcelwise_noncircular(rest_data_here)",
    "Note: The foregoing procedure to exclude source vertices 10 mm from the target border may require 30 min - 1 h of computational time, depending on the input data dimensions (e.g., how many subjects), as well as the computational environment’s capabilities. For reference, we ran the last code block on a compute node on Rutgers University’s Amarel high performance computing cluster (see here for specifications: https://oarc.rutgers.edu/resources/amarel/[href=https://oarc.rutgers.edu/resources/amarel/]) to gauge run times. The data utilized had the following dimensions: <activity_data_vertex> was of shape 59412 vertices by 24 conditions by 30 subjects; <rest_data_vertex> was of shape 59412 vertices by 1195 time points by 30 subjects. The resting-state array was approximately 17 GB, whereas the task activity array was only 0.3 GB. The portion annotated with “Non-circular task activations” took approximately 8 min and the portion annotated with “Non-circular resting-state FC” took approximately 27 min. Altogether these processes used approximately 68% of 20 requested cores per node and 26% of 64 GB requested memory. However, these workload specifications relate to the size of vertex-level input data rather than the Actflow Toolbox functions, and should serve as a reference rather than a recommendation. Users that maintain vertex-level data and are interested in applying the above analysis steps should implement data management practices most suitable to their pipelines and computational environments.\nThe following are additional parameter options available when implementing calcactivity_parcelwise_noncircular (Figure 2[href=https://www.wicell.org#fig2], Step 3a), but are set to defaults in the corresponding code block:",
    "dlabelfile: This is a string indicating the parcellation reference file. We have provided a default dlabel file in-function. For each vertex it lists the corresponding region number in the MMP atlas (Glasser et al., 2016[href=https://www.wicell.org#bib10]). While use of the optional step here (applying a 10 mm dilated mask to source vertices) is currently based upon the MMP atlas, this parameter is available as an input in case the load method fails, users may specify this file path directly. We have outlined this use case in troubleshooting: problem 4[href=https://www.wicell.org#sec6.7]. This file is a ∗dlabel.nii, which is CIFTI-2 formatted and readable by most neuroimaging software. We recommend the following resource for more information on CIFTI files: https://wiki.humanconnectome.org/display/PublicData/HCP+Users+FAQ[href=https://wiki.humanconnectome.org/display/PublicData/HCP+Users+FAQ].\ncortex_only: This is a Boolean that can be set to either True or False. The default is True, which indicates to assess only cortical regions. If False, both cortical and subcortical regions will be assessed.\nverbose: This is a Boolean that is set to False by default. If True, the user will see printed output that tracks the progress of the function.\nThe following are additional parameter options available when implementing calcconn_parcelwise_noncircular (Figure 2[href=https://www.wicell.org#fig2], Step 3b), but are set to defaults in the corresponding code block:\nconnmethod: This is a string that indicates which functional connectivity estimation method to use. The options are: ‘multreg’ (default) (multiple linear regression), ‘pearsoncorr’ (Pearson correlation), ‘pc_multregconn’ (principal components regression), and ‘combinedFC’ (Sanchez-Romero and Cole, 2021[href=https://www.wicell.org#bib34]).\ndlabelfile: The same as listed above for calcactivity_parcelwise_noncircular.\nprecomputedRegularTS: This is an optional input parameter that is set to None by default. If provided, it should be an array of the mean time series of the original set of regions (i.e., pre-masking) that has the same dimensions as the input variable <data> (i.e., <rest_data> in the corresponding example code block).",
    "cortex_only: The same as listed above for calcactivity_parcelwise_noncircular.\nverbose: The same as listed above for calcactivity_parcelwise_noncircular.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1403-Fig1.jpg\nFigure 1. Loaded data, HCP S1200 example\n(A) Cortical schematic of the Cole-Anticevic Brain-Wide Network Partition (CAB-NP) and its 12 functional networks from Ji et al. (2019)[href=https://www.wicell.org#bib18], reproduced with permission. In select portions of this protocol, cortical regions were ordered by these networks (see y-axes in panels C and D). This corresponds to the variable <netorder> used in select code blocks.\n(B) The seven cognitive domains (totaling 24 conditions) sampled in the HCP S1200 task fMRI dataset (Barch et al., 2013[href=https://www.wicell.org#bib1]). These correspond to the x-axis in panel C and the second dimension of the input variable <activity_data>.\n(C) Task-evoked activation patterns across 24 task conditions (mean across N = 30 subjects). This was the data contained in the input variable <activity_data>, which was used throughout the protocol, and constitutes the comparison reference for prediction accuracy statistics.\n(D) The data utilized for connectivity estimation (mean across N=30 subjects) - which was the resting-state time series for 1 run (used to estimate rest FC) - in the examples used throughout this protocol. This corresponds to the input variable <rest_data>.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1403-Fig2.jpg\nFigure 2. Optional step to avoid circularity due to spatial autocorrelation",
    "All steps are performed iteratively, for each target region. Step 1: Identify the to-be-predicted, held-out target region on the MMP atlas surface. The example target region shown (black) is the left hemisphere area PGi (Glasser et al., 2016[href=https://www.wicell.org#bib10]). Note that all steps are performed for each target region, including right hemisphere regions. The left hemisphere lateral surface is solely visualized for simplicity. Step 2: Use the HCP workbench command -cifti-dilate (https://www.humanconnectome.org/software/workbench-command/[href=https://www.humanconnectome.org/software/workbench-command/]) to identify source region vertices (also termed grayordinates) that are 10 mm outside the given target region’s border (green). Steps 1 and 2 are already computed across all target/source node sets, and the resulting masks are built into the Actflow Toolbox. Step 3a: Exclude the source vertices identified in Step 2 from the computation of source regions’ task-evoked activations for a given task condition (example task condition “working memory 2-back: body” is shown). This is performed by calcactivity_parcelwise_noncircular. In this step, a source regions’ activity is computed by taking the average of all included source vertices belonging to that source region. Step 3b: Exclude the source vertices identified in Step 2 from the estimation of FC with the target region. This is performed by calcconn_parcelwise_noncircular. The results of Steps 3a and 3b can be used as inputs into actflowtest, which is detailed in the step-by-step method details[href=https://www.wicell.org#step-by-step-method-details]: Part 3.\nContinuing in the same editor, environment, or notebook, continue on the next line with the following code to estimate connectivity.\nNote: This example computes resting-state FC with the combinedFC (Sanchez-Romero and Cole, 2021[href=https://www.wicell.org#bib34]) method, as our current recommended best practice (Figure 3[href=https://www.wicell.org#fig3]A). The Actflow Toolbox provides a variety of FC estimation methods; see extended example usage at https://github.com/ColeLab/ActflowToolbox/blob/master/examples/HCP_example.ipynb[href=https://github.com/ColeLab/ActflowToolbox/blob/master/examples/HCP_example.ipynb], which can be applied to either resting-state or task-state data.",
    "Note: This assumes <rest_data> has been formatted per before you begin[href=https://www.wicell.org#before-you-begin] recommendations: in a NumPy array of shape nodes by TR by subject (note the for-loop iterates over subjects).\n# Estimate resting-state functional connectivity with combinedFC\nn_nodes, n_trs, n_subjs = rest_data.shape\nfc_arr = np.zeros((n_nodes, n_nodes, n_subjs))\nfor subj_ix in range(n_subjs):\n    net_mask = fc.combinedFC(rest_data[:, :, subj_ix])\n    fc_arr[:, :, subj_ix] = fc.multregconn(\n        rest_data[:, :, subj_ix], conn_mask=(net_mask != 0)\n    )\nThe following are additional parameter options available when implementing combinedFC (see Sanchez-Romero and Cole, 2021[href=https://www.wicell.org#bib34] for more details), but are set to defaults in the corresponding code block:\ntarget_ts: This is an optional parameter set to None by default. This is recommended for two use cases: (1) When the user wants to estimate connectivity for only one target node (with all other source nodes). This should contain the target node’s time series, or, a one dimensional vector of activity across time points. Connectivity will be compared to each source node’s time series in the <dataset> input (e.g., <rest_data> in the corresponding code block), and a one dimensional connectivity vector will be returned. (2) When calling the optional parameter of <conn_method=’combinedFC’> in the calcconn_parcelwise_noncircular function. The user does not need to change any inputs in this case because the calcconn_parcelwise_noncircular function has built-in handling when <conn_method=’combinedFC’>.\nparcelInt: This is an optional parameter set to None by default. This is also used by calcconn_parcelwise_noncircular when <conn_method=’combinedFC’> which also has built-in handling to manage this input. This input helps index the final connectivity network. If the user would like to use <target_ts> without calcconn_parcelwise_noncircular (e.g., has another use for separating the source and target node time series), then this is the indexing value of the target node. If there is only one target node, this can be set to 0.",
    "source_cols: This is an optional parameter set to None by default. This is the corresponding source node indexing information to <parcelInt> explained above. That is, calcconn_parcelwise_noncircular has built-in handling if <conn_method=’combinedFC’>. Otherwise, this is the indexing vector for the source nodes (with the target held out) in the final connectivity network. The following code block is a simple example of how this can be determined:\n# Determine the indices of source node columns for a given target node (parcelInt); to be used to index the final connectivity array\nparcelInt = 0\nnum_sources = 360\nsource_cols = np.arange(num_sources)\nsource_cols = np.delete(source_cols, parcelInt)\nmethodCondAsso: A string that determines which method to use to evaluate conditional associations (i.e., the first portion of the combinedFC procedure). The options are ‘partialCorrelation’ (default) or ‘multipleRegression’.\nmethodParcorr: A string that specifies how the partial correlation matrix is computed, and is thus only relevant when <methodCondAsso=’partialCorrelation’>. The options are ‘inverseCovariance’ (default) and ‘regression’.\nalphaCondAsso: A scalar that specifies the alpha significance cut-off for the conditional association evaluation. The default is 0.01.\nmethodAsso: A string specifying the method for the second procedure performed by combinedFC: testing whether edges should be included or excluded in the connectivity matrix (i.e., the unconditional association procedure). The options are ‘correlation’ (default) and ‘simpleRegression’.\nalphaAsso: A scalar that specifies the alpha significance cut-off for the unconditional association evaluation. The default is 0.01.\nequivalenceTestAsso: A Boolean that is set to False by default. If set to True, the unconditional association procedure will be performed via equivalence testing. When False, two-sided null hypothesis testing will be performed.\nlower_bound: A scalar that specifies the negative bound for the minimum r value of interest in the equivalence test. The default value is -0.1.",
    "upper_bound: A scalar that specifies the positive bound for the minimum r value of interest in the equivalence test. The default value is +0.1.\nThe following are additional parameter options available when implementing multregconn:\ntarget_ts: This is an optional parameter set to None by default. This is recommended for two use cases: (1) When the user wants to estimate connectivity for only one target node (with all other source nodes). This should contain the target node’s time series, or, a one dimensional vector of activity across time points. Connectivity will be compared to each source node’s time series in the <activity_matrix> input (e.g., <rest_data> in the corresponding code block), and a one dimensional connectivity vector will be returned. (2) When calling the optional parameter of <conn_method=’multreg’> in the calcconn_parcelwise_noncircular function. The user does not need to change any inputs in this case because the calcconn_parcelwise_noncircular function has built-in handling when <conn_method=’multreg’>.\nparcelstoexclude_bytarget: This is an optional parameter set to None by default. This can be a dictionary of lists, where each list includes source regions to exclude for each target parcel. This is not used when <target_ts> is set, and thus not used by calcconn_parcelwise_noncircular. This can be used when there are specific source regions (the entire region) that should be held out from connectivity estimation.",
    "conn_mask: This is an optional parameter set to None by default. This is mainly used when calling multregconn after combinedFC (as in the corresponding code block), and specifies a mask to exclude some connections from being fit in the multiple regression procedure by setting them to zero. This should be an array that matches the dimensions of the output <fc_arr> consisting of ones and zeros: ones indicate a connection and zeros indicate no connection. If <target_ts> is set, the dimensions of <conn_mask> should be the number of nodes in the original <activity_matrix> (i.e., <rest_data> in the corresponding code block) by one.\nAlternatives: Estimate FC with task-state data (see before you begin[href=https://www.wicell.org#before-you-begin] for recommendations and data formatting details) (Figure 3[href=https://www.wicell.org#fig3]B).\n# Estimate task-state functional connectivity with combinedFC\n# Note: this assumes each task condition contains the same number of time points. If this is not the case, a data dictionary may be used (instead of a 4D numpy array).\nn_nodes, n_trs, n_conditions, n_subjs = task_data.shape\nfc_arr = np.zeros((n_nodes, n_nodes, n_conditions, n_subjs))\nfor subj_ix in range(n_subjs):\n    for cond_ix in range(n_conditions):\n        net_mask = fc.combinedFC(task_data[:, :, cond_ix, subj_ix])\n        fc_arr[:, :, cond_ix, subj_ix] = fc.multregconn(\n            task_data[:, :, cond_ix, subj_ix], conn_mask=(net_mask != 0)\n        )\nOptional: Visualize the connectivity matrix with regions sorted along the x- and y-axes per the MMP (Glasser et al., 2016[href=https://www.wicell.org#bib10]) and CAB-NP (Ji et al., 2019[href=https://www.wicell.org#bib18]), per the following code (resting-state FC example):\n# Cole-Anticevic Brain-Wide Network Partition (Ji et al., 2019) variables\nnetworkpartition_dir = pkg_resources.resource_filename(\n    \"ActflowToolbox.dependencies\", \"ColeAnticevicNetPartition/\"\n)\nnetworkdef = np.loadtxt(networkpartition_dir + \"/cortex_parcel_network_assignments.txt\")\nnetworkorder = np.asarray(sorted(range(len(networkdef)), key=lambda k: networkdef[k]))\nnetorder = networkorder.copy()\n# Visualize FC matrix with Toolbox function\nfc_mat = np.mean(fc_arr, axis=2)[netorder, :][:, netorder]\nfig = actflow.tools.addNetColors_Seaborn(fc_mat)\n# Note: fig can be used to save the figure as follows (change strings as appropriate):\nfig_directory = \"/my/figure/directory/here/\"",
    "fig_file_name = fig_directory + \"fc_matrix.png\"\nfig.savefig(fig_file_name, bbox_inches=\"tight\", format=\"png\", dpi=600)\nCritical: Timing depends on computational capabilities of a given system and/or environment. We recommend a test run to assess whether a high performance computing environment will be needed, or, if the analysis should be broken up into smaller groups. The following dimensions can become particularly large in select datasets: nodes (e.g., thousands of vertices), conditions (when estimating task-state FC), and/or subjects (e.g., N > 100). The following code modification can be used as a test run for n = 10 subjects:\n# Wrapping the time function around the code to assess computation time\nn_test_subjs = 10\nstart_time = time.time()\nn_nodes, n_trs, n_subjs = rest_data.shape\nfc_arr = np.zeros((n_nodes, n_nodes, n_subjs))\nfor subj_ix in range(n_test_subjs):\n    net_mask = fc.combinedFC(rest_data[:, :, subj_ix])\n    fc_arr[:, :, subj_ix] = fc.multregconn(\n        rest_data[:, :, subj_ix], conn_mask=(net_mask != 0)\n    )\nend_time = time.time()\nprint(\n    \"Computation time for \"\n    + str(n_test_subjs)\n    + \" subjects: \"\n    + str((end_time - start_time) / 60)\n    + \" minutes.\"\n)\nComputation time for 10 subjects: 0.08017793099085489 minutes.\nNote: This test of elapsed computational time was performed on the Rutgers University Amarel compute cluster (https://oarc.rutgers.edu/resources/amarel/[href=https://oarc.rutgers.edu/resources/amarel/]) on one compute node with 10 available cores and 64 GB available memory. We additionally ran the same code block on a local machine, which was a Macbook Pro with the following specifications: 2017 model with macOS Catalina 10.15.6, 2.3 GHz dual-core processor, and 16 GB of RAM. The elapsed time was approximately 0.09 min when running this code block in a Python-enabled terminal on that local machine.",
    "Note: As in Yan et al. (2021a)[href=https://www.wicell.org#bib40], structural connectivity may be used in place of FC. Further, alternate estimates of FC may be used, such as latent FC (as in: McCormick et al., 2021[href=https://www.wicell.org#bib25]). If using a brain connectivity estimate that is not covered by the Actflow Toolbox, this section (Part 2) can be substituted with project-specific code (or skipped if estimated outside of Python) and the resulting FC data array can be used in Part 3 as long as it follows the formatting convention of: nodes by nodes by subjects.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1403-Fig3.jpg\nFigure 3. Functional connectivity\n(A) The grand average (mean of N = 30 subjects resting-state connectivity matrix estimated via combinedFC) of 360 MMP cortical regions, ordered along each axis per the CAB-NP (see Figure 1[href=https://www.wicell.org#fig1]A). This represents the connectivity estimates used in this protocol for activity flow mapping.\n(B) The same as in panel A, but using task timeseries to estimate FC (mean across N = 30 subjects and all HCP tasks). The use of task-state FC in mapping cognitive computations was assessed in Cole et al., 2021[href=https://www.wicell.org#bib6].\nPart 3: Run actflowtest\nTiming: 2–10 min\nThis section provides instructions for running actflowtest, which is the main mapping procedure in the Actflow Toolbox. We also provide a look “under the hood” and describe the quantitative steps performed within actflowtest (depicted diagrammatically in Figure 4[href=https://www.wicell.org#fig4]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1403-Fig4.jpg\nFigure 4. Activity flow mapping procedure performed by actflowtest\n(A) Activity flow mapping toy diagram and corresponding formula (adapted from Cole et al., 2016[href=https://www.wicell.org#bib5] with permission). Task activity for the held out node, j (purple), is predicted by the sum of task activity of all other nodes, i (blue) (where n = total number of nodes), weighted by their connectivity estimates with j (grey).",
    "(B) Activity flow mapping procedure performed by actflowtest with the example HCP S1200 data (N = 30) used throughout this protocol. The computations inside actflowtest are numbered inside dark grey squares, as follows: [1] For held-out target region j, connectivity estimates between j and all other source regions are [2] multiplied by all other regions’ actual task activations (iterated per task). [3] The resulting activity flow map contains the task activations of all source regions weighted by their connectivity estimate with j. [4] Flow map values are summed to equal the predicted activity of j. [5] Computations 1–4 are iterated over all regions and all tasks, which produces a map of activity-flow predicted task activations across the brain. [6] Predicted activations are compared with actual activations via prediction accuracy indices (see expected outcomes[href=https://www.wicell.org#sec3.5]). Excluded source vertices (10 mm from the target region j; see before you begin[href=https://www.wicell.org#before-you-begin]; step-by-step method details[href=https://www.wicell.org#step-by-step-method-details] part 2; and Figure 2[href=https://www.wicell.org#fig2]) are masked in green.\nRun the main function of the toolbox, actflowtest.py, which can be continued from the code above. This is the activity flow mapping procedure (Figure 4[href=https://www.wicell.org#fig4]), which comes included with predicted-to-actual similarity assessment across multiple conditions and subjects. The following group-level statistics are returned to indicate prediction accuracy: Pearson r with t-testing, percent variance explained via the coefficient of determination, and the mean absolute error (see expected outcomes[href=https://www.wicell.org#sec3.5] for details on accuracy indices).\nNote: This assumes <activity_data> has been formatted per before you begin[href=https://www.wicell.org#before-you-begin] recommendations, or, in a NumPy array of shape nodes by conditions by subject (note that the last dimension is optional).\n# Activity flow mapping with resting-state FC estimated via combinedFC\nactflow_output = actflow.actflowcomp.actflowtest(activity_data, fc_arr)\nNote: By default actflowtest prints prediction accuracy results; see expected outcomes[href=https://www.wicell.org#sec3.5] for examples.",
    "The following are additional parameter options available when implementing actflowtest, but are set to defaults in the corresponding code block:\nactVect_group_test: This is an optional parameter set to None by default. This can be used to provide independent data to assess prediction accuracy. Some examples include separate runs or separate participants. The dimensions of this should match <actVect_group> (i.e., the variable <activity_data> in the corresponding code block).\nprint_by_condition: This is a Boolean set to True by default that directs the model_compare function to print the prediction accuracy statistics for each condition separately.\nfull_report: This is a Boolean set to False by default. If True, the model_compare function will assess prediction accuracy across multiple dimensions of the data. See expected outcomes[href=https://www.wicell.org#sec3.5] for a full explanation of these statistics.\nseparate_activations_bytarget: This is a Boolean set to False by default. If True, this indicates that the input <actVect_group> (i.e., the variable <activity_data> in the corresponding code block) has a single activation vector for the to-be-predicted target node (i.e., to perform activity flow mapping for individual target nodes) and will provide additional handling for this.\ntransfer_func: This is an optional parameter set to None by default, and accepts a string otherwise. If set, activity flow mapping will utilize a transfer function. The options are ‘linear’, ‘relu’, ‘sigmoid’, and ‘logit’. This will be applied to the activity of all other nodes (blue nodes in Figure 4[href=https://www.wicell.org#fig4]A; i.e., source nodes for a given target node) in the activity flow mapping procedure. Usage of a transfer function assumes that the target node’s time series is primarily driven by inputs (e.g., local field potentials), such that source time series need to be converted from inputs to outputs via a transfer function.",
    "avgthencomp_fixedeffects: This is a Boolean set to False by default. If True, the model_compare function will assess prediction accuracy after averaging across participants, which is sometimes referred to as a “fixed effects” analysis. We recommend analyses with participants as random effects (i.e., effects for each participant, which can be later averaged to assess group effects), and thus recommend keeping this False (but have included the option for specific use cases).\nExtract results from the <actflow_output> dictionary with the following code (continued from above):\n# Extract the predicted and actual activations\npredicted_activations_array = actflow_output[\"actPredVector_bytask_bysubj\"]\nactual_activations_array = actflow_output[\"actVect_actual_group\"]\nOptional: The following code can be used to extract prediction accuracy:\n# Optionally extract prediction accuracies to NumPy arrays\ncorrelations_full_model = actflow_output[\"model_compare_output\"][\n    \"fullcomp_compthenavg_output\"\n][\"corr_vals\"]\nexpl_variances_full_model = actflow_output[\"model_compare_output\"][\n    \"fullcomp_compthenavg_output\"\n][\"R2_vals\"]\nmaes_full_model = actflow_output[\"model_compare_output\"][\"fullcomp_compthenavg_output\"][\n    \"mae_vals\"\n]\ntstat_full_model = actflow_output[\"model_compare_output\"][\n    \"tval_ActflowPredAcc_fullcomp\"\n]\npval_full_model = actflow_output[\"model_compare_output\"][\"pval_ActflowPredAcc_fullcomp\"]\nOptional part 4: Visualize results\nTiming: 1–5 min\nOnce the activity flow mapping procedure is complete, there are a variety of approaches to visualizing results. Here we provide instructions to produce our recommended visualizations, focusing on comparing predicted task activations to actual task activations. Please note that depending on the research question and data, researchers may find the need to modify these figures, or utilize another figure type altogether (see expected outcomes[href=https://www.wicell.org#sec3.5] for an overview of the current literature implementing activity flow mapping).\nVisualize the predicted and actual activation patterns across all task conditions (Figure 5[href=https://www.wicell.org#fig5]).\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1403-Fig5.jpg\nFigure 5. Activity flow mapped task activations compared to actual task activations across all nodes and tasks\n(A) Predicted task activation patterns across 24 conditions and all MMP cortical regions, sorted into their CAB-NP functional network assignments (color coded per Figure 1[href=https://www.wicell.org#fig1]A) (mean of N=30 subjects).",
    "(B) The actual task activation patterns (as in Figure 1[href=https://www.wicell.org#fig1]C). The predicted activations exhibited high similarity to the actual activations (r = 0.81, R2 = 0.65, MAE = 6.83; see expected outcomes[href=https://www.wicell.org#sec3.5] for more on measuring accuracy).\n# Visualize predicted and actual task activation patterns across all nodes and tasks\n# HCP S1200: names of the 24 conditions (x-axis tick strings)\ntask_names = [\"EMOTION:fear\", \"EMOTION:neut\", \"GAMBLING:win\", \"GAMBLING:loss\", \"LANGUAGE:story\", \"LANGUAGE:math\", \"MOTOR:cue\", \"MOTOR:lf\", \"MOTOR:rf\", \"MOTOR:lh\", \"MOTOR:rh\", \"MOTOR:t\", \"REASONING:rel\", \"REASONING:match\", \"SOCIAL:mental\", \"SOCIAL:rnd\", \"WM 0bk:body\", \"WM 0bk:faces\", \"WM 0bk:places\", \"WM 0bk:tools\", \"WM 2bk:body\", \"WM 2bk:faces\", \"WM 2bk:places\", \"WM 2bk:tools\"]\n# Visualize activity-flow-predicted activation patterns across all 24 HCP S1200 conditions\nplt.figure(figsize=[7, 5])\nax = sns.heatmap(\n    np.mean(predicted_activations_array, axis=2)[netorder, :],\n    center=0,\n    cmap=\"seismic\",\n    cbar=True,\n    yticklabels=100,\n    xticklabels=task_names,\n)\nax.figure.suptitle(\"Predicted Task Activations (mean across subjects)\")\nax.set(ylabel=\"cortical regions\")\nplt.show()\n# Visualize actual (empirical) activation patterns across all 24 HCP S1200 conditions\nplt.figure(figsize=[7,5])\nax = sns.heatmap(\n    np.mean(actual_activations_array, axis=2)[netorder, :],\n    center=0,\n    cmap= \"seismic\",\n    cbar=True,\n    yticklabels=100,\n    xticklabels=task_names,\n)\nax.figure.suptitle(\"Actual Task Activations (mean across subjects)\")\nax.set(ylabel=\"cortical regions\")\nplt.show()\nVisualize the predicted and actual activation patterns for a select task condition, mapped onto a cortical brain schematic (Figure 6[href=https://www.wicell.org#fig6]). This uses wbplot (https://github.com/jbburt/wbplot[href=https://github.com/jbburt/wbplot]), a Python module (see materials and equipment[href=https://www.wicell.org#materials-and-equipment]) built upon Connectome Workbench commands (https://www.humanconnectome.org/software/connectome-workbench[href=https://www.humanconnectome.org/software/connectome-workbench]) to generate brain schematics in-line, such that wbplot can be called within an IDE or Jupyter Notebook. Functionality is limited and use of the workbench GUI is recommended for full visualization options and HCP integration.\nimgsrc:https://prod-shared-star-protocols.s3.amazonaws.com/protocols/1403-Fig6.jpg\nFigure 6. Activity flow mapped task activations compared to actual task activations across all nodes and one task\n(A) Activity-flow-predicted task activation patterns for one task condition (the win condition of the gambling task), across all MMP cortical regions (mean of N = 30 subjects).",
    "(B) The actual task activation patterns for the gambling (win) condition, across all MMP cortical regions (mean of N = 30 subjects). The predicted activations exhibited high similarity to the actual activations (r = 0.81, R2 = 0.64, MAE =5.12; see expected outcomes[href=https://www.wicell.org#sec3.5] for more on measuring accuracy with the ‘nodewise_compthenavg’ flag).\nNote: A pixdim warning message may appear; this can be ignored.\n# Visualize predicted and actual task activation patterns across all nodes and 1 task\ncond_ix = 2 # see task_names for corresponding task\nn_parcels = 360 # this should match n_nodes used upstream in code. 360 across-cortex MMP regions; 180 per hemisphere (Glasser et al., 2016)\n# Activity-flow-predicted activations for one task condition\ninputdata = np.mean(predicted_activations_array, axis=2)[:, cond_ix]\n# Flip hemispheres, since CAB-NP is ordered left-to-right, while wbplot uses right-to-left\ninputdata_flipped = np.zeros(np.shape(inputdata))\ninputdata_flipped[0:int(n_parcels / 2)] = inputdata[\n    int(n_parcels / 2):int(n_parcels)\n]\ninputdata_flipped[int(n_parcels / 2):int(n_parcels)] = inputdata[\n    0:int(n_parcels / 2)\n]\nfile_out = fig_directory + \"out.png\"\ncolormap = \"seismic\" # consider setting to all \"reds\" if no negative values\npscalar(file_out=file_out, pscalars=inputdata_flipped, cmap=colormap, transparent=True)\nimg = mpimg.imread(file_out)\nplt.figure()\nplt.axis(\"off\")\nplt.title(\"Predicted activations (\" + task_names[cond_ix] + \")\")\nplt.imshow(img)\n# Actual activations to one task condition\ninputdata = np.mean(actual_activations_array, axis=2)[:, cond_ix]\n# Flip hemispheres, since CAB-NP is ordered left-to-right, while wbplot uses right-to-left\ninputdata_flipped = np.zeros(np.shape(inputdata))\ninputdata_flipped[0:int(n_parcels / 2)] = inputdata[\n    int(n_parcels / 2):int(n_parcels)\n]\ninputdata_flipped[int(n_parcels / 2):int(n_parcels)] = inputdata[\n    0:int(n_parcels / 2)\n]\nfile_out = fig_directory + \"out.png\"\ncolormap = \"seismic\" # consider setting to all \"reds\" if no negative values\npscalar(file_out=file_out, pscalars=inputdata_flipped, cmap=colormap, transparent=True)\nimg = mpimg.imread(file_out)\nplt.figure()\nplt.axis(\"off\")\nplt.title(\"Actual activations (\" + task_names[cond_ix] + \")\")\nplt.imshow(img)\nExpected outcomes\nPrediction accuracy: model comparison report",
    "The core tool of the Actflow Toolbox, actflowtest (see part 3 in step-by-step method details[href=https://www.wicell.org#step-by-step-method-details]), by default returns a report of the prediction accuracy indices that assess how similar the activity-flow-predicted activations are to the actual activations (visualized in Figures 5[href=https://www.wicell.org#fig5] and 6[href=https://www.wicell.org#fig6]). These accuracy indices include: (1) Pearson r (with associated t-statistic and p-value), computed with numpy.corrcoef. (2) Variance explained via coefficient of determination (R2), computed with sklearn.metrics.r2_score. (3) Mean absolute error (MAE) (see Cole et al., 2016[href=https://www.wicell.org#bib5]), computed with NumPy functions corresponding to the following formula (n = number of subjects):\n  M A E =     Σ  i = 1  n   |  p r e d i c t e d − a c t u a l  |   n   \nA sample report from the Actflow Toolbox example dataset (see key resources table[href=https://www.wicell.org#key-resources-table]), which assessed n = 30 HCP S1200 subjects and utilized the resting-state FC estimated via combinedFC, printed as follows:\n===Comparing prediction accuracies between models (similarity between predicted and actual brain activation patterns)===\n==Comparisons between predicted and actual activation patterns, across all conditions and nodes:==\n--Compare-then-average (calculating prediction accuracies before cross-subject averaging):\nEach comparison based on 24 conditions across 360 nodes, p-values based on 30 subjects (cross-subject variance in comparisons)\nMean Pearson r = 0.81, t-value vs. 0: 64.44, p-value vs. 0: 7.31e-33\nMean % variance explained (Rˆ2 score, coeff. of determination) = 0.65\nMean MAE (mean absolute error) = 6.83\nNote: Pearson r and Pearson rˆ2 are scale-invariant, while Rˆ2 and MAE are not. Rˆ2 units: percentage of the to-be-predicted data's unscaled variance, ranging from negative infinity (because prediction errors can be arbitrarily large) to positive 1. See https://scikit-learn.org/stable/modules/generated/sklearn.metrics.r2_score.html for more info.",
    "By default, these assessments are based on an optional input variable, <comparison_type>, in the function model_compare.py (which is called within actflowtest), which has five possible options specified as strings: (1) comparison_type = \"fullcompare_compthenavg\": This is the default comparison method, where predicted and actual activations are compared across all conditions and nodes simultaneously. This is accomplished by collapsing the data across the condition and node dimensions with numpy.reshape. This process treats the variance between conditions and nodes equally, but independently per subject. The results are summarized (as in the provided sample report) with averages of the cross-subject accuracy indices. (2) comparison_type = \"conditionwise_compthenavg\": This is run separately for (i.e., iterated over) each subject and node, and comparisons are made between the predicted and actual activations across conditions. This can be thought of as characterizing the accuracy of a node’s response profile, or a profile of responses across all task conditions. The results are summarized by averaging over both the node and subject dimensions. (3) comparison_type = \"conditionwise_avgthencomp\": Here, predicted and actual activation data are averaged initially across subjects (sometimes called a fixed-effects analysis). Then, the comparisons are run separately for each node, comparing response profiles as in conditionwise_compthenavg. This will boost the signal-to-noise ratio of the activation data, but will reduce the ability to assess the spread of accuracy scores across subjects (which is possible with conditionwise_compthenavg). The results are summarized by averaging over the node dimension. (4) comparison_type = \"nodewise_compthenavg\": This is run separately for each subject and condition, and comparisons are made between the predicted and actual activations across nodes, or the whole-brain (or, whole-cortex, depending on which nodes are assessed with the Actflow Toolbox) activation patterns. These vectors can be thought of as a response profile across the brain to a given condition.",
    "The results are summarized by averaging over both the condition and subject dimensions. (5) comparison_type = \"nodewise_avgthencomp\": Here, predicted and actual activations are averaged initially across subjects. Then, comparisons are run separately for each condition, comparing the whole-brain response profiles to each condition. The results are summarized by averaging over the condition dimension.",
    "If a specific comparison type is required, users may specifically call the model_comparison function: see the quantification and statistical analysis[href=https://www.wicell.org#quantification-and-statistical-analysis] section for an example. If all comparison types are of interest, users may turn on another optional input variable in the actflowtest.py function, <full_report>, which is by default turned off, by using the following modification to the actflowtest code block in Part 3 (see Figure 6[href=https://www.wicell.org#fig6] for visualization of condition 3):\n# Return full model comparison report\nactflow_output = actflow.actflowcomp.actflowtest(\n  activity_data, fc_arr, full_report=True\n)\n==Condition-wise comparisons between predicted and actual activation patterns (calculated for each node separately):==\n--Compare-then-average (calculating prediction accuracies before cross-subject averaging):\nEach correlation based on N conditions: 24, p-values based on N subjects (cross-subject variance in correlations): 30\nMean Pearson r = 0.83, t-value vs. 0: 62.45, p-value vs. 0: 1.8026564213102585e-32\nMean % variance explained (Rˆ2 score, coeff. of determination) = 0.35\nMean MAE (mean absolute error) = 6.83\nNote: Pearson r and Pearson rˆ2 are scale-invariant, while Rˆ2 and MAE are not. Rˆ2 units: percentage of the to-be-predicted datas unscaled variance, ranging from negative infinity (because prediction errors can be arbitrarily large) to positive 1. See https://scikit-learn.org/stable/modules/generated/sklearn.metrics.r2_score.html for more info.\n==Node-wise (spatial) correlations between predicted and actual activation patterns (calculated for each condition separately):==\n--Compare-then-average (calculating prediction accuracies before cross-subject averaging):\nEach correlation based on N nodes: 360, p-values based on N subjects (cross-subject variance in correlations): 30\nCross-condition mean r=0.78, t-value vs. 0: 55.40, p-value vs. 0: 5.66e-31\nBy task condition:\nCondition 1: r=0.70, t-value vs. 0: 24.83, p-value vs. 0: 4.351151202867745e-21\nCondition 2: r=0.66, t-value vs. 0: 22.49, p-value vs. 0: 6.664353565074144e-20\nCondition 3: r=0.81, t-value vs. 0: 49.47, p-value vs. 0: 1.4548795509484526e-29\nCondition 4: r=0.81, t-value vs. 0: 44.23, p-value vs. 0: 3.61e-28",
    "Condition 5: r=0.71, t-value vs. 0: 28.35, p-value vs. 0: 1.08-22\nCondition 6: r=0.72, t-value vs. 0: 30.75, p-value vs. 0: 1.10e-23\nCondition 7: r=0.79, t-value vs. 0: 39.28, p-value vs. 0: 1.07e-26\nCondition 8: r=0.69, t-value vs. 0: 24.92, p-value vs. 0: 3.94e-21\nCondition 9: r=0.68, t-value vs. 0: 27.53, p-value vs. 0: 2.45e-22\nCondition 10: r=0.68, t-value vs. 0: 28.77, p-value vs. 0: 7.10e-23\nCondition 11: r=0.67, t-value vs. 0: 32.17, p-value vs. 0: 3.07e-24\nCondition 12: r=0.68, t-value vs. 0: 29.39, p-value vs. 0: 3.90e-23\nCondition 13: r=0.83, t-value vs. 0: 39.87, p-value vs. 0: 6.95e-27\nCondition 14: r=0.84, t-value vs. 0: 44.50, p-value vs. 0: 3.02e-28\nCondition 15: r=0.83, t-value vs. 0: 46.05, p-value vs. 0: 1.136e-28\nCondition 16: r=0.83, t-value vs. 0: 56.14, p-value vs. 0: 3.86e-31\nCondition 17: r=0.82, t-value vs. 0: 40.62, p-value vs. 0: 4.09e-27\nCondition 18: r=0.78, t-value vs. 0: 38.98, p-value vs. 0: 1.32e-26\nCondition 19: r=0.83, t-value vs. 0: 50.51, p-value vs. 0: 8.01e-30\nCondition 20: r=0.83, t-value vs. 0: 42.43, p-value vs. 0: 1.183e-27\nCondition 21: r=0.83, t-value vs. 0: 51.47, p-value vs. 0: 4.68e-30\nCondition 22: r=0.78, t-value vs. 0: 41.73, p-value vs. 0: 1.90e-27\nCondition 23: r=0.81, t-value vs. 0: 49.27, p-value vs. 0: 1.64e-29\nCondition 24: r=0.82, t-value vs. 0: 39.27, p-value vs. 0: 1.071e-26\nExpectations and considerations across research questions",
    "As of the time this protocol was prepared, the Actflow Toolbox (or its precursors) has been successfully applied to multiple datasets and task paradigms related to a variety of cognitive domains. These studies contain in-depth considerations for how activity flow mapping can be applied to various research questions, as well as expectations regarding prediction accuracy and related statistics. We have listed these studies in Table 1[href=https://www.wicell.org#tbl1] with study specifications highlighted, to operate as a reference guide for expected outcomes of specific research questions (note that future work with activity flow mapping need not be limited by the specifications in Table 1[href=https://www.wicell.org#tbl1]):\ntable:files/protocols_protocol_1403_1.csv\nNote: Unless stated otherwise, these studies in Table 1[href=https://www.wicell.org#tbl1] utilized fMRI data and resting-state connectivity estimates in the activity flow mapping procedure."
  ],
  "subjectAreas": [
    "Bioinformatics",
    "Systems Biology",
    "Computer Sciences",
    "Cognitive Neuroscience",
    "Neuroscience"
  ],
  "bigAreas": [
    "Biomedical & Clinical Research",
    "Molecular Biology & Genetics",
    "Bioinformatics & Computational Biology"
  ]
}